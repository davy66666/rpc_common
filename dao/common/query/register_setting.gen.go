// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package query

import (
	"context"
	"database/sql"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"github.com/davy66666/rpc_common/dao/model"
)

func newRegisterSetting(db *gorm.DB, opts ...gen.DOOption) registerSetting {
	_registerSetting := registerSetting{}

	_registerSetting.registerSettingDo.UseDB(db, opts...)
	_registerSetting.registerSettingDo.UseModel(&model.RegisterSetting{})

	tableName := _registerSetting.registerSettingDo.TableName()
	_registerSetting.ALL = field.NewAsterisk(tableName)
	_registerSetting.ID = field.NewInt64(tableName, "id")
	_registerSetting.KeyParam = field.NewString(tableName, "key_param")
	_registerSetting.IsShow = field.NewInt64(tableName, "is_show")
	_registerSetting.IsRequire = field.NewInt64(tableName, "is_require")
	_registerSetting.LimitNum = field.NewInt64(tableName, "limit_num")
	_registerSetting.AdminName = field.NewString(tableName, "admin_name")
	_registerSetting.CreatedAt = field.NewField(tableName, "created_at")

	_registerSetting.fillFieldMap()

	return _registerSetting
}

// registerSetting 会员注册设置表
type registerSetting struct {
	registerSettingDo registerSettingDo

	ALL       field.Asterisk
	ID        field.Int64
	KeyParam  field.String // 字段名称
	IsShow    field.Int64  // 是否展示 1/0 显示/隐藏
	IsRequire field.Int64  // 是否必填 1/0 是/否
	LimitNum  field.Int64  // 限制个数
	AdminName field.String // 最后一次操作人
	CreatedAt field.Field

	fieldMap map[string]field.Expr
}

func (r registerSetting) Table(newTableName string) *registerSetting {
	r.registerSettingDo.UseTable(newTableName)
	return r.updateTableName(newTableName)
}

func (r registerSetting) As(alias string) *registerSetting {
	r.registerSettingDo.DO = *(r.registerSettingDo.As(alias).(*gen.DO))
	return r.updateTableName(alias)
}

func (r *registerSetting) updateTableName(table string) *registerSetting {
	r.ALL = field.NewAsterisk(table)
	r.ID = field.NewInt64(table, "id")
	r.KeyParam = field.NewString(table, "key_param")
	r.IsShow = field.NewInt64(table, "is_show")
	r.IsRequire = field.NewInt64(table, "is_require")
	r.LimitNum = field.NewInt64(table, "limit_num")
	r.AdminName = field.NewString(table, "admin_name")
	r.CreatedAt = field.NewField(table, "created_at")

	r.fillFieldMap()

	return r
}

func (r *registerSetting) WithContext(ctx context.Context) IRegisterSettingDo {
	return r.registerSettingDo.WithContext(ctx)
}

func (r registerSetting) TableName() string { return r.registerSettingDo.TableName() }

func (r registerSetting) Alias() string { return r.registerSettingDo.Alias() }

func (r registerSetting) Columns(cols ...field.Expr) gen.Columns {
	return r.registerSettingDo.Columns(cols...)
}

func (r *registerSetting) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := r.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (r *registerSetting) fillFieldMap() {
	r.fieldMap = make(map[string]field.Expr, 7)
	r.fieldMap["id"] = r.ID
	r.fieldMap["key_param"] = r.KeyParam
	r.fieldMap["is_show"] = r.IsShow
	r.fieldMap["is_require"] = r.IsRequire
	r.fieldMap["limit_num"] = r.LimitNum
	r.fieldMap["admin_name"] = r.AdminName
	r.fieldMap["created_at"] = r.CreatedAt
}

func (r registerSetting) clone(db *gorm.DB) registerSetting {
	r.registerSettingDo.ReplaceConnPool(db.Statement.ConnPool)
	return r
}

func (r registerSetting) replaceDB(db *gorm.DB) registerSetting {
	r.registerSettingDo.ReplaceDB(db)
	return r
}

type registerSettingDo struct{ gen.DO }

type IRegisterSettingDo interface {
	gen.SubQuery
	Debug() IRegisterSettingDo
	WithContext(ctx context.Context) IRegisterSettingDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() IRegisterSettingDo
	WriteDB() IRegisterSettingDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) IRegisterSettingDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) IRegisterSettingDo
	Not(conds ...gen.Condition) IRegisterSettingDo
	Or(conds ...gen.Condition) IRegisterSettingDo
	Select(conds ...field.Expr) IRegisterSettingDo
	Where(conds ...gen.Condition) IRegisterSettingDo
	Order(conds ...field.Expr) IRegisterSettingDo
	Distinct(cols ...field.Expr) IRegisterSettingDo
	Omit(cols ...field.Expr) IRegisterSettingDo
	Join(table schema.Tabler, on ...field.Expr) IRegisterSettingDo
	LeftJoin(table schema.Tabler, on ...field.Expr) IRegisterSettingDo
	RightJoin(table schema.Tabler, on ...field.Expr) IRegisterSettingDo
	Group(cols ...field.Expr) IRegisterSettingDo
	Having(conds ...gen.Condition) IRegisterSettingDo
	Limit(limit int) IRegisterSettingDo
	Offset(offset int) IRegisterSettingDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) IRegisterSettingDo
	Unscoped() IRegisterSettingDo
	Create(values ...*model.RegisterSetting) error
	CreateInBatches(values []*model.RegisterSetting, batchSize int) error
	Save(values ...*model.RegisterSetting) error
	First() (*model.RegisterSetting, error)
	Take() (*model.RegisterSetting, error)
	Last() (*model.RegisterSetting, error)
	Find() ([]*model.RegisterSetting, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.RegisterSetting, err error)
	FindInBatches(result *[]*model.RegisterSetting, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.RegisterSetting) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) IRegisterSettingDo
	Assign(attrs ...field.AssignExpr) IRegisterSettingDo
	Joins(fields ...field.RelationField) IRegisterSettingDo
	Preload(fields ...field.RelationField) IRegisterSettingDo
	FirstOrInit() (*model.RegisterSetting, error)
	FirstOrCreate() (*model.RegisterSetting, error)
	FindByPage(offset int, limit int) (result []*model.RegisterSetting, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Rows() (*sql.Rows, error)
	Row() *sql.Row
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) IRegisterSettingDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (r registerSettingDo) Debug() IRegisterSettingDo {
	return r.withDO(r.DO.Debug())
}

func (r registerSettingDo) WithContext(ctx context.Context) IRegisterSettingDo {
	return r.withDO(r.DO.WithContext(ctx))
}

func (r registerSettingDo) ReadDB() IRegisterSettingDo {
	return r.Clauses(dbresolver.Read)
}

func (r registerSettingDo) WriteDB() IRegisterSettingDo {
	return r.Clauses(dbresolver.Write)
}

func (r registerSettingDo) Session(config *gorm.Session) IRegisterSettingDo {
	return r.withDO(r.DO.Session(config))
}

func (r registerSettingDo) Clauses(conds ...clause.Expression) IRegisterSettingDo {
	return r.withDO(r.DO.Clauses(conds...))
}

func (r registerSettingDo) Returning(value interface{}, columns ...string) IRegisterSettingDo {
	return r.withDO(r.DO.Returning(value, columns...))
}

func (r registerSettingDo) Not(conds ...gen.Condition) IRegisterSettingDo {
	return r.withDO(r.DO.Not(conds...))
}

func (r registerSettingDo) Or(conds ...gen.Condition) IRegisterSettingDo {
	return r.withDO(r.DO.Or(conds...))
}

func (r registerSettingDo) Select(conds ...field.Expr) IRegisterSettingDo {
	return r.withDO(r.DO.Select(conds...))
}

func (r registerSettingDo) Where(conds ...gen.Condition) IRegisterSettingDo {
	return r.withDO(r.DO.Where(conds...))
}

func (r registerSettingDo) Order(conds ...field.Expr) IRegisterSettingDo {
	return r.withDO(r.DO.Order(conds...))
}

func (r registerSettingDo) Distinct(cols ...field.Expr) IRegisterSettingDo {
	return r.withDO(r.DO.Distinct(cols...))
}

func (r registerSettingDo) Omit(cols ...field.Expr) IRegisterSettingDo {
	return r.withDO(r.DO.Omit(cols...))
}

func (r registerSettingDo) Join(table schema.Tabler, on ...field.Expr) IRegisterSettingDo {
	return r.withDO(r.DO.Join(table, on...))
}

func (r registerSettingDo) LeftJoin(table schema.Tabler, on ...field.Expr) IRegisterSettingDo {
	return r.withDO(r.DO.LeftJoin(table, on...))
}

func (r registerSettingDo) RightJoin(table schema.Tabler, on ...field.Expr) IRegisterSettingDo {
	return r.withDO(r.DO.RightJoin(table, on...))
}

func (r registerSettingDo) Group(cols ...field.Expr) IRegisterSettingDo {
	return r.withDO(r.DO.Group(cols...))
}

func (r registerSettingDo) Having(conds ...gen.Condition) IRegisterSettingDo {
	return r.withDO(r.DO.Having(conds...))
}

func (r registerSettingDo) Limit(limit int) IRegisterSettingDo {
	return r.withDO(r.DO.Limit(limit))
}

func (r registerSettingDo) Offset(offset int) IRegisterSettingDo {
	return r.withDO(r.DO.Offset(offset))
}

func (r registerSettingDo) Scopes(funcs ...func(gen.Dao) gen.Dao) IRegisterSettingDo {
	return r.withDO(r.DO.Scopes(funcs...))
}

func (r registerSettingDo) Unscoped() IRegisterSettingDo {
	return r.withDO(r.DO.Unscoped())
}

func (r registerSettingDo) Create(values ...*model.RegisterSetting) error {
	if len(values) == 0 {
		return nil
	}
	return r.DO.Create(values)
}

func (r registerSettingDo) CreateInBatches(values []*model.RegisterSetting, batchSize int) error {
	return r.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (r registerSettingDo) Save(values ...*model.RegisterSetting) error {
	if len(values) == 0 {
		return nil
	}
	return r.DO.Save(values)
}

func (r registerSettingDo) First() (*model.RegisterSetting, error) {
	if result, err := r.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.RegisterSetting), nil
	}
}

func (r registerSettingDo) Take() (*model.RegisterSetting, error) {
	if result, err := r.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.RegisterSetting), nil
	}
}

func (r registerSettingDo) Last() (*model.RegisterSetting, error) {
	if result, err := r.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.RegisterSetting), nil
	}
}

func (r registerSettingDo) Find() ([]*model.RegisterSetting, error) {
	result, err := r.DO.Find()
	return result.([]*model.RegisterSetting), err
}

func (r registerSettingDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.RegisterSetting, err error) {
	buf := make([]*model.RegisterSetting, 0, batchSize)
	err = r.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (r registerSettingDo) FindInBatches(result *[]*model.RegisterSetting, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return r.DO.FindInBatches(result, batchSize, fc)
}

func (r registerSettingDo) Attrs(attrs ...field.AssignExpr) IRegisterSettingDo {
	return r.withDO(r.DO.Attrs(attrs...))
}

func (r registerSettingDo) Assign(attrs ...field.AssignExpr) IRegisterSettingDo {
	return r.withDO(r.DO.Assign(attrs...))
}

func (r registerSettingDo) Joins(fields ...field.RelationField) IRegisterSettingDo {
	for _, _f := range fields {
		r = *r.withDO(r.DO.Joins(_f))
	}
	return &r
}

func (r registerSettingDo) Preload(fields ...field.RelationField) IRegisterSettingDo {
	for _, _f := range fields {
		r = *r.withDO(r.DO.Preload(_f))
	}
	return &r
}

func (r registerSettingDo) FirstOrInit() (*model.RegisterSetting, error) {
	if result, err := r.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.RegisterSetting), nil
	}
}

func (r registerSettingDo) FirstOrCreate() (*model.RegisterSetting, error) {
	if result, err := r.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.RegisterSetting), nil
	}
}

func (r registerSettingDo) FindByPage(offset int, limit int) (result []*model.RegisterSetting, count int64, err error) {
	result, err = r.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = r.Offset(-1).Limit(-1).Count()
	return
}

func (r registerSettingDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = r.Count()
	if err != nil {
		return
	}

	err = r.Offset(offset).Limit(limit).Scan(result)
	return
}

func (r registerSettingDo) Scan(result interface{}) (err error) {
	return r.DO.Scan(result)
}

func (r registerSettingDo) Delete(models ...*model.RegisterSetting) (result gen.ResultInfo, err error) {
	return r.DO.Delete(models)
}

func (r *registerSettingDo) withDO(do gen.Dao) *registerSettingDo {
	r.DO = *do.(*gen.DO)
	return r
}
