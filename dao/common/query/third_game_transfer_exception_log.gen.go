// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package query

import (
	"context"
	"database/sql"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"github.com/davy66666/rpc_common/dao/model"
)

func newThirdGameTransferExceptionLog(db *gorm.DB, opts ...gen.DOOption) thirdGameTransferExceptionLog {
	_thirdGameTransferExceptionLog := thirdGameTransferExceptionLog{}

	_thirdGameTransferExceptionLog.thirdGameTransferExceptionLogDo.UseDB(db, opts...)
	_thirdGameTransferExceptionLog.thirdGameTransferExceptionLogDo.UseModel(&model.ThirdGameTransferExceptionLog{})

	tableName := _thirdGameTransferExceptionLog.thirdGameTransferExceptionLogDo.TableName()
	_thirdGameTransferExceptionLog.ALL = field.NewAsterisk(tableName)
	_thirdGameTransferExceptionLog.ID = field.NewInt64(tableName, "id")
	_thirdGameTransferExceptionLog.UserID = field.NewInt64(tableName, "user_id")
	_thirdGameTransferExceptionLog.Username = field.NewString(tableName, "username")
	_thirdGameTransferExceptionLog.Amount = field.NewFloat64(tableName, "amount")
	_thirdGameTransferExceptionLog.TransFatherID = field.NewInt64(tableName, "trans_father_id")
	_thirdGameTransferExceptionLog.TransTypesID = field.NewInt64(tableName, "trans_types_id")
	_thirdGameTransferExceptionLog.TransTypesCnTitle = field.NewString(tableName, "trans_types_cn_title")
	_thirdGameTransferExceptionLog.BeforeMoney = field.NewFloat64(tableName, "before_money")
	_thirdGameTransferExceptionLog.Money = field.NewFloat64(tableName, "money")
	_thirdGameTransferExceptionLog.GameCode = field.NewString(tableName, "game_code")
	_thirdGameTransferExceptionLog.GameName = field.NewString(tableName, "game_name")
	_thirdGameTransferExceptionLog.BillID = field.NewString(tableName, "bill_id")
	_thirdGameTransferExceptionLog.Status = field.NewInt64(tableName, "status")
	_thirdGameTransferExceptionLog.Description = field.NewString(tableName, "description")
	_thirdGameTransferExceptionLog.FilePath = field.NewString(tableName, "file_path")
	_thirdGameTransferExceptionLog.ExtendData = field.NewString(tableName, "extend_data")
	_thirdGameTransferExceptionLog.CreatedAt = field.NewField(tableName, "created_at")
	_thirdGameTransferExceptionLog.UpdatedAt = field.NewField(tableName, "updated_at")

	_thirdGameTransferExceptionLog.fillFieldMap()

	return _thirdGameTransferExceptionLog
}

// thirdGameTransferExceptionLog 第三方游戏转账异常log
type thirdGameTransferExceptionLog struct {
	thirdGameTransferExceptionLogDo thirdGameTransferExceptionLogDo

	ALL               field.Asterisk
	ID                field.Int64
	UserID            field.Int64   // 用户Id
	Username          field.String  // 用户名
	Amount            field.Float64 // 用户当前交易金额
	TransFatherID     field.Int64   // 账变类型父类
	TransTypesID      field.Int64   // 账变类型
	TransTypesCnTitle field.String  // 账变中文名称
	BeforeMoney       field.Float64 // 交易前金额
	Money             field.Float64 // 交易后金额
	GameCode          field.String  // 游戏gameCode
	GameName          field.String  // 游戏名称
	BillID            field.String  // 订单id
	Status            field.Int64   // 状态：0 第三方接口转账成功，未回滚（额度丢失），1：第三方接口转账成功，已回滚
	Description       field.String  // 转账说明
	FilePath          field.String  // 代码所在文件路径
	ExtendData        field.String  // 请求参数
	CreatedAt         field.Field
	UpdatedAt         field.Field

	fieldMap map[string]field.Expr
}

func (t thirdGameTransferExceptionLog) Table(newTableName string) *thirdGameTransferExceptionLog {
	t.thirdGameTransferExceptionLogDo.UseTable(newTableName)
	return t.updateTableName(newTableName)
}

func (t thirdGameTransferExceptionLog) As(alias string) *thirdGameTransferExceptionLog {
	t.thirdGameTransferExceptionLogDo.DO = *(t.thirdGameTransferExceptionLogDo.As(alias).(*gen.DO))
	return t.updateTableName(alias)
}

func (t *thirdGameTransferExceptionLog) updateTableName(table string) *thirdGameTransferExceptionLog {
	t.ALL = field.NewAsterisk(table)
	t.ID = field.NewInt64(table, "id")
	t.UserID = field.NewInt64(table, "user_id")
	t.Username = field.NewString(table, "username")
	t.Amount = field.NewFloat64(table, "amount")
	t.TransFatherID = field.NewInt64(table, "trans_father_id")
	t.TransTypesID = field.NewInt64(table, "trans_types_id")
	t.TransTypesCnTitle = field.NewString(table, "trans_types_cn_title")
	t.BeforeMoney = field.NewFloat64(table, "before_money")
	t.Money = field.NewFloat64(table, "money")
	t.GameCode = field.NewString(table, "game_code")
	t.GameName = field.NewString(table, "game_name")
	t.BillID = field.NewString(table, "bill_id")
	t.Status = field.NewInt64(table, "status")
	t.Description = field.NewString(table, "description")
	t.FilePath = field.NewString(table, "file_path")
	t.ExtendData = field.NewString(table, "extend_data")
	t.CreatedAt = field.NewField(table, "created_at")
	t.UpdatedAt = field.NewField(table, "updated_at")

	t.fillFieldMap()

	return t
}

func (t *thirdGameTransferExceptionLog) WithContext(ctx context.Context) IThirdGameTransferExceptionLogDo {
	return t.thirdGameTransferExceptionLogDo.WithContext(ctx)
}

func (t thirdGameTransferExceptionLog) TableName() string {
	return t.thirdGameTransferExceptionLogDo.TableName()
}

func (t thirdGameTransferExceptionLog) Alias() string {
	return t.thirdGameTransferExceptionLogDo.Alias()
}

func (t thirdGameTransferExceptionLog) Columns(cols ...field.Expr) gen.Columns {
	return t.thirdGameTransferExceptionLogDo.Columns(cols...)
}

func (t *thirdGameTransferExceptionLog) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := t.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (t *thirdGameTransferExceptionLog) fillFieldMap() {
	t.fieldMap = make(map[string]field.Expr, 18)
	t.fieldMap["id"] = t.ID
	t.fieldMap["user_id"] = t.UserID
	t.fieldMap["username"] = t.Username
	t.fieldMap["amount"] = t.Amount
	t.fieldMap["trans_father_id"] = t.TransFatherID
	t.fieldMap["trans_types_id"] = t.TransTypesID
	t.fieldMap["trans_types_cn_title"] = t.TransTypesCnTitle
	t.fieldMap["before_money"] = t.BeforeMoney
	t.fieldMap["money"] = t.Money
	t.fieldMap["game_code"] = t.GameCode
	t.fieldMap["game_name"] = t.GameName
	t.fieldMap["bill_id"] = t.BillID
	t.fieldMap["status"] = t.Status
	t.fieldMap["description"] = t.Description
	t.fieldMap["file_path"] = t.FilePath
	t.fieldMap["extend_data"] = t.ExtendData
	t.fieldMap["created_at"] = t.CreatedAt
	t.fieldMap["updated_at"] = t.UpdatedAt
}

func (t thirdGameTransferExceptionLog) clone(db *gorm.DB) thirdGameTransferExceptionLog {
	t.thirdGameTransferExceptionLogDo.ReplaceConnPool(db.Statement.ConnPool)
	return t
}

func (t thirdGameTransferExceptionLog) replaceDB(db *gorm.DB) thirdGameTransferExceptionLog {
	t.thirdGameTransferExceptionLogDo.ReplaceDB(db)
	return t
}

type thirdGameTransferExceptionLogDo struct{ gen.DO }

type IThirdGameTransferExceptionLogDo interface {
	gen.SubQuery
	Debug() IThirdGameTransferExceptionLogDo
	WithContext(ctx context.Context) IThirdGameTransferExceptionLogDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() IThirdGameTransferExceptionLogDo
	WriteDB() IThirdGameTransferExceptionLogDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) IThirdGameTransferExceptionLogDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) IThirdGameTransferExceptionLogDo
	Not(conds ...gen.Condition) IThirdGameTransferExceptionLogDo
	Or(conds ...gen.Condition) IThirdGameTransferExceptionLogDo
	Select(conds ...field.Expr) IThirdGameTransferExceptionLogDo
	Where(conds ...gen.Condition) IThirdGameTransferExceptionLogDo
	Order(conds ...field.Expr) IThirdGameTransferExceptionLogDo
	Distinct(cols ...field.Expr) IThirdGameTransferExceptionLogDo
	Omit(cols ...field.Expr) IThirdGameTransferExceptionLogDo
	Join(table schema.Tabler, on ...field.Expr) IThirdGameTransferExceptionLogDo
	LeftJoin(table schema.Tabler, on ...field.Expr) IThirdGameTransferExceptionLogDo
	RightJoin(table schema.Tabler, on ...field.Expr) IThirdGameTransferExceptionLogDo
	Group(cols ...field.Expr) IThirdGameTransferExceptionLogDo
	Having(conds ...gen.Condition) IThirdGameTransferExceptionLogDo
	Limit(limit int) IThirdGameTransferExceptionLogDo
	Offset(offset int) IThirdGameTransferExceptionLogDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) IThirdGameTransferExceptionLogDo
	Unscoped() IThirdGameTransferExceptionLogDo
	Create(values ...*model.ThirdGameTransferExceptionLog) error
	CreateInBatches(values []*model.ThirdGameTransferExceptionLog, batchSize int) error
	Save(values ...*model.ThirdGameTransferExceptionLog) error
	First() (*model.ThirdGameTransferExceptionLog, error)
	Take() (*model.ThirdGameTransferExceptionLog, error)
	Last() (*model.ThirdGameTransferExceptionLog, error)
	Find() ([]*model.ThirdGameTransferExceptionLog, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.ThirdGameTransferExceptionLog, err error)
	FindInBatches(result *[]*model.ThirdGameTransferExceptionLog, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.ThirdGameTransferExceptionLog) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) IThirdGameTransferExceptionLogDo
	Assign(attrs ...field.AssignExpr) IThirdGameTransferExceptionLogDo
	Joins(fields ...field.RelationField) IThirdGameTransferExceptionLogDo
	Preload(fields ...field.RelationField) IThirdGameTransferExceptionLogDo
	FirstOrInit() (*model.ThirdGameTransferExceptionLog, error)
	FirstOrCreate() (*model.ThirdGameTransferExceptionLog, error)
	FindByPage(offset int, limit int) (result []*model.ThirdGameTransferExceptionLog, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Rows() (*sql.Rows, error)
	Row() *sql.Row
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) IThirdGameTransferExceptionLogDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (t thirdGameTransferExceptionLogDo) Debug() IThirdGameTransferExceptionLogDo {
	return t.withDO(t.DO.Debug())
}

func (t thirdGameTransferExceptionLogDo) WithContext(ctx context.Context) IThirdGameTransferExceptionLogDo {
	return t.withDO(t.DO.WithContext(ctx))
}

func (t thirdGameTransferExceptionLogDo) ReadDB() IThirdGameTransferExceptionLogDo {
	return t.Clauses(dbresolver.Read)
}

func (t thirdGameTransferExceptionLogDo) WriteDB() IThirdGameTransferExceptionLogDo {
	return t.Clauses(dbresolver.Write)
}

func (t thirdGameTransferExceptionLogDo) Session(config *gorm.Session) IThirdGameTransferExceptionLogDo {
	return t.withDO(t.DO.Session(config))
}

func (t thirdGameTransferExceptionLogDo) Clauses(conds ...clause.Expression) IThirdGameTransferExceptionLogDo {
	return t.withDO(t.DO.Clauses(conds...))
}

func (t thirdGameTransferExceptionLogDo) Returning(value interface{}, columns ...string) IThirdGameTransferExceptionLogDo {
	return t.withDO(t.DO.Returning(value, columns...))
}

func (t thirdGameTransferExceptionLogDo) Not(conds ...gen.Condition) IThirdGameTransferExceptionLogDo {
	return t.withDO(t.DO.Not(conds...))
}

func (t thirdGameTransferExceptionLogDo) Or(conds ...gen.Condition) IThirdGameTransferExceptionLogDo {
	return t.withDO(t.DO.Or(conds...))
}

func (t thirdGameTransferExceptionLogDo) Select(conds ...field.Expr) IThirdGameTransferExceptionLogDo {
	return t.withDO(t.DO.Select(conds...))
}

func (t thirdGameTransferExceptionLogDo) Where(conds ...gen.Condition) IThirdGameTransferExceptionLogDo {
	return t.withDO(t.DO.Where(conds...))
}

func (t thirdGameTransferExceptionLogDo) Order(conds ...field.Expr) IThirdGameTransferExceptionLogDo {
	return t.withDO(t.DO.Order(conds...))
}

func (t thirdGameTransferExceptionLogDo) Distinct(cols ...field.Expr) IThirdGameTransferExceptionLogDo {
	return t.withDO(t.DO.Distinct(cols...))
}

func (t thirdGameTransferExceptionLogDo) Omit(cols ...field.Expr) IThirdGameTransferExceptionLogDo {
	return t.withDO(t.DO.Omit(cols...))
}

func (t thirdGameTransferExceptionLogDo) Join(table schema.Tabler, on ...field.Expr) IThirdGameTransferExceptionLogDo {
	return t.withDO(t.DO.Join(table, on...))
}

func (t thirdGameTransferExceptionLogDo) LeftJoin(table schema.Tabler, on ...field.Expr) IThirdGameTransferExceptionLogDo {
	return t.withDO(t.DO.LeftJoin(table, on...))
}

func (t thirdGameTransferExceptionLogDo) RightJoin(table schema.Tabler, on ...field.Expr) IThirdGameTransferExceptionLogDo {
	return t.withDO(t.DO.RightJoin(table, on...))
}

func (t thirdGameTransferExceptionLogDo) Group(cols ...field.Expr) IThirdGameTransferExceptionLogDo {
	return t.withDO(t.DO.Group(cols...))
}

func (t thirdGameTransferExceptionLogDo) Having(conds ...gen.Condition) IThirdGameTransferExceptionLogDo {
	return t.withDO(t.DO.Having(conds...))
}

func (t thirdGameTransferExceptionLogDo) Limit(limit int) IThirdGameTransferExceptionLogDo {
	return t.withDO(t.DO.Limit(limit))
}

func (t thirdGameTransferExceptionLogDo) Offset(offset int) IThirdGameTransferExceptionLogDo {
	return t.withDO(t.DO.Offset(offset))
}

func (t thirdGameTransferExceptionLogDo) Scopes(funcs ...func(gen.Dao) gen.Dao) IThirdGameTransferExceptionLogDo {
	return t.withDO(t.DO.Scopes(funcs...))
}

func (t thirdGameTransferExceptionLogDo) Unscoped() IThirdGameTransferExceptionLogDo {
	return t.withDO(t.DO.Unscoped())
}

func (t thirdGameTransferExceptionLogDo) Create(values ...*model.ThirdGameTransferExceptionLog) error {
	if len(values) == 0 {
		return nil
	}
	return t.DO.Create(values)
}

func (t thirdGameTransferExceptionLogDo) CreateInBatches(values []*model.ThirdGameTransferExceptionLog, batchSize int) error {
	return t.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (t thirdGameTransferExceptionLogDo) Save(values ...*model.ThirdGameTransferExceptionLog) error {
	if len(values) == 0 {
		return nil
	}
	return t.DO.Save(values)
}

func (t thirdGameTransferExceptionLogDo) First() (*model.ThirdGameTransferExceptionLog, error) {
	if result, err := t.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.ThirdGameTransferExceptionLog), nil
	}
}

func (t thirdGameTransferExceptionLogDo) Take() (*model.ThirdGameTransferExceptionLog, error) {
	if result, err := t.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.ThirdGameTransferExceptionLog), nil
	}
}

func (t thirdGameTransferExceptionLogDo) Last() (*model.ThirdGameTransferExceptionLog, error) {
	if result, err := t.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.ThirdGameTransferExceptionLog), nil
	}
}

func (t thirdGameTransferExceptionLogDo) Find() ([]*model.ThirdGameTransferExceptionLog, error) {
	result, err := t.DO.Find()
	return result.([]*model.ThirdGameTransferExceptionLog), err
}

func (t thirdGameTransferExceptionLogDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.ThirdGameTransferExceptionLog, err error) {
	buf := make([]*model.ThirdGameTransferExceptionLog, 0, batchSize)
	err = t.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (t thirdGameTransferExceptionLogDo) FindInBatches(result *[]*model.ThirdGameTransferExceptionLog, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return t.DO.FindInBatches(result, batchSize, fc)
}

func (t thirdGameTransferExceptionLogDo) Attrs(attrs ...field.AssignExpr) IThirdGameTransferExceptionLogDo {
	return t.withDO(t.DO.Attrs(attrs...))
}

func (t thirdGameTransferExceptionLogDo) Assign(attrs ...field.AssignExpr) IThirdGameTransferExceptionLogDo {
	return t.withDO(t.DO.Assign(attrs...))
}

func (t thirdGameTransferExceptionLogDo) Joins(fields ...field.RelationField) IThirdGameTransferExceptionLogDo {
	for _, _f := range fields {
		t = *t.withDO(t.DO.Joins(_f))
	}
	return &t
}

func (t thirdGameTransferExceptionLogDo) Preload(fields ...field.RelationField) IThirdGameTransferExceptionLogDo {
	for _, _f := range fields {
		t = *t.withDO(t.DO.Preload(_f))
	}
	return &t
}

func (t thirdGameTransferExceptionLogDo) FirstOrInit() (*model.ThirdGameTransferExceptionLog, error) {
	if result, err := t.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.ThirdGameTransferExceptionLog), nil
	}
}

func (t thirdGameTransferExceptionLogDo) FirstOrCreate() (*model.ThirdGameTransferExceptionLog, error) {
	if result, err := t.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.ThirdGameTransferExceptionLog), nil
	}
}

func (t thirdGameTransferExceptionLogDo) FindByPage(offset int, limit int) (result []*model.ThirdGameTransferExceptionLog, count int64, err error) {
	result, err = t.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = t.Offset(-1).Limit(-1).Count()
	return
}

func (t thirdGameTransferExceptionLogDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = t.Count()
	if err != nil {
		return
	}

	err = t.Offset(offset).Limit(limit).Scan(result)
	return
}

func (t thirdGameTransferExceptionLogDo) Scan(result interface{}) (err error) {
	return t.DO.Scan(result)
}

func (t thirdGameTransferExceptionLogDo) Delete(models ...*model.ThirdGameTransferExceptionLog) (result gen.ResultInfo, err error) {
	return t.DO.Delete(models)
}

func (t *thirdGameTransferExceptionLogDo) withDO(do gen.Dao) *thirdGameTransferExceptionLogDo {
	t.DO = *do.(*gen.DO)
	return t
}
