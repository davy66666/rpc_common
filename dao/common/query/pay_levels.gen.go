// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package query

import (
	"context"
	"database/sql"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"github.com/davy66666/rpc_common/dao/model"
)

func newPayLevel(db *gorm.DB, opts ...gen.DOOption) payLevel {
	_payLevel := payLevel{}

	_payLevel.payLevelDo.UseDB(db, opts...)
	_payLevel.payLevelDo.UseModel(&model.PayLevel{})

	tableName := _payLevel.payLevelDo.TableName()
	_payLevel.ALL = field.NewAsterisk(tableName)
	_payLevel.ID = field.NewInt64(tableName, "id")
	_payLevel.EnName = field.NewString(tableName, "en_name")
	_payLevel.CnName = field.NewString(tableName, "cn_name")
	_payLevel.PcBindPay = field.NewString(tableName, "pc_bind_pay")
	_payLevel.BindPay = field.NewString(tableName, "bind_pay")
	_payLevel.MaxFanshui = field.NewFloat64(tableName, "max_fanshui")
	_payLevel.Sort = field.NewInt64(tableName, "sort")
	_payLevel.Remark = field.NewString(tableName, "remark")
	_payLevel.Editor = field.NewString(tableName, "editor")
	_payLevel.IsDefault = field.NewInt64(tableName, "is_default")
	_payLevel.IsOpen = field.NewInt64(tableName, "is_open")
	_payLevel.CreatedAt = field.NewField(tableName, "created_at")
	_payLevel.UpdatedAt = field.NewField(tableName, "updated_at")
	_payLevel.DingshiMaxFanshui = field.NewFloat64(tableName, "dingshi_max_fanshui")
	_payLevel.CanRedPacket = field.NewInt64(tableName, "can_red_packet")
	_payLevel.CanFanshui = field.NewInt64(tableName, "can_fanshui")
	_payLevel.CanRecommendFanshui = field.NewInt64(tableName, "can_recommend_fanshui")
	_payLevel.CanPromotionMoney = field.NewInt64(tableName, "can_promotion_money")
	_payLevel.CanWeekMoney = field.NewInt64(tableName, "can_week_money")
	_payLevel.CanMonthMoney = field.NewInt64(tableName, "can_month_money")
	_payLevel.CanBirthdayMoney = field.NewInt64(tableName, "can_birthday_money")
	_payLevel.PcBindPayType = field.NewString(tableName, "pc_bind_pay_type")
	_payLevel.MobileBindPayType = field.NewString(tableName, "mobile_bind_pay_type")
	_payLevel.IncomeMaxLimit = field.NewInt64(tableName, "income_max_limit")
	_payLevel.RechargeTimes = field.NewInt64(tableName, "recharge_times")
	_payLevel.SingleRechargeAmount = field.NewInt64(tableName, "single_recharge_amount")
	_payLevel.IsLock = field.NewInt64(tableName, "is_lock")
	_payLevel.WithdrawTimes = field.NewInt64(tableName, "withdraw_times")
	_payLevel.QuickRechargeUploadPic = field.NewInt64(tableName, "quick_recharge_upload_pic")
	_payLevel.QuickRechargeUploadVideo = field.NewInt64(tableName, "quick_recharge_upload_video")
	_payLevel.BankStatementUploadPic = field.NewInt64(tableName, "bank_statement_upload_pic")
	_payLevel.UserCount = field.NewInt64(tableName, "user_count")
	_payLevel.YhzcDiscountRate = field.NewFloat64(tableName, "yhzc_discount_rate")

	_payLevel.fillFieldMap()

	return _payLevel
}

// payLevel 支付层级
type payLevel struct {
	payLevelDo payLevelDo

	ALL                      field.Asterisk
	ID                       field.Int64
	EnName                   field.String  // 层级名称英文名
	CnName                   field.String  // 层级名称中文名
	PcBindPay                field.String  // PC绑定的支付以json格式存储{支付类en_name:[具体支付id,以逗号分隔]
	BindPay                  field.String  // 绑定的支付以json格式存储{支付类en_name:[具体支付id,以逗号分隔]
	MaxFanshui               field.Float64 // 实时返水最高额
	Sort                     field.Int64   // 排序
	Remark                   field.String  // 备注
	Editor                   field.String  // 编辑者
	IsDefault                field.Int64   // 是否默认层级0:否;1:是
	IsOpen                   field.Int64   // 是否开启0:否;1:是
	CreatedAt                field.Field
	UpdatedAt                field.Field
	DingshiMaxFanshui        field.Float64 // 定时反水最高额
	CanRedPacket             field.Int64   // 是否容许抢红包0:不可以;1:可以
	CanFanshui               field.Int64   // 是否容许返水
	CanRecommendFanshui      field.Int64   // 是否容许推荐返水：0:不可以;1:可以
	CanPromotionMoney        field.Int64   // 是否可领VIP晋级彩金 0:不可以;1:可以
	CanWeekMoney             field.Int64   // 是否可领VIP周俸禄 0:不可以;1:可以
	CanMonthMoney            field.Int64   // 是否可领VIP月俸禄 0:不可以;1:可以
	CanBirthdayMoney         field.Int64   // 是否可领生日礼金 0:不可以;1:可以
	PcBindPayType            field.String  // pc绑定通道，以逗号分隔通道en_name
	MobileBindPayType        field.String  // mobile绑定通道，以逗号分隔通道en_name
	IncomeMaxLimit           field.Int64   // 单笔入款限制
	RechargeTimes            field.Int64   // 充值次数
	SingleRechargeAmount     field.Int64   // 单次充值金额
	IsLock                   field.Int64   // 是否锁定自动升级
	WithdrawTimes            field.Int64   // 取款次数
	QuickRechargeUploadPic   field.Int64   // 0:极速充值不需要上传图片凭证,1:极速充值需要上传图片凭证
	QuickRechargeUploadVideo field.Int64   // 0:极速充值不需要上传视频凭证,1:极速充值需要上传视频凭证
	BankStatementUploadPic   field.Int64   // 是否需要上传资金流水图 0:不需要 1:需要
	UserCount                field.Int64   // 会员数
	YhzcDiscountRate         field.Float64 // 易汇直充优惠比例

	fieldMap map[string]field.Expr
}

func (p payLevel) Table(newTableName string) *payLevel {
	p.payLevelDo.UseTable(newTableName)
	return p.updateTableName(newTableName)
}

func (p payLevel) As(alias string) *payLevel {
	p.payLevelDo.DO = *(p.payLevelDo.As(alias).(*gen.DO))
	return p.updateTableName(alias)
}

func (p *payLevel) updateTableName(table string) *payLevel {
	p.ALL = field.NewAsterisk(table)
	p.ID = field.NewInt64(table, "id")
	p.EnName = field.NewString(table, "en_name")
	p.CnName = field.NewString(table, "cn_name")
	p.PcBindPay = field.NewString(table, "pc_bind_pay")
	p.BindPay = field.NewString(table, "bind_pay")
	p.MaxFanshui = field.NewFloat64(table, "max_fanshui")
	p.Sort = field.NewInt64(table, "sort")
	p.Remark = field.NewString(table, "remark")
	p.Editor = field.NewString(table, "editor")
	p.IsDefault = field.NewInt64(table, "is_default")
	p.IsOpen = field.NewInt64(table, "is_open")
	p.CreatedAt = field.NewField(table, "created_at")
	p.UpdatedAt = field.NewField(table, "updated_at")
	p.DingshiMaxFanshui = field.NewFloat64(table, "dingshi_max_fanshui")
	p.CanRedPacket = field.NewInt64(table, "can_red_packet")
	p.CanFanshui = field.NewInt64(table, "can_fanshui")
	p.CanRecommendFanshui = field.NewInt64(table, "can_recommend_fanshui")
	p.CanPromotionMoney = field.NewInt64(table, "can_promotion_money")
	p.CanWeekMoney = field.NewInt64(table, "can_week_money")
	p.CanMonthMoney = field.NewInt64(table, "can_month_money")
	p.CanBirthdayMoney = field.NewInt64(table, "can_birthday_money")
	p.PcBindPayType = field.NewString(table, "pc_bind_pay_type")
	p.MobileBindPayType = field.NewString(table, "mobile_bind_pay_type")
	p.IncomeMaxLimit = field.NewInt64(table, "income_max_limit")
	p.RechargeTimes = field.NewInt64(table, "recharge_times")
	p.SingleRechargeAmount = field.NewInt64(table, "single_recharge_amount")
	p.IsLock = field.NewInt64(table, "is_lock")
	p.WithdrawTimes = field.NewInt64(table, "withdraw_times")
	p.QuickRechargeUploadPic = field.NewInt64(table, "quick_recharge_upload_pic")
	p.QuickRechargeUploadVideo = field.NewInt64(table, "quick_recharge_upload_video")
	p.BankStatementUploadPic = field.NewInt64(table, "bank_statement_upload_pic")
	p.UserCount = field.NewInt64(table, "user_count")
	p.YhzcDiscountRate = field.NewFloat64(table, "yhzc_discount_rate")

	p.fillFieldMap()

	return p
}

func (p *payLevel) WithContext(ctx context.Context) IPayLevelDo { return p.payLevelDo.WithContext(ctx) }

func (p payLevel) TableName() string { return p.payLevelDo.TableName() }

func (p payLevel) Alias() string { return p.payLevelDo.Alias() }

func (p payLevel) Columns(cols ...field.Expr) gen.Columns { return p.payLevelDo.Columns(cols...) }

func (p *payLevel) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := p.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (p *payLevel) fillFieldMap() {
	p.fieldMap = make(map[string]field.Expr, 33)
	p.fieldMap["id"] = p.ID
	p.fieldMap["en_name"] = p.EnName
	p.fieldMap["cn_name"] = p.CnName
	p.fieldMap["pc_bind_pay"] = p.PcBindPay
	p.fieldMap["bind_pay"] = p.BindPay
	p.fieldMap["max_fanshui"] = p.MaxFanshui
	p.fieldMap["sort"] = p.Sort
	p.fieldMap["remark"] = p.Remark
	p.fieldMap["editor"] = p.Editor
	p.fieldMap["is_default"] = p.IsDefault
	p.fieldMap["is_open"] = p.IsOpen
	p.fieldMap["created_at"] = p.CreatedAt
	p.fieldMap["updated_at"] = p.UpdatedAt
	p.fieldMap["dingshi_max_fanshui"] = p.DingshiMaxFanshui
	p.fieldMap["can_red_packet"] = p.CanRedPacket
	p.fieldMap["can_fanshui"] = p.CanFanshui
	p.fieldMap["can_recommend_fanshui"] = p.CanRecommendFanshui
	p.fieldMap["can_promotion_money"] = p.CanPromotionMoney
	p.fieldMap["can_week_money"] = p.CanWeekMoney
	p.fieldMap["can_month_money"] = p.CanMonthMoney
	p.fieldMap["can_birthday_money"] = p.CanBirthdayMoney
	p.fieldMap["pc_bind_pay_type"] = p.PcBindPayType
	p.fieldMap["mobile_bind_pay_type"] = p.MobileBindPayType
	p.fieldMap["income_max_limit"] = p.IncomeMaxLimit
	p.fieldMap["recharge_times"] = p.RechargeTimes
	p.fieldMap["single_recharge_amount"] = p.SingleRechargeAmount
	p.fieldMap["is_lock"] = p.IsLock
	p.fieldMap["withdraw_times"] = p.WithdrawTimes
	p.fieldMap["quick_recharge_upload_pic"] = p.QuickRechargeUploadPic
	p.fieldMap["quick_recharge_upload_video"] = p.QuickRechargeUploadVideo
	p.fieldMap["bank_statement_upload_pic"] = p.BankStatementUploadPic
	p.fieldMap["user_count"] = p.UserCount
	p.fieldMap["yhzc_discount_rate"] = p.YhzcDiscountRate
}

func (p payLevel) clone(db *gorm.DB) payLevel {
	p.payLevelDo.ReplaceConnPool(db.Statement.ConnPool)
	return p
}

func (p payLevel) replaceDB(db *gorm.DB) payLevel {
	p.payLevelDo.ReplaceDB(db)
	return p
}

type payLevelDo struct{ gen.DO }

type IPayLevelDo interface {
	gen.SubQuery
	Debug() IPayLevelDo
	WithContext(ctx context.Context) IPayLevelDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() IPayLevelDo
	WriteDB() IPayLevelDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) IPayLevelDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) IPayLevelDo
	Not(conds ...gen.Condition) IPayLevelDo
	Or(conds ...gen.Condition) IPayLevelDo
	Select(conds ...field.Expr) IPayLevelDo
	Where(conds ...gen.Condition) IPayLevelDo
	Order(conds ...field.Expr) IPayLevelDo
	Distinct(cols ...field.Expr) IPayLevelDo
	Omit(cols ...field.Expr) IPayLevelDo
	Join(table schema.Tabler, on ...field.Expr) IPayLevelDo
	LeftJoin(table schema.Tabler, on ...field.Expr) IPayLevelDo
	RightJoin(table schema.Tabler, on ...field.Expr) IPayLevelDo
	Group(cols ...field.Expr) IPayLevelDo
	Having(conds ...gen.Condition) IPayLevelDo
	Limit(limit int) IPayLevelDo
	Offset(offset int) IPayLevelDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) IPayLevelDo
	Unscoped() IPayLevelDo
	Create(values ...*model.PayLevel) error
	CreateInBatches(values []*model.PayLevel, batchSize int) error
	Save(values ...*model.PayLevel) error
	First() (*model.PayLevel, error)
	Take() (*model.PayLevel, error)
	Last() (*model.PayLevel, error)
	Find() ([]*model.PayLevel, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.PayLevel, err error)
	FindInBatches(result *[]*model.PayLevel, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.PayLevel) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) IPayLevelDo
	Assign(attrs ...field.AssignExpr) IPayLevelDo
	Joins(fields ...field.RelationField) IPayLevelDo
	Preload(fields ...field.RelationField) IPayLevelDo
	FirstOrInit() (*model.PayLevel, error)
	FirstOrCreate() (*model.PayLevel, error)
	FindByPage(offset int, limit int) (result []*model.PayLevel, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Rows() (*sql.Rows, error)
	Row() *sql.Row
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) IPayLevelDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (p payLevelDo) Debug() IPayLevelDo {
	return p.withDO(p.DO.Debug())
}

func (p payLevelDo) WithContext(ctx context.Context) IPayLevelDo {
	return p.withDO(p.DO.WithContext(ctx))
}

func (p payLevelDo) ReadDB() IPayLevelDo {
	return p.Clauses(dbresolver.Read)
}

func (p payLevelDo) WriteDB() IPayLevelDo {
	return p.Clauses(dbresolver.Write)
}

func (p payLevelDo) Session(config *gorm.Session) IPayLevelDo {
	return p.withDO(p.DO.Session(config))
}

func (p payLevelDo) Clauses(conds ...clause.Expression) IPayLevelDo {
	return p.withDO(p.DO.Clauses(conds...))
}

func (p payLevelDo) Returning(value interface{}, columns ...string) IPayLevelDo {
	return p.withDO(p.DO.Returning(value, columns...))
}

func (p payLevelDo) Not(conds ...gen.Condition) IPayLevelDo {
	return p.withDO(p.DO.Not(conds...))
}

func (p payLevelDo) Or(conds ...gen.Condition) IPayLevelDo {
	return p.withDO(p.DO.Or(conds...))
}

func (p payLevelDo) Select(conds ...field.Expr) IPayLevelDo {
	return p.withDO(p.DO.Select(conds...))
}

func (p payLevelDo) Where(conds ...gen.Condition) IPayLevelDo {
	return p.withDO(p.DO.Where(conds...))
}

func (p payLevelDo) Order(conds ...field.Expr) IPayLevelDo {
	return p.withDO(p.DO.Order(conds...))
}

func (p payLevelDo) Distinct(cols ...field.Expr) IPayLevelDo {
	return p.withDO(p.DO.Distinct(cols...))
}

func (p payLevelDo) Omit(cols ...field.Expr) IPayLevelDo {
	return p.withDO(p.DO.Omit(cols...))
}

func (p payLevelDo) Join(table schema.Tabler, on ...field.Expr) IPayLevelDo {
	return p.withDO(p.DO.Join(table, on...))
}

func (p payLevelDo) LeftJoin(table schema.Tabler, on ...field.Expr) IPayLevelDo {
	return p.withDO(p.DO.LeftJoin(table, on...))
}

func (p payLevelDo) RightJoin(table schema.Tabler, on ...field.Expr) IPayLevelDo {
	return p.withDO(p.DO.RightJoin(table, on...))
}

func (p payLevelDo) Group(cols ...field.Expr) IPayLevelDo {
	return p.withDO(p.DO.Group(cols...))
}

func (p payLevelDo) Having(conds ...gen.Condition) IPayLevelDo {
	return p.withDO(p.DO.Having(conds...))
}

func (p payLevelDo) Limit(limit int) IPayLevelDo {
	return p.withDO(p.DO.Limit(limit))
}

func (p payLevelDo) Offset(offset int) IPayLevelDo {
	return p.withDO(p.DO.Offset(offset))
}

func (p payLevelDo) Scopes(funcs ...func(gen.Dao) gen.Dao) IPayLevelDo {
	return p.withDO(p.DO.Scopes(funcs...))
}

func (p payLevelDo) Unscoped() IPayLevelDo {
	return p.withDO(p.DO.Unscoped())
}

func (p payLevelDo) Create(values ...*model.PayLevel) error {
	if len(values) == 0 {
		return nil
	}
	return p.DO.Create(values)
}

func (p payLevelDo) CreateInBatches(values []*model.PayLevel, batchSize int) error {
	return p.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (p payLevelDo) Save(values ...*model.PayLevel) error {
	if len(values) == 0 {
		return nil
	}
	return p.DO.Save(values)
}

func (p payLevelDo) First() (*model.PayLevel, error) {
	if result, err := p.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.PayLevel), nil
	}
}

func (p payLevelDo) Take() (*model.PayLevel, error) {
	if result, err := p.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.PayLevel), nil
	}
}

func (p payLevelDo) Last() (*model.PayLevel, error) {
	if result, err := p.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.PayLevel), nil
	}
}

func (p payLevelDo) Find() ([]*model.PayLevel, error) {
	result, err := p.DO.Find()
	return result.([]*model.PayLevel), err
}

func (p payLevelDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.PayLevel, err error) {
	buf := make([]*model.PayLevel, 0, batchSize)
	err = p.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (p payLevelDo) FindInBatches(result *[]*model.PayLevel, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return p.DO.FindInBatches(result, batchSize, fc)
}

func (p payLevelDo) Attrs(attrs ...field.AssignExpr) IPayLevelDo {
	return p.withDO(p.DO.Attrs(attrs...))
}

func (p payLevelDo) Assign(attrs ...field.AssignExpr) IPayLevelDo {
	return p.withDO(p.DO.Assign(attrs...))
}

func (p payLevelDo) Joins(fields ...field.RelationField) IPayLevelDo {
	for _, _f := range fields {
		p = *p.withDO(p.DO.Joins(_f))
	}
	return &p
}

func (p payLevelDo) Preload(fields ...field.RelationField) IPayLevelDo {
	for _, _f := range fields {
		p = *p.withDO(p.DO.Preload(_f))
	}
	return &p
}

func (p payLevelDo) FirstOrInit() (*model.PayLevel, error) {
	if result, err := p.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.PayLevel), nil
	}
}

func (p payLevelDo) FirstOrCreate() (*model.PayLevel, error) {
	if result, err := p.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.PayLevel), nil
	}
}

func (p payLevelDo) FindByPage(offset int, limit int) (result []*model.PayLevel, count int64, err error) {
	result, err = p.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = p.Offset(-1).Limit(-1).Count()
	return
}

func (p payLevelDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = p.Count()
	if err != nil {
		return
	}

	err = p.Offset(offset).Limit(limit).Scan(result)
	return
}

func (p payLevelDo) Scan(result interface{}) (err error) {
	return p.DO.Scan(result)
}

func (p payLevelDo) Delete(models ...*model.PayLevel) (result gen.ResultInfo, err error) {
	return p.DO.Delete(models)
}

func (p *payLevelDo) withDO(do gen.Dao) *payLevelDo {
	p.DO = *do.(*gen.DO)
	return p
}
