// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package query

import (
	"context"
	"database/sql"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"github.com/davy66666/rpc_common/dao/model"
)

func newUserRealNameConfig(db *gorm.DB, opts ...gen.DOOption) userRealNameConfig {
	_userRealNameConfig := userRealNameConfig{}

	_userRealNameConfig.userRealNameConfigDo.UseDB(db, opts...)
	_userRealNameConfig.userRealNameConfigDo.UseModel(&model.UserRealNameConfig{})

	tableName := _userRealNameConfig.userRealNameConfigDo.TableName()
	_userRealNameConfig.ALL = field.NewAsterisk(tableName)
	_userRealNameConfig.ID = field.NewInt64(tableName, "id")
	_userRealNameConfig.RealNameType = field.NewInt64(tableName, "real_name_type")
	_userRealNameConfig.TypeValue = field.NewString(tableName, "type_value")
	_userRealNameConfig.Condition = field.NewInt64(tableName, "condition")
	_userRealNameConfig.IsOpen = field.NewInt64(tableName, "is_open")
	_userRealNameConfig.PayLevel = field.NewString(tableName, "pay_level")
	_userRealNameConfig.UserLevel = field.NewString(tableName, "user_level")
	_userRealNameConfig.AdminName = field.NewString(tableName, "admin_name")
	_userRealNameConfig.CreatedAt = field.NewField(tableName, "created_at")
	_userRealNameConfig.UpdatedAt = field.NewField(tableName, "updated_at")
	_userRealNameConfig.PopupText = field.NewString(tableName, "popup_text")

	_userRealNameConfig.fillFieldMap()

	return _userRealNameConfig
}

// userRealNameConfig 用户实名配置表
type userRealNameConfig struct {
	userRealNameConfigDo userRealNameConfigDo

	ALL          field.Asterisk
	ID           field.Int64
	RealNameType field.Int64  // 要求实名类型 1:取款,2:充值,3:取款账户管理
	TypeValue    field.String // 要求实名类型配置值，存放数值，逗号分隔
	Condition    field.Int64  // 满足条件要求实名 1:同时满足所有条件,2:满足其中一项条件
	IsOpen       field.Int64  // 是否启用 1:是,0否
	PayLevel     field.String // 支付层级，多个用逗号分隔，0代表全部
	UserLevel    field.String // 用户层级，多个用逗号分隔，0代表全部
	AdminName    field.String // 最后操作管理员
	CreatedAt    field.Field
	UpdatedAt    field.Field
	PopupText    field.String // 弹窗文案

	fieldMap map[string]field.Expr
}

func (u userRealNameConfig) Table(newTableName string) *userRealNameConfig {
	u.userRealNameConfigDo.UseTable(newTableName)
	return u.updateTableName(newTableName)
}

func (u userRealNameConfig) As(alias string) *userRealNameConfig {
	u.userRealNameConfigDo.DO = *(u.userRealNameConfigDo.As(alias).(*gen.DO))
	return u.updateTableName(alias)
}

func (u *userRealNameConfig) updateTableName(table string) *userRealNameConfig {
	u.ALL = field.NewAsterisk(table)
	u.ID = field.NewInt64(table, "id")
	u.RealNameType = field.NewInt64(table, "real_name_type")
	u.TypeValue = field.NewString(table, "type_value")
	u.Condition = field.NewInt64(table, "condition")
	u.IsOpen = field.NewInt64(table, "is_open")
	u.PayLevel = field.NewString(table, "pay_level")
	u.UserLevel = field.NewString(table, "user_level")
	u.AdminName = field.NewString(table, "admin_name")
	u.CreatedAt = field.NewField(table, "created_at")
	u.UpdatedAt = field.NewField(table, "updated_at")
	u.PopupText = field.NewString(table, "popup_text")

	u.fillFieldMap()

	return u
}

func (u *userRealNameConfig) WithContext(ctx context.Context) IUserRealNameConfigDo {
	return u.userRealNameConfigDo.WithContext(ctx)
}

func (u userRealNameConfig) TableName() string { return u.userRealNameConfigDo.TableName() }

func (u userRealNameConfig) Alias() string { return u.userRealNameConfigDo.Alias() }

func (u userRealNameConfig) Columns(cols ...field.Expr) gen.Columns {
	return u.userRealNameConfigDo.Columns(cols...)
}

func (u *userRealNameConfig) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := u.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (u *userRealNameConfig) fillFieldMap() {
	u.fieldMap = make(map[string]field.Expr, 11)
	u.fieldMap["id"] = u.ID
	u.fieldMap["real_name_type"] = u.RealNameType
	u.fieldMap["type_value"] = u.TypeValue
	u.fieldMap["condition"] = u.Condition
	u.fieldMap["is_open"] = u.IsOpen
	u.fieldMap["pay_level"] = u.PayLevel
	u.fieldMap["user_level"] = u.UserLevel
	u.fieldMap["admin_name"] = u.AdminName
	u.fieldMap["created_at"] = u.CreatedAt
	u.fieldMap["updated_at"] = u.UpdatedAt
	u.fieldMap["popup_text"] = u.PopupText
}

func (u userRealNameConfig) clone(db *gorm.DB) userRealNameConfig {
	u.userRealNameConfigDo.ReplaceConnPool(db.Statement.ConnPool)
	return u
}

func (u userRealNameConfig) replaceDB(db *gorm.DB) userRealNameConfig {
	u.userRealNameConfigDo.ReplaceDB(db)
	return u
}

type userRealNameConfigDo struct{ gen.DO }

type IUserRealNameConfigDo interface {
	gen.SubQuery
	Debug() IUserRealNameConfigDo
	WithContext(ctx context.Context) IUserRealNameConfigDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() IUserRealNameConfigDo
	WriteDB() IUserRealNameConfigDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) IUserRealNameConfigDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) IUserRealNameConfigDo
	Not(conds ...gen.Condition) IUserRealNameConfigDo
	Or(conds ...gen.Condition) IUserRealNameConfigDo
	Select(conds ...field.Expr) IUserRealNameConfigDo
	Where(conds ...gen.Condition) IUserRealNameConfigDo
	Order(conds ...field.Expr) IUserRealNameConfigDo
	Distinct(cols ...field.Expr) IUserRealNameConfigDo
	Omit(cols ...field.Expr) IUserRealNameConfigDo
	Join(table schema.Tabler, on ...field.Expr) IUserRealNameConfigDo
	LeftJoin(table schema.Tabler, on ...field.Expr) IUserRealNameConfigDo
	RightJoin(table schema.Tabler, on ...field.Expr) IUserRealNameConfigDo
	Group(cols ...field.Expr) IUserRealNameConfigDo
	Having(conds ...gen.Condition) IUserRealNameConfigDo
	Limit(limit int) IUserRealNameConfigDo
	Offset(offset int) IUserRealNameConfigDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) IUserRealNameConfigDo
	Unscoped() IUserRealNameConfigDo
	Create(values ...*model.UserRealNameConfig) error
	CreateInBatches(values []*model.UserRealNameConfig, batchSize int) error
	Save(values ...*model.UserRealNameConfig) error
	First() (*model.UserRealNameConfig, error)
	Take() (*model.UserRealNameConfig, error)
	Last() (*model.UserRealNameConfig, error)
	Find() ([]*model.UserRealNameConfig, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.UserRealNameConfig, err error)
	FindInBatches(result *[]*model.UserRealNameConfig, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.UserRealNameConfig) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) IUserRealNameConfigDo
	Assign(attrs ...field.AssignExpr) IUserRealNameConfigDo
	Joins(fields ...field.RelationField) IUserRealNameConfigDo
	Preload(fields ...field.RelationField) IUserRealNameConfigDo
	FirstOrInit() (*model.UserRealNameConfig, error)
	FirstOrCreate() (*model.UserRealNameConfig, error)
	FindByPage(offset int, limit int) (result []*model.UserRealNameConfig, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Rows() (*sql.Rows, error)
	Row() *sql.Row
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) IUserRealNameConfigDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (u userRealNameConfigDo) Debug() IUserRealNameConfigDo {
	return u.withDO(u.DO.Debug())
}

func (u userRealNameConfigDo) WithContext(ctx context.Context) IUserRealNameConfigDo {
	return u.withDO(u.DO.WithContext(ctx))
}

func (u userRealNameConfigDo) ReadDB() IUserRealNameConfigDo {
	return u.Clauses(dbresolver.Read)
}

func (u userRealNameConfigDo) WriteDB() IUserRealNameConfigDo {
	return u.Clauses(dbresolver.Write)
}

func (u userRealNameConfigDo) Session(config *gorm.Session) IUserRealNameConfigDo {
	return u.withDO(u.DO.Session(config))
}

func (u userRealNameConfigDo) Clauses(conds ...clause.Expression) IUserRealNameConfigDo {
	return u.withDO(u.DO.Clauses(conds...))
}

func (u userRealNameConfigDo) Returning(value interface{}, columns ...string) IUserRealNameConfigDo {
	return u.withDO(u.DO.Returning(value, columns...))
}

func (u userRealNameConfigDo) Not(conds ...gen.Condition) IUserRealNameConfigDo {
	return u.withDO(u.DO.Not(conds...))
}

func (u userRealNameConfigDo) Or(conds ...gen.Condition) IUserRealNameConfigDo {
	return u.withDO(u.DO.Or(conds...))
}

func (u userRealNameConfigDo) Select(conds ...field.Expr) IUserRealNameConfigDo {
	return u.withDO(u.DO.Select(conds...))
}

func (u userRealNameConfigDo) Where(conds ...gen.Condition) IUserRealNameConfigDo {
	return u.withDO(u.DO.Where(conds...))
}

func (u userRealNameConfigDo) Order(conds ...field.Expr) IUserRealNameConfigDo {
	return u.withDO(u.DO.Order(conds...))
}

func (u userRealNameConfigDo) Distinct(cols ...field.Expr) IUserRealNameConfigDo {
	return u.withDO(u.DO.Distinct(cols...))
}

func (u userRealNameConfigDo) Omit(cols ...field.Expr) IUserRealNameConfigDo {
	return u.withDO(u.DO.Omit(cols...))
}

func (u userRealNameConfigDo) Join(table schema.Tabler, on ...field.Expr) IUserRealNameConfigDo {
	return u.withDO(u.DO.Join(table, on...))
}

func (u userRealNameConfigDo) LeftJoin(table schema.Tabler, on ...field.Expr) IUserRealNameConfigDo {
	return u.withDO(u.DO.LeftJoin(table, on...))
}

func (u userRealNameConfigDo) RightJoin(table schema.Tabler, on ...field.Expr) IUserRealNameConfigDo {
	return u.withDO(u.DO.RightJoin(table, on...))
}

func (u userRealNameConfigDo) Group(cols ...field.Expr) IUserRealNameConfigDo {
	return u.withDO(u.DO.Group(cols...))
}

func (u userRealNameConfigDo) Having(conds ...gen.Condition) IUserRealNameConfigDo {
	return u.withDO(u.DO.Having(conds...))
}

func (u userRealNameConfigDo) Limit(limit int) IUserRealNameConfigDo {
	return u.withDO(u.DO.Limit(limit))
}

func (u userRealNameConfigDo) Offset(offset int) IUserRealNameConfigDo {
	return u.withDO(u.DO.Offset(offset))
}

func (u userRealNameConfigDo) Scopes(funcs ...func(gen.Dao) gen.Dao) IUserRealNameConfigDo {
	return u.withDO(u.DO.Scopes(funcs...))
}

func (u userRealNameConfigDo) Unscoped() IUserRealNameConfigDo {
	return u.withDO(u.DO.Unscoped())
}

func (u userRealNameConfigDo) Create(values ...*model.UserRealNameConfig) error {
	if len(values) == 0 {
		return nil
	}
	return u.DO.Create(values)
}

func (u userRealNameConfigDo) CreateInBatches(values []*model.UserRealNameConfig, batchSize int) error {
	return u.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (u userRealNameConfigDo) Save(values ...*model.UserRealNameConfig) error {
	if len(values) == 0 {
		return nil
	}
	return u.DO.Save(values)
}

func (u userRealNameConfigDo) First() (*model.UserRealNameConfig, error) {
	if result, err := u.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.UserRealNameConfig), nil
	}
}

func (u userRealNameConfigDo) Take() (*model.UserRealNameConfig, error) {
	if result, err := u.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.UserRealNameConfig), nil
	}
}

func (u userRealNameConfigDo) Last() (*model.UserRealNameConfig, error) {
	if result, err := u.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.UserRealNameConfig), nil
	}
}

func (u userRealNameConfigDo) Find() ([]*model.UserRealNameConfig, error) {
	result, err := u.DO.Find()
	return result.([]*model.UserRealNameConfig), err
}

func (u userRealNameConfigDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.UserRealNameConfig, err error) {
	buf := make([]*model.UserRealNameConfig, 0, batchSize)
	err = u.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (u userRealNameConfigDo) FindInBatches(result *[]*model.UserRealNameConfig, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return u.DO.FindInBatches(result, batchSize, fc)
}

func (u userRealNameConfigDo) Attrs(attrs ...field.AssignExpr) IUserRealNameConfigDo {
	return u.withDO(u.DO.Attrs(attrs...))
}

func (u userRealNameConfigDo) Assign(attrs ...field.AssignExpr) IUserRealNameConfigDo {
	return u.withDO(u.DO.Assign(attrs...))
}

func (u userRealNameConfigDo) Joins(fields ...field.RelationField) IUserRealNameConfigDo {
	for _, _f := range fields {
		u = *u.withDO(u.DO.Joins(_f))
	}
	return &u
}

func (u userRealNameConfigDo) Preload(fields ...field.RelationField) IUserRealNameConfigDo {
	for _, _f := range fields {
		u = *u.withDO(u.DO.Preload(_f))
	}
	return &u
}

func (u userRealNameConfigDo) FirstOrInit() (*model.UserRealNameConfig, error) {
	if result, err := u.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.UserRealNameConfig), nil
	}
}

func (u userRealNameConfigDo) FirstOrCreate() (*model.UserRealNameConfig, error) {
	if result, err := u.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.UserRealNameConfig), nil
	}
}

func (u userRealNameConfigDo) FindByPage(offset int, limit int) (result []*model.UserRealNameConfig, count int64, err error) {
	result, err = u.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = u.Offset(-1).Limit(-1).Count()
	return
}

func (u userRealNameConfigDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = u.Count()
	if err != nil {
		return
	}

	err = u.Offset(offset).Limit(limit).Scan(result)
	return
}

func (u userRealNameConfigDo) Scan(result interface{}) (err error) {
	return u.DO.Scan(result)
}

func (u userRealNameConfigDo) Delete(models ...*model.UserRealNameConfig) (result gen.ResultInfo, err error) {
	return u.DO.Delete(models)
}

func (u *userRealNameConfigDo) withDO(do gen.Dao) *userRealNameConfigDo {
	u.DO = *do.(*gen.DO)
	return u
}
