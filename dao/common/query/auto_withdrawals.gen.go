// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package query

import (
	"context"
	"database/sql"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"github.com/davy66666/rpc_common/dao/model"
)

func newAutoWithdrawal(db *gorm.DB, opts ...gen.DOOption) autoWithdrawal {
	_autoWithdrawal := autoWithdrawal{}

	_autoWithdrawal.autoWithdrawalDo.UseDB(db, opts...)
	_autoWithdrawal.autoWithdrawalDo.UseModel(&model.AutoWithdrawal{})

	tableName := _autoWithdrawal.autoWithdrawalDo.TableName()
	_autoWithdrawal.ALL = field.NewAsterisk(tableName)
	_autoWithdrawal.ID = field.NewInt64(tableName, "id")
	_autoWithdrawal.PayCode = field.NewString(tableName, "pay_code")
	_autoWithdrawal.PayName = field.NewString(tableName, "pay_name")
	_autoWithdrawal.Account = field.NewString(tableName, "account")
	_autoWithdrawal.MerchantKey = field.NewString(tableName, "merchant_key")
	_autoWithdrawal.ChannelCode = field.NewString(tableName, "channel_code")
	_autoWithdrawal.Gateway = field.NewString(tableName, "gateway")
	_autoWithdrawal.PayURL = field.NewString(tableName, "pay_url")
	_autoWithdrawal.MinMoney = field.NewFloat64(tableName, "min_money")
	_autoWithdrawal.MaxMoney = field.NewFloat64(tableName, "max_money")
	_autoWithdrawal.PayLevel = field.NewString(tableName, "pay_level")
	_autoWithdrawal.IP = field.NewString(tableName, "ip")
	_autoWithdrawal.Sort = field.NewInt64(tableName, "sort")
	_autoWithdrawal.Platform = field.NewString(tableName, "platform")
	_autoWithdrawal.ExRate = field.NewFloat64(tableName, "ex_rate")
	_autoWithdrawal.HandlingFee = field.NewFloat64(tableName, "handling_fee")
	_autoWithdrawal.Remark = field.NewString(tableName, "remark")
	_autoWithdrawal.Extra = field.NewString(tableName, "extra")
	_autoWithdrawal.AdminUser = field.NewString(tableName, "admin_user")
	_autoWithdrawal.IsThird = field.NewInt64(tableName, "is_third")
	_autoWithdrawal.IsOpen = field.NewInt64(tableName, "is_open")
	_autoWithdrawal.DailyMaxTimes = field.NewInt64(tableName, "daily_max_times")
	_autoWithdrawal.GiftMoneyRate = field.NewFloat64(tableName, "gift_money_rate")
	_autoWithdrawal.CreatedAt = field.NewField(tableName, "created_at")
	_autoWithdrawal.UpdatedAt = field.NewField(tableName, "updated_at")
	_autoWithdrawal.Type = field.NewInt64(tableName, "type")
	_autoWithdrawal.PayOutType = field.NewInt64(tableName, "pay_out_type")

	_autoWithdrawal.fillFieldMap()

	return _autoWithdrawal
}

type autoWithdrawal struct {
	autoWithdrawalDo autoWithdrawalDo

	ALL           field.Asterisk
	ID            field.Int64
	PayCode       field.String  // 第三方英文名
	PayName       field.String  // 第三方中文名
	Account       field.String  // 商户号
	MerchantKey   field.String  // 商户密匙
	ChannelCode   field.String  // 通道编码
	Gateway       field.String  // 第三方网关地址
	PayURL        field.String  // 支付地址
	MinMoney      field.Float64 // 取款最低限额
	MaxMoney      field.Float64 // 取款最高限额
	PayLevel      field.String  // 支付层级 多个以逗号隔开
	IP            field.String  // 第三方ip
	Sort          field.Int64   // 排序
	Platform      field.String  // 取款开放的支付平台,1:手机端;4:pc端
	ExRate        field.Float64 // 汇率
	HandlingFee   field.Float64 // 手续费(%)
	Remark        field.String  // 前台的取款提示
	Extra         field.String  // 备用字段
	AdminUser     field.String  // 编辑者
	IsThird       field.Int64   // 是否是线上取款 0:否，1：是
	IsOpen        field.Int64   // 是否开启0:否;1:是
	DailyMaxTimes field.Int64   // 取款最大次数
	GiftMoneyRate field.Float64 // 出款优惠比例(%)
	CreatedAt     field.Field
	UpdatedAt     field.Field
	Type          field.Int64 // 自动出款分类
	PayOutType    field.Int64 // 出款方式，0未选择 1人民币 2虚拟币

	fieldMap map[string]field.Expr
}

func (a autoWithdrawal) Table(newTableName string) *autoWithdrawal {
	a.autoWithdrawalDo.UseTable(newTableName)
	return a.updateTableName(newTableName)
}

func (a autoWithdrawal) As(alias string) *autoWithdrawal {
	a.autoWithdrawalDo.DO = *(a.autoWithdrawalDo.As(alias).(*gen.DO))
	return a.updateTableName(alias)
}

func (a *autoWithdrawal) updateTableName(table string) *autoWithdrawal {
	a.ALL = field.NewAsterisk(table)
	a.ID = field.NewInt64(table, "id")
	a.PayCode = field.NewString(table, "pay_code")
	a.PayName = field.NewString(table, "pay_name")
	a.Account = field.NewString(table, "account")
	a.MerchantKey = field.NewString(table, "merchant_key")
	a.ChannelCode = field.NewString(table, "channel_code")
	a.Gateway = field.NewString(table, "gateway")
	a.PayURL = field.NewString(table, "pay_url")
	a.MinMoney = field.NewFloat64(table, "min_money")
	a.MaxMoney = field.NewFloat64(table, "max_money")
	a.PayLevel = field.NewString(table, "pay_level")
	a.IP = field.NewString(table, "ip")
	a.Sort = field.NewInt64(table, "sort")
	a.Platform = field.NewString(table, "platform")
	a.ExRate = field.NewFloat64(table, "ex_rate")
	a.HandlingFee = field.NewFloat64(table, "handling_fee")
	a.Remark = field.NewString(table, "remark")
	a.Extra = field.NewString(table, "extra")
	a.AdminUser = field.NewString(table, "admin_user")
	a.IsThird = field.NewInt64(table, "is_third")
	a.IsOpen = field.NewInt64(table, "is_open")
	a.DailyMaxTimes = field.NewInt64(table, "daily_max_times")
	a.GiftMoneyRate = field.NewFloat64(table, "gift_money_rate")
	a.CreatedAt = field.NewField(table, "created_at")
	a.UpdatedAt = field.NewField(table, "updated_at")
	a.Type = field.NewInt64(table, "type")
	a.PayOutType = field.NewInt64(table, "pay_out_type")

	a.fillFieldMap()

	return a
}

func (a *autoWithdrawal) WithContext(ctx context.Context) IAutoWithdrawalDo {
	return a.autoWithdrawalDo.WithContext(ctx)
}

func (a autoWithdrawal) TableName() string { return a.autoWithdrawalDo.TableName() }

func (a autoWithdrawal) Alias() string { return a.autoWithdrawalDo.Alias() }

func (a autoWithdrawal) Columns(cols ...field.Expr) gen.Columns {
	return a.autoWithdrawalDo.Columns(cols...)
}

func (a *autoWithdrawal) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := a.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (a *autoWithdrawal) fillFieldMap() {
	a.fieldMap = make(map[string]field.Expr, 27)
	a.fieldMap["id"] = a.ID
	a.fieldMap["pay_code"] = a.PayCode
	a.fieldMap["pay_name"] = a.PayName
	a.fieldMap["account"] = a.Account
	a.fieldMap["merchant_key"] = a.MerchantKey
	a.fieldMap["channel_code"] = a.ChannelCode
	a.fieldMap["gateway"] = a.Gateway
	a.fieldMap["pay_url"] = a.PayURL
	a.fieldMap["min_money"] = a.MinMoney
	a.fieldMap["max_money"] = a.MaxMoney
	a.fieldMap["pay_level"] = a.PayLevel
	a.fieldMap["ip"] = a.IP
	a.fieldMap["sort"] = a.Sort
	a.fieldMap["platform"] = a.Platform
	a.fieldMap["ex_rate"] = a.ExRate
	a.fieldMap["handling_fee"] = a.HandlingFee
	a.fieldMap["remark"] = a.Remark
	a.fieldMap["extra"] = a.Extra
	a.fieldMap["admin_user"] = a.AdminUser
	a.fieldMap["is_third"] = a.IsThird
	a.fieldMap["is_open"] = a.IsOpen
	a.fieldMap["daily_max_times"] = a.DailyMaxTimes
	a.fieldMap["gift_money_rate"] = a.GiftMoneyRate
	a.fieldMap["created_at"] = a.CreatedAt
	a.fieldMap["updated_at"] = a.UpdatedAt
	a.fieldMap["type"] = a.Type
	a.fieldMap["pay_out_type"] = a.PayOutType
}

func (a autoWithdrawal) clone(db *gorm.DB) autoWithdrawal {
	a.autoWithdrawalDo.ReplaceConnPool(db.Statement.ConnPool)
	return a
}

func (a autoWithdrawal) replaceDB(db *gorm.DB) autoWithdrawal {
	a.autoWithdrawalDo.ReplaceDB(db)
	return a
}

type autoWithdrawalDo struct{ gen.DO }

type IAutoWithdrawalDo interface {
	gen.SubQuery
	Debug() IAutoWithdrawalDo
	WithContext(ctx context.Context) IAutoWithdrawalDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() IAutoWithdrawalDo
	WriteDB() IAutoWithdrawalDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) IAutoWithdrawalDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) IAutoWithdrawalDo
	Not(conds ...gen.Condition) IAutoWithdrawalDo
	Or(conds ...gen.Condition) IAutoWithdrawalDo
	Select(conds ...field.Expr) IAutoWithdrawalDo
	Where(conds ...gen.Condition) IAutoWithdrawalDo
	Order(conds ...field.Expr) IAutoWithdrawalDo
	Distinct(cols ...field.Expr) IAutoWithdrawalDo
	Omit(cols ...field.Expr) IAutoWithdrawalDo
	Join(table schema.Tabler, on ...field.Expr) IAutoWithdrawalDo
	LeftJoin(table schema.Tabler, on ...field.Expr) IAutoWithdrawalDo
	RightJoin(table schema.Tabler, on ...field.Expr) IAutoWithdrawalDo
	Group(cols ...field.Expr) IAutoWithdrawalDo
	Having(conds ...gen.Condition) IAutoWithdrawalDo
	Limit(limit int) IAutoWithdrawalDo
	Offset(offset int) IAutoWithdrawalDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) IAutoWithdrawalDo
	Unscoped() IAutoWithdrawalDo
	Create(values ...*model.AutoWithdrawal) error
	CreateInBatches(values []*model.AutoWithdrawal, batchSize int) error
	Save(values ...*model.AutoWithdrawal) error
	First() (*model.AutoWithdrawal, error)
	Take() (*model.AutoWithdrawal, error)
	Last() (*model.AutoWithdrawal, error)
	Find() ([]*model.AutoWithdrawal, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.AutoWithdrawal, err error)
	FindInBatches(result *[]*model.AutoWithdrawal, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.AutoWithdrawal) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) IAutoWithdrawalDo
	Assign(attrs ...field.AssignExpr) IAutoWithdrawalDo
	Joins(fields ...field.RelationField) IAutoWithdrawalDo
	Preload(fields ...field.RelationField) IAutoWithdrawalDo
	FirstOrInit() (*model.AutoWithdrawal, error)
	FirstOrCreate() (*model.AutoWithdrawal, error)
	FindByPage(offset int, limit int) (result []*model.AutoWithdrawal, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Rows() (*sql.Rows, error)
	Row() *sql.Row
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) IAutoWithdrawalDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (a autoWithdrawalDo) Debug() IAutoWithdrawalDo {
	return a.withDO(a.DO.Debug())
}

func (a autoWithdrawalDo) WithContext(ctx context.Context) IAutoWithdrawalDo {
	return a.withDO(a.DO.WithContext(ctx))
}

func (a autoWithdrawalDo) ReadDB() IAutoWithdrawalDo {
	return a.Clauses(dbresolver.Read)
}

func (a autoWithdrawalDo) WriteDB() IAutoWithdrawalDo {
	return a.Clauses(dbresolver.Write)
}

func (a autoWithdrawalDo) Session(config *gorm.Session) IAutoWithdrawalDo {
	return a.withDO(a.DO.Session(config))
}

func (a autoWithdrawalDo) Clauses(conds ...clause.Expression) IAutoWithdrawalDo {
	return a.withDO(a.DO.Clauses(conds...))
}

func (a autoWithdrawalDo) Returning(value interface{}, columns ...string) IAutoWithdrawalDo {
	return a.withDO(a.DO.Returning(value, columns...))
}

func (a autoWithdrawalDo) Not(conds ...gen.Condition) IAutoWithdrawalDo {
	return a.withDO(a.DO.Not(conds...))
}

func (a autoWithdrawalDo) Or(conds ...gen.Condition) IAutoWithdrawalDo {
	return a.withDO(a.DO.Or(conds...))
}

func (a autoWithdrawalDo) Select(conds ...field.Expr) IAutoWithdrawalDo {
	return a.withDO(a.DO.Select(conds...))
}

func (a autoWithdrawalDo) Where(conds ...gen.Condition) IAutoWithdrawalDo {
	return a.withDO(a.DO.Where(conds...))
}

func (a autoWithdrawalDo) Order(conds ...field.Expr) IAutoWithdrawalDo {
	return a.withDO(a.DO.Order(conds...))
}

func (a autoWithdrawalDo) Distinct(cols ...field.Expr) IAutoWithdrawalDo {
	return a.withDO(a.DO.Distinct(cols...))
}

func (a autoWithdrawalDo) Omit(cols ...field.Expr) IAutoWithdrawalDo {
	return a.withDO(a.DO.Omit(cols...))
}

func (a autoWithdrawalDo) Join(table schema.Tabler, on ...field.Expr) IAutoWithdrawalDo {
	return a.withDO(a.DO.Join(table, on...))
}

func (a autoWithdrawalDo) LeftJoin(table schema.Tabler, on ...field.Expr) IAutoWithdrawalDo {
	return a.withDO(a.DO.LeftJoin(table, on...))
}

func (a autoWithdrawalDo) RightJoin(table schema.Tabler, on ...field.Expr) IAutoWithdrawalDo {
	return a.withDO(a.DO.RightJoin(table, on...))
}

func (a autoWithdrawalDo) Group(cols ...field.Expr) IAutoWithdrawalDo {
	return a.withDO(a.DO.Group(cols...))
}

func (a autoWithdrawalDo) Having(conds ...gen.Condition) IAutoWithdrawalDo {
	return a.withDO(a.DO.Having(conds...))
}

func (a autoWithdrawalDo) Limit(limit int) IAutoWithdrawalDo {
	return a.withDO(a.DO.Limit(limit))
}

func (a autoWithdrawalDo) Offset(offset int) IAutoWithdrawalDo {
	return a.withDO(a.DO.Offset(offset))
}

func (a autoWithdrawalDo) Scopes(funcs ...func(gen.Dao) gen.Dao) IAutoWithdrawalDo {
	return a.withDO(a.DO.Scopes(funcs...))
}

func (a autoWithdrawalDo) Unscoped() IAutoWithdrawalDo {
	return a.withDO(a.DO.Unscoped())
}

func (a autoWithdrawalDo) Create(values ...*model.AutoWithdrawal) error {
	if len(values) == 0 {
		return nil
	}
	return a.DO.Create(values)
}

func (a autoWithdrawalDo) CreateInBatches(values []*model.AutoWithdrawal, batchSize int) error {
	return a.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (a autoWithdrawalDo) Save(values ...*model.AutoWithdrawal) error {
	if len(values) == 0 {
		return nil
	}
	return a.DO.Save(values)
}

func (a autoWithdrawalDo) First() (*model.AutoWithdrawal, error) {
	if result, err := a.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.AutoWithdrawal), nil
	}
}

func (a autoWithdrawalDo) Take() (*model.AutoWithdrawal, error) {
	if result, err := a.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.AutoWithdrawal), nil
	}
}

func (a autoWithdrawalDo) Last() (*model.AutoWithdrawal, error) {
	if result, err := a.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.AutoWithdrawal), nil
	}
}

func (a autoWithdrawalDo) Find() ([]*model.AutoWithdrawal, error) {
	result, err := a.DO.Find()
	return result.([]*model.AutoWithdrawal), err
}

func (a autoWithdrawalDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.AutoWithdrawal, err error) {
	buf := make([]*model.AutoWithdrawal, 0, batchSize)
	err = a.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (a autoWithdrawalDo) FindInBatches(result *[]*model.AutoWithdrawal, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return a.DO.FindInBatches(result, batchSize, fc)
}

func (a autoWithdrawalDo) Attrs(attrs ...field.AssignExpr) IAutoWithdrawalDo {
	return a.withDO(a.DO.Attrs(attrs...))
}

func (a autoWithdrawalDo) Assign(attrs ...field.AssignExpr) IAutoWithdrawalDo {
	return a.withDO(a.DO.Assign(attrs...))
}

func (a autoWithdrawalDo) Joins(fields ...field.RelationField) IAutoWithdrawalDo {
	for _, _f := range fields {
		a = *a.withDO(a.DO.Joins(_f))
	}
	return &a
}

func (a autoWithdrawalDo) Preload(fields ...field.RelationField) IAutoWithdrawalDo {
	for _, _f := range fields {
		a = *a.withDO(a.DO.Preload(_f))
	}
	return &a
}

func (a autoWithdrawalDo) FirstOrInit() (*model.AutoWithdrawal, error) {
	if result, err := a.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.AutoWithdrawal), nil
	}
}

func (a autoWithdrawalDo) FirstOrCreate() (*model.AutoWithdrawal, error) {
	if result, err := a.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.AutoWithdrawal), nil
	}
}

func (a autoWithdrawalDo) FindByPage(offset int, limit int) (result []*model.AutoWithdrawal, count int64, err error) {
	result, err = a.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = a.Offset(-1).Limit(-1).Count()
	return
}

func (a autoWithdrawalDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = a.Count()
	if err != nil {
		return
	}

	err = a.Offset(offset).Limit(limit).Scan(result)
	return
}

func (a autoWithdrawalDo) Scan(result interface{}) (err error) {
	return a.DO.Scan(result)
}

func (a autoWithdrawalDo) Delete(models ...*model.AutoWithdrawal) (result gen.ResultInfo, err error) {
	return a.DO.Delete(models)
}

func (a *autoWithdrawalDo) withDO(do gen.Dao) *autoWithdrawalDo {
	a.DO = *do.(*gen.DO)
	return a
}
