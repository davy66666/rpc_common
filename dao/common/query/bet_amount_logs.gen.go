// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package query

import (
	"context"
	"database/sql"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"github.com/davy66666/rpc_common/dao/model"
)

func newBetAmountLog(db *gorm.DB, opts ...gen.DOOption) betAmountLog {
	_betAmountLog := betAmountLog{}

	_betAmountLog.betAmountLogDo.UseDB(db, opts...)
	_betAmountLog.betAmountLogDo.UseModel(&model.BetAmountLog{})

	tableName := _betAmountLog.betAmountLogDo.TableName()
	_betAmountLog.ALL = field.NewAsterisk(tableName)
	_betAmountLog.ID = field.NewInt64(tableName, "id")
	_betAmountLog.UserID = field.NewInt64(tableName, "user_id")
	_betAmountLog.Username = field.NewString(tableName, "username")
	_betAmountLog.TotalAmount = field.NewFloat64(tableName, "total_amount")
	_betAmountLog.Remark = field.NewString(tableName, "remark")
	_betAmountLog.TransactionID = field.NewInt64(tableName, "transaction_id")
	_betAmountLog.State = field.NewInt64(tableName, "state")
	_betAmountLog.DeleteAt = field.NewField(tableName, "delete_at")
	_betAmountLog.CreatedAt = field.NewField(tableName, "created_at")
	_betAmountLog.UpdatedAt = field.NewField(tableName, "updated_at")

	_betAmountLog.fillFieldMap()

	return _betAmountLog
}

type betAmountLog struct {
	betAmountLogDo betAmountLogDo

	ALL           field.Asterisk
	ID            field.Int64
	UserID        field.Int64   // 用户id
	Username      field.String  // 用户名
	TotalAmount   field.Float64 // 要求打码量
	Remark        field.String  // 备注
	TransactionID field.Int64
	State         field.Int64 // 是否有效0:否;1:是
	DeleteAt      field.Field // 重置时间 就是失效时间
	CreatedAt     field.Field
	UpdatedAt     field.Field

	fieldMap map[string]field.Expr
}

func (b betAmountLog) Table(newTableName string) *betAmountLog {
	b.betAmountLogDo.UseTable(newTableName)
	return b.updateTableName(newTableName)
}

func (b betAmountLog) As(alias string) *betAmountLog {
	b.betAmountLogDo.DO = *(b.betAmountLogDo.As(alias).(*gen.DO))
	return b.updateTableName(alias)
}

func (b *betAmountLog) updateTableName(table string) *betAmountLog {
	b.ALL = field.NewAsterisk(table)
	b.ID = field.NewInt64(table, "id")
	b.UserID = field.NewInt64(table, "user_id")
	b.Username = field.NewString(table, "username")
	b.TotalAmount = field.NewFloat64(table, "total_amount")
	b.Remark = field.NewString(table, "remark")
	b.TransactionID = field.NewInt64(table, "transaction_id")
	b.State = field.NewInt64(table, "state")
	b.DeleteAt = field.NewField(table, "delete_at")
	b.CreatedAt = field.NewField(table, "created_at")
	b.UpdatedAt = field.NewField(table, "updated_at")

	b.fillFieldMap()

	return b
}

func (b *betAmountLog) WithContext(ctx context.Context) IBetAmountLogDo {
	return b.betAmountLogDo.WithContext(ctx)
}

func (b betAmountLog) TableName() string { return b.betAmountLogDo.TableName() }

func (b betAmountLog) Alias() string { return b.betAmountLogDo.Alias() }

func (b betAmountLog) Columns(cols ...field.Expr) gen.Columns {
	return b.betAmountLogDo.Columns(cols...)
}

func (b *betAmountLog) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := b.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (b *betAmountLog) fillFieldMap() {
	b.fieldMap = make(map[string]field.Expr, 10)
	b.fieldMap["id"] = b.ID
	b.fieldMap["user_id"] = b.UserID
	b.fieldMap["username"] = b.Username
	b.fieldMap["total_amount"] = b.TotalAmount
	b.fieldMap["remark"] = b.Remark
	b.fieldMap["transaction_id"] = b.TransactionID
	b.fieldMap["state"] = b.State
	b.fieldMap["delete_at"] = b.DeleteAt
	b.fieldMap["created_at"] = b.CreatedAt
	b.fieldMap["updated_at"] = b.UpdatedAt
}

func (b betAmountLog) clone(db *gorm.DB) betAmountLog {
	b.betAmountLogDo.ReplaceConnPool(db.Statement.ConnPool)
	return b
}

func (b betAmountLog) replaceDB(db *gorm.DB) betAmountLog {
	b.betAmountLogDo.ReplaceDB(db)
	return b
}

type betAmountLogDo struct{ gen.DO }

type IBetAmountLogDo interface {
	gen.SubQuery
	Debug() IBetAmountLogDo
	WithContext(ctx context.Context) IBetAmountLogDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() IBetAmountLogDo
	WriteDB() IBetAmountLogDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) IBetAmountLogDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) IBetAmountLogDo
	Not(conds ...gen.Condition) IBetAmountLogDo
	Or(conds ...gen.Condition) IBetAmountLogDo
	Select(conds ...field.Expr) IBetAmountLogDo
	Where(conds ...gen.Condition) IBetAmountLogDo
	Order(conds ...field.Expr) IBetAmountLogDo
	Distinct(cols ...field.Expr) IBetAmountLogDo
	Omit(cols ...field.Expr) IBetAmountLogDo
	Join(table schema.Tabler, on ...field.Expr) IBetAmountLogDo
	LeftJoin(table schema.Tabler, on ...field.Expr) IBetAmountLogDo
	RightJoin(table schema.Tabler, on ...field.Expr) IBetAmountLogDo
	Group(cols ...field.Expr) IBetAmountLogDo
	Having(conds ...gen.Condition) IBetAmountLogDo
	Limit(limit int) IBetAmountLogDo
	Offset(offset int) IBetAmountLogDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) IBetAmountLogDo
	Unscoped() IBetAmountLogDo
	Create(values ...*model.BetAmountLog) error
	CreateInBatches(values []*model.BetAmountLog, batchSize int) error
	Save(values ...*model.BetAmountLog) error
	First() (*model.BetAmountLog, error)
	Take() (*model.BetAmountLog, error)
	Last() (*model.BetAmountLog, error)
	Find() ([]*model.BetAmountLog, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.BetAmountLog, err error)
	FindInBatches(result *[]*model.BetAmountLog, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.BetAmountLog) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) IBetAmountLogDo
	Assign(attrs ...field.AssignExpr) IBetAmountLogDo
	Joins(fields ...field.RelationField) IBetAmountLogDo
	Preload(fields ...field.RelationField) IBetAmountLogDo
	FirstOrInit() (*model.BetAmountLog, error)
	FirstOrCreate() (*model.BetAmountLog, error)
	FindByPage(offset int, limit int) (result []*model.BetAmountLog, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Rows() (*sql.Rows, error)
	Row() *sql.Row
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) IBetAmountLogDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (b betAmountLogDo) Debug() IBetAmountLogDo {
	return b.withDO(b.DO.Debug())
}

func (b betAmountLogDo) WithContext(ctx context.Context) IBetAmountLogDo {
	return b.withDO(b.DO.WithContext(ctx))
}

func (b betAmountLogDo) ReadDB() IBetAmountLogDo {
	return b.Clauses(dbresolver.Read)
}

func (b betAmountLogDo) WriteDB() IBetAmountLogDo {
	return b.Clauses(dbresolver.Write)
}

func (b betAmountLogDo) Session(config *gorm.Session) IBetAmountLogDo {
	return b.withDO(b.DO.Session(config))
}

func (b betAmountLogDo) Clauses(conds ...clause.Expression) IBetAmountLogDo {
	return b.withDO(b.DO.Clauses(conds...))
}

func (b betAmountLogDo) Returning(value interface{}, columns ...string) IBetAmountLogDo {
	return b.withDO(b.DO.Returning(value, columns...))
}

func (b betAmountLogDo) Not(conds ...gen.Condition) IBetAmountLogDo {
	return b.withDO(b.DO.Not(conds...))
}

func (b betAmountLogDo) Or(conds ...gen.Condition) IBetAmountLogDo {
	return b.withDO(b.DO.Or(conds...))
}

func (b betAmountLogDo) Select(conds ...field.Expr) IBetAmountLogDo {
	return b.withDO(b.DO.Select(conds...))
}

func (b betAmountLogDo) Where(conds ...gen.Condition) IBetAmountLogDo {
	return b.withDO(b.DO.Where(conds...))
}

func (b betAmountLogDo) Order(conds ...field.Expr) IBetAmountLogDo {
	return b.withDO(b.DO.Order(conds...))
}

func (b betAmountLogDo) Distinct(cols ...field.Expr) IBetAmountLogDo {
	return b.withDO(b.DO.Distinct(cols...))
}

func (b betAmountLogDo) Omit(cols ...field.Expr) IBetAmountLogDo {
	return b.withDO(b.DO.Omit(cols...))
}

func (b betAmountLogDo) Join(table schema.Tabler, on ...field.Expr) IBetAmountLogDo {
	return b.withDO(b.DO.Join(table, on...))
}

func (b betAmountLogDo) LeftJoin(table schema.Tabler, on ...field.Expr) IBetAmountLogDo {
	return b.withDO(b.DO.LeftJoin(table, on...))
}

func (b betAmountLogDo) RightJoin(table schema.Tabler, on ...field.Expr) IBetAmountLogDo {
	return b.withDO(b.DO.RightJoin(table, on...))
}

func (b betAmountLogDo) Group(cols ...field.Expr) IBetAmountLogDo {
	return b.withDO(b.DO.Group(cols...))
}

func (b betAmountLogDo) Having(conds ...gen.Condition) IBetAmountLogDo {
	return b.withDO(b.DO.Having(conds...))
}

func (b betAmountLogDo) Limit(limit int) IBetAmountLogDo {
	return b.withDO(b.DO.Limit(limit))
}

func (b betAmountLogDo) Offset(offset int) IBetAmountLogDo {
	return b.withDO(b.DO.Offset(offset))
}

func (b betAmountLogDo) Scopes(funcs ...func(gen.Dao) gen.Dao) IBetAmountLogDo {
	return b.withDO(b.DO.Scopes(funcs...))
}

func (b betAmountLogDo) Unscoped() IBetAmountLogDo {
	return b.withDO(b.DO.Unscoped())
}

func (b betAmountLogDo) Create(values ...*model.BetAmountLog) error {
	if len(values) == 0 {
		return nil
	}
	return b.DO.Create(values)
}

func (b betAmountLogDo) CreateInBatches(values []*model.BetAmountLog, batchSize int) error {
	return b.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (b betAmountLogDo) Save(values ...*model.BetAmountLog) error {
	if len(values) == 0 {
		return nil
	}
	return b.DO.Save(values)
}

func (b betAmountLogDo) First() (*model.BetAmountLog, error) {
	if result, err := b.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.BetAmountLog), nil
	}
}

func (b betAmountLogDo) Take() (*model.BetAmountLog, error) {
	if result, err := b.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.BetAmountLog), nil
	}
}

func (b betAmountLogDo) Last() (*model.BetAmountLog, error) {
	if result, err := b.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.BetAmountLog), nil
	}
}

func (b betAmountLogDo) Find() ([]*model.BetAmountLog, error) {
	result, err := b.DO.Find()
	return result.([]*model.BetAmountLog), err
}

func (b betAmountLogDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.BetAmountLog, err error) {
	buf := make([]*model.BetAmountLog, 0, batchSize)
	err = b.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (b betAmountLogDo) FindInBatches(result *[]*model.BetAmountLog, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return b.DO.FindInBatches(result, batchSize, fc)
}

func (b betAmountLogDo) Attrs(attrs ...field.AssignExpr) IBetAmountLogDo {
	return b.withDO(b.DO.Attrs(attrs...))
}

func (b betAmountLogDo) Assign(attrs ...field.AssignExpr) IBetAmountLogDo {
	return b.withDO(b.DO.Assign(attrs...))
}

func (b betAmountLogDo) Joins(fields ...field.RelationField) IBetAmountLogDo {
	for _, _f := range fields {
		b = *b.withDO(b.DO.Joins(_f))
	}
	return &b
}

func (b betAmountLogDo) Preload(fields ...field.RelationField) IBetAmountLogDo {
	for _, _f := range fields {
		b = *b.withDO(b.DO.Preload(_f))
	}
	return &b
}

func (b betAmountLogDo) FirstOrInit() (*model.BetAmountLog, error) {
	if result, err := b.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.BetAmountLog), nil
	}
}

func (b betAmountLogDo) FirstOrCreate() (*model.BetAmountLog, error) {
	if result, err := b.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.BetAmountLog), nil
	}
}

func (b betAmountLogDo) FindByPage(offset int, limit int) (result []*model.BetAmountLog, count int64, err error) {
	result, err = b.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = b.Offset(-1).Limit(-1).Count()
	return
}

func (b betAmountLogDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = b.Count()
	if err != nil {
		return
	}

	err = b.Offset(offset).Limit(limit).Scan(result)
	return
}

func (b betAmountLogDo) Scan(result interface{}) (err error) {
	return b.DO.Scan(result)
}

func (b betAmountLogDo) Delete(models ...*model.BetAmountLog) (result gen.ResultInfo, err error) {
	return b.DO.Delete(models)
}

func (b *betAmountLogDo) withDO(do gen.Dao) *betAmountLogDo {
	b.DO = *do.(*gen.DO)
	return b
}
