// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package query

import (
	"context"
	"database/sql"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"github.com/davy66666/rpc_common/dao/model"
)

func newWithdrawalChannel(db *gorm.DB, opts ...gen.DOOption) withdrawalChannel {
	_withdrawalChannel := withdrawalChannel{}

	_withdrawalChannel.withdrawalChannelDo.UseDB(db, opts...)
	_withdrawalChannel.withdrawalChannelDo.UseModel(&model.WithdrawalChannel{})

	tableName := _withdrawalChannel.withdrawalChannelDo.TableName()
	_withdrawalChannel.ALL = field.NewAsterisk(tableName)
	_withdrawalChannel.ID = field.NewInt64(tableName, "id")
	_withdrawalChannel.PayLevelID = field.NewString(tableName, "pay_level_id")
	_withdrawalChannel.PayTitle = field.NewString(tableName, "pay_title")
	_withdrawalChannel.Type = field.NewInt64(tableName, "type")
	_withdrawalChannel.WithdrawalMinAmount = field.NewFloat64(tableName, "withdrawal_min_amount")
	_withdrawalChannel.WithdrawalMaxAmount = field.NewFloat64(tableName, "withdrawal_max_amount")
	_withdrawalChannel.MaxWithdraw = field.NewInt64(tableName, "max_withdraw")
	_withdrawalChannel.WithdrawFee = field.NewFloat64(tableName, "withdraw_fee")
	_withdrawalChannel.GiftMoneyRate = field.NewFloat64(tableName, "gift_money_rate")
	_withdrawalChannel.Sort = field.NewInt64(tableName, "sort")
	_withdrawalChannel.IsOpen = field.NewInt64(tableName, "is_open")
	_withdrawalChannel.Remark = field.NewString(tableName, "remark")
	_withdrawalChannel.CreatedAt = field.NewField(tableName, "created_at")
	_withdrawalChannel.UpdatedAt = field.NewField(tableName, "updated_at")
	_withdrawalChannel.AdminName = field.NewString(tableName, "admin_name")
	_withdrawalChannel.IsRiskOpen = field.NewInt64(tableName, "is_risk_open")
	_withdrawalChannel.RiskRuleID = field.NewInt64(tableName, "risk_rule_id")
	_withdrawalChannel.FundsType = field.NewInt64(tableName, "funds_type")

	_withdrawalChannel.fillFieldMap()

	return _withdrawalChannel
}

type withdrawalChannel struct {
	withdrawalChannelDo withdrawalChannelDo

	ALL                 field.Asterisk
	ID                  field.Int64
	PayLevelID          field.String  // 支付分层ID
	PayTitle            field.String  // 取款标题
	Type                field.Int64   // 取款类型;1:普通取款;2:虚拟币取款
	WithdrawalMinAmount field.Float64 // 取款最小金额
	WithdrawalMaxAmount field.Float64 // 取款最大金额
	MaxWithdraw         field.Int64   // 取款最大次数
	WithdrawFee         field.Float64 // 取款手续费比例
	GiftMoneyRate       field.Float64
	Sort                field.Int64  // 排序,从小到大排序
	IsOpen              field.Int64  // 是否启用
	Remark              field.String // 备注
	CreatedAt           field.Field
	UpdatedAt           field.Field
	AdminName           field.String
	IsRiskOpen          field.Int64 // 风控开关1开 0关
	RiskRuleID          field.Int64 // 关联规则集
	FundsType           field.Int64 // 资金类型：1 rmb，2 usdt 3钱包

	fieldMap map[string]field.Expr
}

func (w withdrawalChannel) Table(newTableName string) *withdrawalChannel {
	w.withdrawalChannelDo.UseTable(newTableName)
	return w.updateTableName(newTableName)
}

func (w withdrawalChannel) As(alias string) *withdrawalChannel {
	w.withdrawalChannelDo.DO = *(w.withdrawalChannelDo.As(alias).(*gen.DO))
	return w.updateTableName(alias)
}

func (w *withdrawalChannel) updateTableName(table string) *withdrawalChannel {
	w.ALL = field.NewAsterisk(table)
	w.ID = field.NewInt64(table, "id")
	w.PayLevelID = field.NewString(table, "pay_level_id")
	w.PayTitle = field.NewString(table, "pay_title")
	w.Type = field.NewInt64(table, "type")
	w.WithdrawalMinAmount = field.NewFloat64(table, "withdrawal_min_amount")
	w.WithdrawalMaxAmount = field.NewFloat64(table, "withdrawal_max_amount")
	w.MaxWithdraw = field.NewInt64(table, "max_withdraw")
	w.WithdrawFee = field.NewFloat64(table, "withdraw_fee")
	w.GiftMoneyRate = field.NewFloat64(table, "gift_money_rate")
	w.Sort = field.NewInt64(table, "sort")
	w.IsOpen = field.NewInt64(table, "is_open")
	w.Remark = field.NewString(table, "remark")
	w.CreatedAt = field.NewField(table, "created_at")
	w.UpdatedAt = field.NewField(table, "updated_at")
	w.AdminName = field.NewString(table, "admin_name")
	w.IsRiskOpen = field.NewInt64(table, "is_risk_open")
	w.RiskRuleID = field.NewInt64(table, "risk_rule_id")
	w.FundsType = field.NewInt64(table, "funds_type")

	w.fillFieldMap()

	return w
}

func (w *withdrawalChannel) WithContext(ctx context.Context) IWithdrawalChannelDo {
	return w.withdrawalChannelDo.WithContext(ctx)
}

func (w withdrawalChannel) TableName() string { return w.withdrawalChannelDo.TableName() }

func (w withdrawalChannel) Alias() string { return w.withdrawalChannelDo.Alias() }

func (w withdrawalChannel) Columns(cols ...field.Expr) gen.Columns {
	return w.withdrawalChannelDo.Columns(cols...)
}

func (w *withdrawalChannel) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := w.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (w *withdrawalChannel) fillFieldMap() {
	w.fieldMap = make(map[string]field.Expr, 18)
	w.fieldMap["id"] = w.ID
	w.fieldMap["pay_level_id"] = w.PayLevelID
	w.fieldMap["pay_title"] = w.PayTitle
	w.fieldMap["type"] = w.Type
	w.fieldMap["withdrawal_min_amount"] = w.WithdrawalMinAmount
	w.fieldMap["withdrawal_max_amount"] = w.WithdrawalMaxAmount
	w.fieldMap["max_withdraw"] = w.MaxWithdraw
	w.fieldMap["withdraw_fee"] = w.WithdrawFee
	w.fieldMap["gift_money_rate"] = w.GiftMoneyRate
	w.fieldMap["sort"] = w.Sort
	w.fieldMap["is_open"] = w.IsOpen
	w.fieldMap["remark"] = w.Remark
	w.fieldMap["created_at"] = w.CreatedAt
	w.fieldMap["updated_at"] = w.UpdatedAt
	w.fieldMap["admin_name"] = w.AdminName
	w.fieldMap["is_risk_open"] = w.IsRiskOpen
	w.fieldMap["risk_rule_id"] = w.RiskRuleID
	w.fieldMap["funds_type"] = w.FundsType
}

func (w withdrawalChannel) clone(db *gorm.DB) withdrawalChannel {
	w.withdrawalChannelDo.ReplaceConnPool(db.Statement.ConnPool)
	return w
}

func (w withdrawalChannel) replaceDB(db *gorm.DB) withdrawalChannel {
	w.withdrawalChannelDo.ReplaceDB(db)
	return w
}

type withdrawalChannelDo struct{ gen.DO }

type IWithdrawalChannelDo interface {
	gen.SubQuery
	Debug() IWithdrawalChannelDo
	WithContext(ctx context.Context) IWithdrawalChannelDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() IWithdrawalChannelDo
	WriteDB() IWithdrawalChannelDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) IWithdrawalChannelDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) IWithdrawalChannelDo
	Not(conds ...gen.Condition) IWithdrawalChannelDo
	Or(conds ...gen.Condition) IWithdrawalChannelDo
	Select(conds ...field.Expr) IWithdrawalChannelDo
	Where(conds ...gen.Condition) IWithdrawalChannelDo
	Order(conds ...field.Expr) IWithdrawalChannelDo
	Distinct(cols ...field.Expr) IWithdrawalChannelDo
	Omit(cols ...field.Expr) IWithdrawalChannelDo
	Join(table schema.Tabler, on ...field.Expr) IWithdrawalChannelDo
	LeftJoin(table schema.Tabler, on ...field.Expr) IWithdrawalChannelDo
	RightJoin(table schema.Tabler, on ...field.Expr) IWithdrawalChannelDo
	Group(cols ...field.Expr) IWithdrawalChannelDo
	Having(conds ...gen.Condition) IWithdrawalChannelDo
	Limit(limit int) IWithdrawalChannelDo
	Offset(offset int) IWithdrawalChannelDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) IWithdrawalChannelDo
	Unscoped() IWithdrawalChannelDo
	Create(values ...*model.WithdrawalChannel) error
	CreateInBatches(values []*model.WithdrawalChannel, batchSize int) error
	Save(values ...*model.WithdrawalChannel) error
	First() (*model.WithdrawalChannel, error)
	Take() (*model.WithdrawalChannel, error)
	Last() (*model.WithdrawalChannel, error)
	Find() ([]*model.WithdrawalChannel, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.WithdrawalChannel, err error)
	FindInBatches(result *[]*model.WithdrawalChannel, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.WithdrawalChannel) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) IWithdrawalChannelDo
	Assign(attrs ...field.AssignExpr) IWithdrawalChannelDo
	Joins(fields ...field.RelationField) IWithdrawalChannelDo
	Preload(fields ...field.RelationField) IWithdrawalChannelDo
	FirstOrInit() (*model.WithdrawalChannel, error)
	FirstOrCreate() (*model.WithdrawalChannel, error)
	FindByPage(offset int, limit int) (result []*model.WithdrawalChannel, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Rows() (*sql.Rows, error)
	Row() *sql.Row
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) IWithdrawalChannelDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (w withdrawalChannelDo) Debug() IWithdrawalChannelDo {
	return w.withDO(w.DO.Debug())
}

func (w withdrawalChannelDo) WithContext(ctx context.Context) IWithdrawalChannelDo {
	return w.withDO(w.DO.WithContext(ctx))
}

func (w withdrawalChannelDo) ReadDB() IWithdrawalChannelDo {
	return w.Clauses(dbresolver.Read)
}

func (w withdrawalChannelDo) WriteDB() IWithdrawalChannelDo {
	return w.Clauses(dbresolver.Write)
}

func (w withdrawalChannelDo) Session(config *gorm.Session) IWithdrawalChannelDo {
	return w.withDO(w.DO.Session(config))
}

func (w withdrawalChannelDo) Clauses(conds ...clause.Expression) IWithdrawalChannelDo {
	return w.withDO(w.DO.Clauses(conds...))
}

func (w withdrawalChannelDo) Returning(value interface{}, columns ...string) IWithdrawalChannelDo {
	return w.withDO(w.DO.Returning(value, columns...))
}

func (w withdrawalChannelDo) Not(conds ...gen.Condition) IWithdrawalChannelDo {
	return w.withDO(w.DO.Not(conds...))
}

func (w withdrawalChannelDo) Or(conds ...gen.Condition) IWithdrawalChannelDo {
	return w.withDO(w.DO.Or(conds...))
}

func (w withdrawalChannelDo) Select(conds ...field.Expr) IWithdrawalChannelDo {
	return w.withDO(w.DO.Select(conds...))
}

func (w withdrawalChannelDo) Where(conds ...gen.Condition) IWithdrawalChannelDo {
	return w.withDO(w.DO.Where(conds...))
}

func (w withdrawalChannelDo) Order(conds ...field.Expr) IWithdrawalChannelDo {
	return w.withDO(w.DO.Order(conds...))
}

func (w withdrawalChannelDo) Distinct(cols ...field.Expr) IWithdrawalChannelDo {
	return w.withDO(w.DO.Distinct(cols...))
}

func (w withdrawalChannelDo) Omit(cols ...field.Expr) IWithdrawalChannelDo {
	return w.withDO(w.DO.Omit(cols...))
}

func (w withdrawalChannelDo) Join(table schema.Tabler, on ...field.Expr) IWithdrawalChannelDo {
	return w.withDO(w.DO.Join(table, on...))
}

func (w withdrawalChannelDo) LeftJoin(table schema.Tabler, on ...field.Expr) IWithdrawalChannelDo {
	return w.withDO(w.DO.LeftJoin(table, on...))
}

func (w withdrawalChannelDo) RightJoin(table schema.Tabler, on ...field.Expr) IWithdrawalChannelDo {
	return w.withDO(w.DO.RightJoin(table, on...))
}

func (w withdrawalChannelDo) Group(cols ...field.Expr) IWithdrawalChannelDo {
	return w.withDO(w.DO.Group(cols...))
}

func (w withdrawalChannelDo) Having(conds ...gen.Condition) IWithdrawalChannelDo {
	return w.withDO(w.DO.Having(conds...))
}

func (w withdrawalChannelDo) Limit(limit int) IWithdrawalChannelDo {
	return w.withDO(w.DO.Limit(limit))
}

func (w withdrawalChannelDo) Offset(offset int) IWithdrawalChannelDo {
	return w.withDO(w.DO.Offset(offset))
}

func (w withdrawalChannelDo) Scopes(funcs ...func(gen.Dao) gen.Dao) IWithdrawalChannelDo {
	return w.withDO(w.DO.Scopes(funcs...))
}

func (w withdrawalChannelDo) Unscoped() IWithdrawalChannelDo {
	return w.withDO(w.DO.Unscoped())
}

func (w withdrawalChannelDo) Create(values ...*model.WithdrawalChannel) error {
	if len(values) == 0 {
		return nil
	}
	return w.DO.Create(values)
}

func (w withdrawalChannelDo) CreateInBatches(values []*model.WithdrawalChannel, batchSize int) error {
	return w.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (w withdrawalChannelDo) Save(values ...*model.WithdrawalChannel) error {
	if len(values) == 0 {
		return nil
	}
	return w.DO.Save(values)
}

func (w withdrawalChannelDo) First() (*model.WithdrawalChannel, error) {
	if result, err := w.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.WithdrawalChannel), nil
	}
}

func (w withdrawalChannelDo) Take() (*model.WithdrawalChannel, error) {
	if result, err := w.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.WithdrawalChannel), nil
	}
}

func (w withdrawalChannelDo) Last() (*model.WithdrawalChannel, error) {
	if result, err := w.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.WithdrawalChannel), nil
	}
}

func (w withdrawalChannelDo) Find() ([]*model.WithdrawalChannel, error) {
	result, err := w.DO.Find()
	return result.([]*model.WithdrawalChannel), err
}

func (w withdrawalChannelDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.WithdrawalChannel, err error) {
	buf := make([]*model.WithdrawalChannel, 0, batchSize)
	err = w.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (w withdrawalChannelDo) FindInBatches(result *[]*model.WithdrawalChannel, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return w.DO.FindInBatches(result, batchSize, fc)
}

func (w withdrawalChannelDo) Attrs(attrs ...field.AssignExpr) IWithdrawalChannelDo {
	return w.withDO(w.DO.Attrs(attrs...))
}

func (w withdrawalChannelDo) Assign(attrs ...field.AssignExpr) IWithdrawalChannelDo {
	return w.withDO(w.DO.Assign(attrs...))
}

func (w withdrawalChannelDo) Joins(fields ...field.RelationField) IWithdrawalChannelDo {
	for _, _f := range fields {
		w = *w.withDO(w.DO.Joins(_f))
	}
	return &w
}

func (w withdrawalChannelDo) Preload(fields ...field.RelationField) IWithdrawalChannelDo {
	for _, _f := range fields {
		w = *w.withDO(w.DO.Preload(_f))
	}
	return &w
}

func (w withdrawalChannelDo) FirstOrInit() (*model.WithdrawalChannel, error) {
	if result, err := w.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.WithdrawalChannel), nil
	}
}

func (w withdrawalChannelDo) FirstOrCreate() (*model.WithdrawalChannel, error) {
	if result, err := w.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.WithdrawalChannel), nil
	}
}

func (w withdrawalChannelDo) FindByPage(offset int, limit int) (result []*model.WithdrawalChannel, count int64, err error) {
	result, err = w.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = w.Offset(-1).Limit(-1).Count()
	return
}

func (w withdrawalChannelDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = w.Count()
	if err != nil {
		return
	}

	err = w.Offset(offset).Limit(limit).Scan(result)
	return
}

func (w withdrawalChannelDo) Scan(result interface{}) (err error) {
	return w.DO.Scan(result)
}

func (w withdrawalChannelDo) Delete(models ...*model.WithdrawalChannel) (result gen.ResultInfo, err error) {
	return w.DO.Delete(models)
}

func (w *withdrawalChannelDo) withDO(do gen.Dao) *withdrawalChannelDo {
	w.DO = *do.(*gen.DO)
	return w
}
