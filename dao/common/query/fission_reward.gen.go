// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package query

import (
	"context"
	"database/sql"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"github.com/davy66666/rpc_common/dao/model"
)

func newFissionReward(db *gorm.DB, opts ...gen.DOOption) fissionReward {
	_fissionReward := fissionReward{}

	_fissionReward.fissionRewardDo.UseDB(db, opts...)
	_fissionReward.fissionRewardDo.UseModel(&model.FissionReward{})

	tableName := _fissionReward.fissionRewardDo.TableName()
	_fissionReward.ALL = field.NewAsterisk(tableName)
	_fissionReward.ID = field.NewInt64(tableName, "id")
	_fissionReward.UserID = field.NewInt64(tableName, "user_id")
	_fissionReward.Username = field.NewString(tableName, "username")
	_fissionReward.PayLevelsID = field.NewInt64(tableName, "pay_levels_id")
	_fissionReward.PayLevelsName = field.NewString(tableName, "pay_levels_name")
	_fissionReward.FromUserID = field.NewInt64(tableName, "from_user_id")
	_fissionReward.FromUsername = field.NewString(tableName, "from_username")
	_fissionReward.RewardType = field.NewInt64(tableName, "reward_type")
	_fissionReward.Money = field.NewFloat64(tableName, "money")
	_fissionReward.RewardStatus = field.NewInt64(tableName, "reward_status")
	_fissionReward.CreatedAt = field.NewField(tableName, "created_at")
	_fissionReward.UpdatedAt = field.NewField(tableName, "updated_at")
	_fissionReward.AuditRemark = field.NewString(tableName, "audit_remark")
	_fissionReward.AuditTime = field.NewField(tableName, "audit_time")
	_fissionReward.AuditUsername = field.NewString(tableName, "audit_username")
	_fissionReward.BackflowExt = field.NewString(tableName, "backflow_ext")
	_fissionReward.UsernameParentName = field.NewString(tableName, "username_parent_name")
	_fissionReward.FromUsernameParentName = field.NewString(tableName, "from_username_parent_name")

	_fissionReward.fillFieldMap()

	return _fissionReward
}

// fissionReward 裂变奖励
type fissionReward struct {
	fissionRewardDo fissionRewardDo

	ALL                    field.Asterisk
	ID                     field.Int64   // 主键
	UserID                 field.Int64   // 用戶id
	Username               field.String  // 用户账号
	PayLevelsID            field.Int64   // 支付层级id
	PayLevelsName          field.String  // 支付层级name
	FromUserID             field.Int64   // 来自用戶id
	FromUsername           field.String  // 来自用户账号
	RewardType             field.Int64   // 0好友绑定账户、1好友首充、2好友打码返利
	Money                  field.Float64 // 金额
	RewardStatus           field.Int64   // 0待派发,1已派发,2拒绝派发
	CreatedAt              field.Field   // 生成时间
	UpdatedAt              field.Field   // 更新时间
	AuditRemark            field.String  // 审核备注
	AuditTime              field.Field   // 审核时间
	AuditUsername          field.String  // 审核人
	BackflowExt            field.String  // 返水扩展字段
	UsernameParentName     field.String  // 邀请人代理商
	FromUsernameParentName field.String  // 好友代理商

	fieldMap map[string]field.Expr
}

func (f fissionReward) Table(newTableName string) *fissionReward {
	f.fissionRewardDo.UseTable(newTableName)
	return f.updateTableName(newTableName)
}

func (f fissionReward) As(alias string) *fissionReward {
	f.fissionRewardDo.DO = *(f.fissionRewardDo.As(alias).(*gen.DO))
	return f.updateTableName(alias)
}

func (f *fissionReward) updateTableName(table string) *fissionReward {
	f.ALL = field.NewAsterisk(table)
	f.ID = field.NewInt64(table, "id")
	f.UserID = field.NewInt64(table, "user_id")
	f.Username = field.NewString(table, "username")
	f.PayLevelsID = field.NewInt64(table, "pay_levels_id")
	f.PayLevelsName = field.NewString(table, "pay_levels_name")
	f.FromUserID = field.NewInt64(table, "from_user_id")
	f.FromUsername = field.NewString(table, "from_username")
	f.RewardType = field.NewInt64(table, "reward_type")
	f.Money = field.NewFloat64(table, "money")
	f.RewardStatus = field.NewInt64(table, "reward_status")
	f.CreatedAt = field.NewField(table, "created_at")
	f.UpdatedAt = field.NewField(table, "updated_at")
	f.AuditRemark = field.NewString(table, "audit_remark")
	f.AuditTime = field.NewField(table, "audit_time")
	f.AuditUsername = field.NewString(table, "audit_username")
	f.BackflowExt = field.NewString(table, "backflow_ext")
	f.UsernameParentName = field.NewString(table, "username_parent_name")
	f.FromUsernameParentName = field.NewString(table, "from_username_parent_name")

	f.fillFieldMap()

	return f
}

func (f *fissionReward) WithContext(ctx context.Context) IFissionRewardDo {
	return f.fissionRewardDo.WithContext(ctx)
}

func (f fissionReward) TableName() string { return f.fissionRewardDo.TableName() }

func (f fissionReward) Alias() string { return f.fissionRewardDo.Alias() }

func (f fissionReward) Columns(cols ...field.Expr) gen.Columns {
	return f.fissionRewardDo.Columns(cols...)
}

func (f *fissionReward) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := f.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (f *fissionReward) fillFieldMap() {
	f.fieldMap = make(map[string]field.Expr, 18)
	f.fieldMap["id"] = f.ID
	f.fieldMap["user_id"] = f.UserID
	f.fieldMap["username"] = f.Username
	f.fieldMap["pay_levels_id"] = f.PayLevelsID
	f.fieldMap["pay_levels_name"] = f.PayLevelsName
	f.fieldMap["from_user_id"] = f.FromUserID
	f.fieldMap["from_username"] = f.FromUsername
	f.fieldMap["reward_type"] = f.RewardType
	f.fieldMap["money"] = f.Money
	f.fieldMap["reward_status"] = f.RewardStatus
	f.fieldMap["created_at"] = f.CreatedAt
	f.fieldMap["updated_at"] = f.UpdatedAt
	f.fieldMap["audit_remark"] = f.AuditRemark
	f.fieldMap["audit_time"] = f.AuditTime
	f.fieldMap["audit_username"] = f.AuditUsername
	f.fieldMap["backflow_ext"] = f.BackflowExt
	f.fieldMap["username_parent_name"] = f.UsernameParentName
	f.fieldMap["from_username_parent_name"] = f.FromUsernameParentName
}

func (f fissionReward) clone(db *gorm.DB) fissionReward {
	f.fissionRewardDo.ReplaceConnPool(db.Statement.ConnPool)
	return f
}

func (f fissionReward) replaceDB(db *gorm.DB) fissionReward {
	f.fissionRewardDo.ReplaceDB(db)
	return f
}

type fissionRewardDo struct{ gen.DO }

type IFissionRewardDo interface {
	gen.SubQuery
	Debug() IFissionRewardDo
	WithContext(ctx context.Context) IFissionRewardDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() IFissionRewardDo
	WriteDB() IFissionRewardDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) IFissionRewardDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) IFissionRewardDo
	Not(conds ...gen.Condition) IFissionRewardDo
	Or(conds ...gen.Condition) IFissionRewardDo
	Select(conds ...field.Expr) IFissionRewardDo
	Where(conds ...gen.Condition) IFissionRewardDo
	Order(conds ...field.Expr) IFissionRewardDo
	Distinct(cols ...field.Expr) IFissionRewardDo
	Omit(cols ...field.Expr) IFissionRewardDo
	Join(table schema.Tabler, on ...field.Expr) IFissionRewardDo
	LeftJoin(table schema.Tabler, on ...field.Expr) IFissionRewardDo
	RightJoin(table schema.Tabler, on ...field.Expr) IFissionRewardDo
	Group(cols ...field.Expr) IFissionRewardDo
	Having(conds ...gen.Condition) IFissionRewardDo
	Limit(limit int) IFissionRewardDo
	Offset(offset int) IFissionRewardDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) IFissionRewardDo
	Unscoped() IFissionRewardDo
	Create(values ...*model.FissionReward) error
	CreateInBatches(values []*model.FissionReward, batchSize int) error
	Save(values ...*model.FissionReward) error
	First() (*model.FissionReward, error)
	Take() (*model.FissionReward, error)
	Last() (*model.FissionReward, error)
	Find() ([]*model.FissionReward, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.FissionReward, err error)
	FindInBatches(result *[]*model.FissionReward, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.FissionReward) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) IFissionRewardDo
	Assign(attrs ...field.AssignExpr) IFissionRewardDo
	Joins(fields ...field.RelationField) IFissionRewardDo
	Preload(fields ...field.RelationField) IFissionRewardDo
	FirstOrInit() (*model.FissionReward, error)
	FirstOrCreate() (*model.FissionReward, error)
	FindByPage(offset int, limit int) (result []*model.FissionReward, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Rows() (*sql.Rows, error)
	Row() *sql.Row
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) IFissionRewardDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (f fissionRewardDo) Debug() IFissionRewardDo {
	return f.withDO(f.DO.Debug())
}

func (f fissionRewardDo) WithContext(ctx context.Context) IFissionRewardDo {
	return f.withDO(f.DO.WithContext(ctx))
}

func (f fissionRewardDo) ReadDB() IFissionRewardDo {
	return f.Clauses(dbresolver.Read)
}

func (f fissionRewardDo) WriteDB() IFissionRewardDo {
	return f.Clauses(dbresolver.Write)
}

func (f fissionRewardDo) Session(config *gorm.Session) IFissionRewardDo {
	return f.withDO(f.DO.Session(config))
}

func (f fissionRewardDo) Clauses(conds ...clause.Expression) IFissionRewardDo {
	return f.withDO(f.DO.Clauses(conds...))
}

func (f fissionRewardDo) Returning(value interface{}, columns ...string) IFissionRewardDo {
	return f.withDO(f.DO.Returning(value, columns...))
}

func (f fissionRewardDo) Not(conds ...gen.Condition) IFissionRewardDo {
	return f.withDO(f.DO.Not(conds...))
}

func (f fissionRewardDo) Or(conds ...gen.Condition) IFissionRewardDo {
	return f.withDO(f.DO.Or(conds...))
}

func (f fissionRewardDo) Select(conds ...field.Expr) IFissionRewardDo {
	return f.withDO(f.DO.Select(conds...))
}

func (f fissionRewardDo) Where(conds ...gen.Condition) IFissionRewardDo {
	return f.withDO(f.DO.Where(conds...))
}

func (f fissionRewardDo) Order(conds ...field.Expr) IFissionRewardDo {
	return f.withDO(f.DO.Order(conds...))
}

func (f fissionRewardDo) Distinct(cols ...field.Expr) IFissionRewardDo {
	return f.withDO(f.DO.Distinct(cols...))
}

func (f fissionRewardDo) Omit(cols ...field.Expr) IFissionRewardDo {
	return f.withDO(f.DO.Omit(cols...))
}

func (f fissionRewardDo) Join(table schema.Tabler, on ...field.Expr) IFissionRewardDo {
	return f.withDO(f.DO.Join(table, on...))
}

func (f fissionRewardDo) LeftJoin(table schema.Tabler, on ...field.Expr) IFissionRewardDo {
	return f.withDO(f.DO.LeftJoin(table, on...))
}

func (f fissionRewardDo) RightJoin(table schema.Tabler, on ...field.Expr) IFissionRewardDo {
	return f.withDO(f.DO.RightJoin(table, on...))
}

func (f fissionRewardDo) Group(cols ...field.Expr) IFissionRewardDo {
	return f.withDO(f.DO.Group(cols...))
}

func (f fissionRewardDo) Having(conds ...gen.Condition) IFissionRewardDo {
	return f.withDO(f.DO.Having(conds...))
}

func (f fissionRewardDo) Limit(limit int) IFissionRewardDo {
	return f.withDO(f.DO.Limit(limit))
}

func (f fissionRewardDo) Offset(offset int) IFissionRewardDo {
	return f.withDO(f.DO.Offset(offset))
}

func (f fissionRewardDo) Scopes(funcs ...func(gen.Dao) gen.Dao) IFissionRewardDo {
	return f.withDO(f.DO.Scopes(funcs...))
}

func (f fissionRewardDo) Unscoped() IFissionRewardDo {
	return f.withDO(f.DO.Unscoped())
}

func (f fissionRewardDo) Create(values ...*model.FissionReward) error {
	if len(values) == 0 {
		return nil
	}
	return f.DO.Create(values)
}

func (f fissionRewardDo) CreateInBatches(values []*model.FissionReward, batchSize int) error {
	return f.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (f fissionRewardDo) Save(values ...*model.FissionReward) error {
	if len(values) == 0 {
		return nil
	}
	return f.DO.Save(values)
}

func (f fissionRewardDo) First() (*model.FissionReward, error) {
	if result, err := f.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.FissionReward), nil
	}
}

func (f fissionRewardDo) Take() (*model.FissionReward, error) {
	if result, err := f.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.FissionReward), nil
	}
}

func (f fissionRewardDo) Last() (*model.FissionReward, error) {
	if result, err := f.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.FissionReward), nil
	}
}

func (f fissionRewardDo) Find() ([]*model.FissionReward, error) {
	result, err := f.DO.Find()
	return result.([]*model.FissionReward), err
}

func (f fissionRewardDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.FissionReward, err error) {
	buf := make([]*model.FissionReward, 0, batchSize)
	err = f.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (f fissionRewardDo) FindInBatches(result *[]*model.FissionReward, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return f.DO.FindInBatches(result, batchSize, fc)
}

func (f fissionRewardDo) Attrs(attrs ...field.AssignExpr) IFissionRewardDo {
	return f.withDO(f.DO.Attrs(attrs...))
}

func (f fissionRewardDo) Assign(attrs ...field.AssignExpr) IFissionRewardDo {
	return f.withDO(f.DO.Assign(attrs...))
}

func (f fissionRewardDo) Joins(fields ...field.RelationField) IFissionRewardDo {
	for _, _f := range fields {
		f = *f.withDO(f.DO.Joins(_f))
	}
	return &f
}

func (f fissionRewardDo) Preload(fields ...field.RelationField) IFissionRewardDo {
	for _, _f := range fields {
		f = *f.withDO(f.DO.Preload(_f))
	}
	return &f
}

func (f fissionRewardDo) FirstOrInit() (*model.FissionReward, error) {
	if result, err := f.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.FissionReward), nil
	}
}

func (f fissionRewardDo) FirstOrCreate() (*model.FissionReward, error) {
	if result, err := f.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.FissionReward), nil
	}
}

func (f fissionRewardDo) FindByPage(offset int, limit int) (result []*model.FissionReward, count int64, err error) {
	result, err = f.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = f.Offset(-1).Limit(-1).Count()
	return
}

func (f fissionRewardDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = f.Count()
	if err != nil {
		return
	}

	err = f.Offset(offset).Limit(limit).Scan(result)
	return
}

func (f fissionRewardDo) Scan(result interface{}) (err error) {
	return f.DO.Scan(result)
}

func (f fissionRewardDo) Delete(models ...*model.FissionReward) (result gen.ResultInfo, err error) {
	return f.DO.Delete(models)
}

func (f *fissionRewardDo) withDO(do gen.Dao) *fissionRewardDo {
	f.DO = *do.(*gen.DO)
	return f
}
