// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package query

import (
	"context"
	"database/sql"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"github.com/davy66666/rpc_common/dao/model"
)

func newTransactionReport(db *gorm.DB, opts ...gen.DOOption) transactionReport {
	_transactionReport := transactionReport{}

	_transactionReport.transactionReportDo.UseDB(db, opts...)
	_transactionReport.transactionReportDo.UseModel(&model.TransactionReport{})

	tableName := _transactionReport.transactionReportDo.TableName()
	_transactionReport.ALL = field.NewAsterisk(tableName)
	_transactionReport.ID = field.NewInt64(tableName, "id")
	_transactionReport.UserID = field.NewInt64(tableName, "user_id")
	_transactionReport.Username = field.NewString(tableName, "username")
	_transactionReport.Date = field.NewTime(tableName, "date")
	_transactionReport.ParentID = field.NewInt64(tableName, "parent_id")
	_transactionReport.ForefatherIds = field.NewString(tableName, "forefather_ids")
	_transactionReport.TransFatherID = field.NewInt64(tableName, "trans_father_id")
	_transactionReport.TransTypesID = field.NewInt64(tableName, "trans_types_id")
	_transactionReport.Amount = field.NewFloat64(tableName, "amount")
	_transactionReport.Count = field.NewInt64(tableName, "count")
	_transactionReport.CreatedAt = field.NewField(tableName, "created_at")
	_transactionReport.UpdatedAt = field.NewField(tableName, "updated_at")

	_transactionReport.fillFieldMap()

	return _transactionReport
}

type transactionReport struct {
	transactionReportDo transactionReportDo

	ALL           field.Asterisk
	ID            field.Int64
	UserID        field.Int64   // 会员id
	Username      field.String  // 会员名称
	Date          field.Time    // 时间
	ParentID      field.Int64   // 上级id
	ForefatherIds field.String  // 代理树
	TransFatherID field.Int64   // 帐变父级类型
	TransTypesID  field.Int64   // 帐变类型
	Amount        field.Float64 // 金额
	Count         field.Int64   // 笔数
	CreatedAt     field.Field
	UpdatedAt     field.Field

	fieldMap map[string]field.Expr
}

func (t transactionReport) Table(newTableName string) *transactionReport {
	t.transactionReportDo.UseTable(newTableName)
	return t.updateTableName(newTableName)
}

func (t transactionReport) As(alias string) *transactionReport {
	t.transactionReportDo.DO = *(t.transactionReportDo.As(alias).(*gen.DO))
	return t.updateTableName(alias)
}

func (t *transactionReport) updateTableName(table string) *transactionReport {
	t.ALL = field.NewAsterisk(table)
	t.ID = field.NewInt64(table, "id")
	t.UserID = field.NewInt64(table, "user_id")
	t.Username = field.NewString(table, "username")
	t.Date = field.NewTime(table, "date")
	t.ParentID = field.NewInt64(table, "parent_id")
	t.ForefatherIds = field.NewString(table, "forefather_ids")
	t.TransFatherID = field.NewInt64(table, "trans_father_id")
	t.TransTypesID = field.NewInt64(table, "trans_types_id")
	t.Amount = field.NewFloat64(table, "amount")
	t.Count = field.NewInt64(table, "count")
	t.CreatedAt = field.NewField(table, "created_at")
	t.UpdatedAt = field.NewField(table, "updated_at")

	t.fillFieldMap()

	return t
}

func (t *transactionReport) WithContext(ctx context.Context) ITransactionReportDo {
	return t.transactionReportDo.WithContext(ctx)
}

func (t transactionReport) TableName() string { return t.transactionReportDo.TableName() }

func (t transactionReport) Alias() string { return t.transactionReportDo.Alias() }

func (t transactionReport) Columns(cols ...field.Expr) gen.Columns {
	return t.transactionReportDo.Columns(cols...)
}

func (t *transactionReport) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := t.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (t *transactionReport) fillFieldMap() {
	t.fieldMap = make(map[string]field.Expr, 12)
	t.fieldMap["id"] = t.ID
	t.fieldMap["user_id"] = t.UserID
	t.fieldMap["username"] = t.Username
	t.fieldMap["date"] = t.Date
	t.fieldMap["parent_id"] = t.ParentID
	t.fieldMap["forefather_ids"] = t.ForefatherIds
	t.fieldMap["trans_father_id"] = t.TransFatherID
	t.fieldMap["trans_types_id"] = t.TransTypesID
	t.fieldMap["amount"] = t.Amount
	t.fieldMap["count"] = t.Count
	t.fieldMap["created_at"] = t.CreatedAt
	t.fieldMap["updated_at"] = t.UpdatedAt
}

func (t transactionReport) clone(db *gorm.DB) transactionReport {
	t.transactionReportDo.ReplaceConnPool(db.Statement.ConnPool)
	return t
}

func (t transactionReport) replaceDB(db *gorm.DB) transactionReport {
	t.transactionReportDo.ReplaceDB(db)
	return t
}

type transactionReportDo struct{ gen.DO }

type ITransactionReportDo interface {
	gen.SubQuery
	Debug() ITransactionReportDo
	WithContext(ctx context.Context) ITransactionReportDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() ITransactionReportDo
	WriteDB() ITransactionReportDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) ITransactionReportDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) ITransactionReportDo
	Not(conds ...gen.Condition) ITransactionReportDo
	Or(conds ...gen.Condition) ITransactionReportDo
	Select(conds ...field.Expr) ITransactionReportDo
	Where(conds ...gen.Condition) ITransactionReportDo
	Order(conds ...field.Expr) ITransactionReportDo
	Distinct(cols ...field.Expr) ITransactionReportDo
	Omit(cols ...field.Expr) ITransactionReportDo
	Join(table schema.Tabler, on ...field.Expr) ITransactionReportDo
	LeftJoin(table schema.Tabler, on ...field.Expr) ITransactionReportDo
	RightJoin(table schema.Tabler, on ...field.Expr) ITransactionReportDo
	Group(cols ...field.Expr) ITransactionReportDo
	Having(conds ...gen.Condition) ITransactionReportDo
	Limit(limit int) ITransactionReportDo
	Offset(offset int) ITransactionReportDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) ITransactionReportDo
	Unscoped() ITransactionReportDo
	Create(values ...*model.TransactionReport) error
	CreateInBatches(values []*model.TransactionReport, batchSize int) error
	Save(values ...*model.TransactionReport) error
	First() (*model.TransactionReport, error)
	Take() (*model.TransactionReport, error)
	Last() (*model.TransactionReport, error)
	Find() ([]*model.TransactionReport, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.TransactionReport, err error)
	FindInBatches(result *[]*model.TransactionReport, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.TransactionReport) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) ITransactionReportDo
	Assign(attrs ...field.AssignExpr) ITransactionReportDo
	Joins(fields ...field.RelationField) ITransactionReportDo
	Preload(fields ...field.RelationField) ITransactionReportDo
	FirstOrInit() (*model.TransactionReport, error)
	FirstOrCreate() (*model.TransactionReport, error)
	FindByPage(offset int, limit int) (result []*model.TransactionReport, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Rows() (*sql.Rows, error)
	Row() *sql.Row
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) ITransactionReportDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (t transactionReportDo) Debug() ITransactionReportDo {
	return t.withDO(t.DO.Debug())
}

func (t transactionReportDo) WithContext(ctx context.Context) ITransactionReportDo {
	return t.withDO(t.DO.WithContext(ctx))
}

func (t transactionReportDo) ReadDB() ITransactionReportDo {
	return t.Clauses(dbresolver.Read)
}

func (t transactionReportDo) WriteDB() ITransactionReportDo {
	return t.Clauses(dbresolver.Write)
}

func (t transactionReportDo) Session(config *gorm.Session) ITransactionReportDo {
	return t.withDO(t.DO.Session(config))
}

func (t transactionReportDo) Clauses(conds ...clause.Expression) ITransactionReportDo {
	return t.withDO(t.DO.Clauses(conds...))
}

func (t transactionReportDo) Returning(value interface{}, columns ...string) ITransactionReportDo {
	return t.withDO(t.DO.Returning(value, columns...))
}

func (t transactionReportDo) Not(conds ...gen.Condition) ITransactionReportDo {
	return t.withDO(t.DO.Not(conds...))
}

func (t transactionReportDo) Or(conds ...gen.Condition) ITransactionReportDo {
	return t.withDO(t.DO.Or(conds...))
}

func (t transactionReportDo) Select(conds ...field.Expr) ITransactionReportDo {
	return t.withDO(t.DO.Select(conds...))
}

func (t transactionReportDo) Where(conds ...gen.Condition) ITransactionReportDo {
	return t.withDO(t.DO.Where(conds...))
}

func (t transactionReportDo) Order(conds ...field.Expr) ITransactionReportDo {
	return t.withDO(t.DO.Order(conds...))
}

func (t transactionReportDo) Distinct(cols ...field.Expr) ITransactionReportDo {
	return t.withDO(t.DO.Distinct(cols...))
}

func (t transactionReportDo) Omit(cols ...field.Expr) ITransactionReportDo {
	return t.withDO(t.DO.Omit(cols...))
}

func (t transactionReportDo) Join(table schema.Tabler, on ...field.Expr) ITransactionReportDo {
	return t.withDO(t.DO.Join(table, on...))
}

func (t transactionReportDo) LeftJoin(table schema.Tabler, on ...field.Expr) ITransactionReportDo {
	return t.withDO(t.DO.LeftJoin(table, on...))
}

func (t transactionReportDo) RightJoin(table schema.Tabler, on ...field.Expr) ITransactionReportDo {
	return t.withDO(t.DO.RightJoin(table, on...))
}

func (t transactionReportDo) Group(cols ...field.Expr) ITransactionReportDo {
	return t.withDO(t.DO.Group(cols...))
}

func (t transactionReportDo) Having(conds ...gen.Condition) ITransactionReportDo {
	return t.withDO(t.DO.Having(conds...))
}

func (t transactionReportDo) Limit(limit int) ITransactionReportDo {
	return t.withDO(t.DO.Limit(limit))
}

func (t transactionReportDo) Offset(offset int) ITransactionReportDo {
	return t.withDO(t.DO.Offset(offset))
}

func (t transactionReportDo) Scopes(funcs ...func(gen.Dao) gen.Dao) ITransactionReportDo {
	return t.withDO(t.DO.Scopes(funcs...))
}

func (t transactionReportDo) Unscoped() ITransactionReportDo {
	return t.withDO(t.DO.Unscoped())
}

func (t transactionReportDo) Create(values ...*model.TransactionReport) error {
	if len(values) == 0 {
		return nil
	}
	return t.DO.Create(values)
}

func (t transactionReportDo) CreateInBatches(values []*model.TransactionReport, batchSize int) error {
	return t.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (t transactionReportDo) Save(values ...*model.TransactionReport) error {
	if len(values) == 0 {
		return nil
	}
	return t.DO.Save(values)
}

func (t transactionReportDo) First() (*model.TransactionReport, error) {
	if result, err := t.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.TransactionReport), nil
	}
}

func (t transactionReportDo) Take() (*model.TransactionReport, error) {
	if result, err := t.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.TransactionReport), nil
	}
}

func (t transactionReportDo) Last() (*model.TransactionReport, error) {
	if result, err := t.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.TransactionReport), nil
	}
}

func (t transactionReportDo) Find() ([]*model.TransactionReport, error) {
	result, err := t.DO.Find()
	return result.([]*model.TransactionReport), err
}

func (t transactionReportDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.TransactionReport, err error) {
	buf := make([]*model.TransactionReport, 0, batchSize)
	err = t.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (t transactionReportDo) FindInBatches(result *[]*model.TransactionReport, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return t.DO.FindInBatches(result, batchSize, fc)
}

func (t transactionReportDo) Attrs(attrs ...field.AssignExpr) ITransactionReportDo {
	return t.withDO(t.DO.Attrs(attrs...))
}

func (t transactionReportDo) Assign(attrs ...field.AssignExpr) ITransactionReportDo {
	return t.withDO(t.DO.Assign(attrs...))
}

func (t transactionReportDo) Joins(fields ...field.RelationField) ITransactionReportDo {
	for _, _f := range fields {
		t = *t.withDO(t.DO.Joins(_f))
	}
	return &t
}

func (t transactionReportDo) Preload(fields ...field.RelationField) ITransactionReportDo {
	for _, _f := range fields {
		t = *t.withDO(t.DO.Preload(_f))
	}
	return &t
}

func (t transactionReportDo) FirstOrInit() (*model.TransactionReport, error) {
	if result, err := t.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.TransactionReport), nil
	}
}

func (t transactionReportDo) FirstOrCreate() (*model.TransactionReport, error) {
	if result, err := t.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.TransactionReport), nil
	}
}

func (t transactionReportDo) FindByPage(offset int, limit int) (result []*model.TransactionReport, count int64, err error) {
	result, err = t.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = t.Offset(-1).Limit(-1).Count()
	return
}

func (t transactionReportDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = t.Count()
	if err != nil {
		return
	}

	err = t.Offset(offset).Limit(limit).Scan(result)
	return
}

func (t transactionReportDo) Scan(result interface{}) (err error) {
	return t.DO.Scan(result)
}

func (t transactionReportDo) Delete(models ...*model.TransactionReport) (result gen.ResultInfo, err error) {
	return t.DO.Delete(models)
}

func (t *transactionReportDo) withDO(do gen.Dao) *transactionReportDo {
	t.DO = *do.(*gen.DO)
	return t
}
