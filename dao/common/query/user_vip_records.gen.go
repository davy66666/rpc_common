// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package query

import (
	"context"
	"database/sql"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"github.com/davy66666/rpc_common/dao/model"
)

func newUserVipRecord(db *gorm.DB, opts ...gen.DOOption) userVipRecord {
	_userVipRecord := userVipRecord{}

	_userVipRecord.userVipRecordDo.UseDB(db, opts...)
	_userVipRecord.userVipRecordDo.UseModel(&model.UserVipRecord{})

	tableName := _userVipRecord.userVipRecordDo.TableName()
	_userVipRecord.ALL = field.NewAsterisk(tableName)
	_userVipRecord.ID = field.NewInt64(tableName, "id")
	_userVipRecord.UserID = field.NewInt64(tableName, "user_id")
	_userVipRecord.Username = field.NewString(tableName, "username")
	_userVipRecord.ParentID = field.NewInt64(tableName, "parent_id")
	_userVipRecord.ParentName = field.NewString(tableName, "parent_name")
	_userVipRecord.ForefatherIds = field.NewString(tableName, "forefather_ids")
	_userVipRecord.BetAmount = field.NewFloat64(tableName, "bet_amount")
	_userVipRecord.UserLevel = field.NewInt64(tableName, "user_level")
	_userVipRecord.NeedBetAmount = field.NewFloat64(tableName, "need_bet_amount")
	_userVipRecord.UserVipsRewardID = field.NewInt64(tableName, "user_vips_reward_id")
	_userVipRecord.UserVipsRewardTitle = field.NewString(tableName, "user_vips_reward_title")
	_userVipRecord.Status = field.NewInt64(tableName, "status")
	_userVipRecord.Money = field.NewFloat64(tableName, "money")
	_userVipRecord.IsManual = field.NewInt64(tableName, "is_manual")
	_userVipRecord.Remark = field.NewString(tableName, "remark")
	_userVipRecord.OperateAt = field.NewField(tableName, "operate_at")
	_userVipRecord.CreatedAt = field.NewField(tableName, "created_at")
	_userVipRecord.UpdatedAt = field.NewField(tableName, "updated_at")
	_userVipRecord.UserLevelUpdatedAt = field.NewField(tableName, "user_level_updated_at")

	_userVipRecord.fillFieldMap()

	return _userVipRecord
}

// userVipRecord vip奖品领取记录表
type userVipRecord struct {
	userVipRecordDo userVipRecordDo

	ALL                 field.Asterisk
	ID                  field.Int64
	UserID              field.Int64   // 用户id
	Username            field.String  // 用户名
	ParentID            field.Int64   // 上级id
	ParentName          field.String  // 上级用户名
	ForefatherIds       field.String  // 上级树,多个以逗号隔开
	BetAmount           field.Float64 // 用户投注金额
	UserLevel           field.Int64   // 用户vip 等级
	NeedBetAmount       field.Float64 // 晋级需要打码量
	UserVipsRewardID    field.Int64   // user_vips_rewards 的id
	UserVipsRewardTitle field.String  // 领取的具体内容
	Status              field.Int64   // 0:未派发;1:派发进行中;2:已派发;
	Money               field.Float64 // 如果是钱的话 领取的钱
	IsManual            field.Int64   // 是否手动0:否;1:是
	Remark              field.String  // 备注
	OperateAt           field.Field   // 派发时间
	CreatedAt           field.Field
	UpdatedAt           field.Field
	UserLevelUpdatedAt  field.Field // vip晋级时间

	fieldMap map[string]field.Expr
}

func (u userVipRecord) Table(newTableName string) *userVipRecord {
	u.userVipRecordDo.UseTable(newTableName)
	return u.updateTableName(newTableName)
}

func (u userVipRecord) As(alias string) *userVipRecord {
	u.userVipRecordDo.DO = *(u.userVipRecordDo.As(alias).(*gen.DO))
	return u.updateTableName(alias)
}

func (u *userVipRecord) updateTableName(table string) *userVipRecord {
	u.ALL = field.NewAsterisk(table)
	u.ID = field.NewInt64(table, "id")
	u.UserID = field.NewInt64(table, "user_id")
	u.Username = field.NewString(table, "username")
	u.ParentID = field.NewInt64(table, "parent_id")
	u.ParentName = field.NewString(table, "parent_name")
	u.ForefatherIds = field.NewString(table, "forefather_ids")
	u.BetAmount = field.NewFloat64(table, "bet_amount")
	u.UserLevel = field.NewInt64(table, "user_level")
	u.NeedBetAmount = field.NewFloat64(table, "need_bet_amount")
	u.UserVipsRewardID = field.NewInt64(table, "user_vips_reward_id")
	u.UserVipsRewardTitle = field.NewString(table, "user_vips_reward_title")
	u.Status = field.NewInt64(table, "status")
	u.Money = field.NewFloat64(table, "money")
	u.IsManual = field.NewInt64(table, "is_manual")
	u.Remark = field.NewString(table, "remark")
	u.OperateAt = field.NewField(table, "operate_at")
	u.CreatedAt = field.NewField(table, "created_at")
	u.UpdatedAt = field.NewField(table, "updated_at")
	u.UserLevelUpdatedAt = field.NewField(table, "user_level_updated_at")

	u.fillFieldMap()

	return u
}

func (u *userVipRecord) WithContext(ctx context.Context) IUserVipRecordDo {
	return u.userVipRecordDo.WithContext(ctx)
}

func (u userVipRecord) TableName() string { return u.userVipRecordDo.TableName() }

func (u userVipRecord) Alias() string { return u.userVipRecordDo.Alias() }

func (u userVipRecord) Columns(cols ...field.Expr) gen.Columns {
	return u.userVipRecordDo.Columns(cols...)
}

func (u *userVipRecord) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := u.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (u *userVipRecord) fillFieldMap() {
	u.fieldMap = make(map[string]field.Expr, 19)
	u.fieldMap["id"] = u.ID
	u.fieldMap["user_id"] = u.UserID
	u.fieldMap["username"] = u.Username
	u.fieldMap["parent_id"] = u.ParentID
	u.fieldMap["parent_name"] = u.ParentName
	u.fieldMap["forefather_ids"] = u.ForefatherIds
	u.fieldMap["bet_amount"] = u.BetAmount
	u.fieldMap["user_level"] = u.UserLevel
	u.fieldMap["need_bet_amount"] = u.NeedBetAmount
	u.fieldMap["user_vips_reward_id"] = u.UserVipsRewardID
	u.fieldMap["user_vips_reward_title"] = u.UserVipsRewardTitle
	u.fieldMap["status"] = u.Status
	u.fieldMap["money"] = u.Money
	u.fieldMap["is_manual"] = u.IsManual
	u.fieldMap["remark"] = u.Remark
	u.fieldMap["operate_at"] = u.OperateAt
	u.fieldMap["created_at"] = u.CreatedAt
	u.fieldMap["updated_at"] = u.UpdatedAt
	u.fieldMap["user_level_updated_at"] = u.UserLevelUpdatedAt
}

func (u userVipRecord) clone(db *gorm.DB) userVipRecord {
	u.userVipRecordDo.ReplaceConnPool(db.Statement.ConnPool)
	return u
}

func (u userVipRecord) replaceDB(db *gorm.DB) userVipRecord {
	u.userVipRecordDo.ReplaceDB(db)
	return u
}

type userVipRecordDo struct{ gen.DO }

type IUserVipRecordDo interface {
	gen.SubQuery
	Debug() IUserVipRecordDo
	WithContext(ctx context.Context) IUserVipRecordDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() IUserVipRecordDo
	WriteDB() IUserVipRecordDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) IUserVipRecordDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) IUserVipRecordDo
	Not(conds ...gen.Condition) IUserVipRecordDo
	Or(conds ...gen.Condition) IUserVipRecordDo
	Select(conds ...field.Expr) IUserVipRecordDo
	Where(conds ...gen.Condition) IUserVipRecordDo
	Order(conds ...field.Expr) IUserVipRecordDo
	Distinct(cols ...field.Expr) IUserVipRecordDo
	Omit(cols ...field.Expr) IUserVipRecordDo
	Join(table schema.Tabler, on ...field.Expr) IUserVipRecordDo
	LeftJoin(table schema.Tabler, on ...field.Expr) IUserVipRecordDo
	RightJoin(table schema.Tabler, on ...field.Expr) IUserVipRecordDo
	Group(cols ...field.Expr) IUserVipRecordDo
	Having(conds ...gen.Condition) IUserVipRecordDo
	Limit(limit int) IUserVipRecordDo
	Offset(offset int) IUserVipRecordDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) IUserVipRecordDo
	Unscoped() IUserVipRecordDo
	Create(values ...*model.UserVipRecord) error
	CreateInBatches(values []*model.UserVipRecord, batchSize int) error
	Save(values ...*model.UserVipRecord) error
	First() (*model.UserVipRecord, error)
	Take() (*model.UserVipRecord, error)
	Last() (*model.UserVipRecord, error)
	Find() ([]*model.UserVipRecord, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.UserVipRecord, err error)
	FindInBatches(result *[]*model.UserVipRecord, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.UserVipRecord) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) IUserVipRecordDo
	Assign(attrs ...field.AssignExpr) IUserVipRecordDo
	Joins(fields ...field.RelationField) IUserVipRecordDo
	Preload(fields ...field.RelationField) IUserVipRecordDo
	FirstOrInit() (*model.UserVipRecord, error)
	FirstOrCreate() (*model.UserVipRecord, error)
	FindByPage(offset int, limit int) (result []*model.UserVipRecord, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Rows() (*sql.Rows, error)
	Row() *sql.Row
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) IUserVipRecordDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (u userVipRecordDo) Debug() IUserVipRecordDo {
	return u.withDO(u.DO.Debug())
}

func (u userVipRecordDo) WithContext(ctx context.Context) IUserVipRecordDo {
	return u.withDO(u.DO.WithContext(ctx))
}

func (u userVipRecordDo) ReadDB() IUserVipRecordDo {
	return u.Clauses(dbresolver.Read)
}

func (u userVipRecordDo) WriteDB() IUserVipRecordDo {
	return u.Clauses(dbresolver.Write)
}

func (u userVipRecordDo) Session(config *gorm.Session) IUserVipRecordDo {
	return u.withDO(u.DO.Session(config))
}

func (u userVipRecordDo) Clauses(conds ...clause.Expression) IUserVipRecordDo {
	return u.withDO(u.DO.Clauses(conds...))
}

func (u userVipRecordDo) Returning(value interface{}, columns ...string) IUserVipRecordDo {
	return u.withDO(u.DO.Returning(value, columns...))
}

func (u userVipRecordDo) Not(conds ...gen.Condition) IUserVipRecordDo {
	return u.withDO(u.DO.Not(conds...))
}

func (u userVipRecordDo) Or(conds ...gen.Condition) IUserVipRecordDo {
	return u.withDO(u.DO.Or(conds...))
}

func (u userVipRecordDo) Select(conds ...field.Expr) IUserVipRecordDo {
	return u.withDO(u.DO.Select(conds...))
}

func (u userVipRecordDo) Where(conds ...gen.Condition) IUserVipRecordDo {
	return u.withDO(u.DO.Where(conds...))
}

func (u userVipRecordDo) Order(conds ...field.Expr) IUserVipRecordDo {
	return u.withDO(u.DO.Order(conds...))
}

func (u userVipRecordDo) Distinct(cols ...field.Expr) IUserVipRecordDo {
	return u.withDO(u.DO.Distinct(cols...))
}

func (u userVipRecordDo) Omit(cols ...field.Expr) IUserVipRecordDo {
	return u.withDO(u.DO.Omit(cols...))
}

func (u userVipRecordDo) Join(table schema.Tabler, on ...field.Expr) IUserVipRecordDo {
	return u.withDO(u.DO.Join(table, on...))
}

func (u userVipRecordDo) LeftJoin(table schema.Tabler, on ...field.Expr) IUserVipRecordDo {
	return u.withDO(u.DO.LeftJoin(table, on...))
}

func (u userVipRecordDo) RightJoin(table schema.Tabler, on ...field.Expr) IUserVipRecordDo {
	return u.withDO(u.DO.RightJoin(table, on...))
}

func (u userVipRecordDo) Group(cols ...field.Expr) IUserVipRecordDo {
	return u.withDO(u.DO.Group(cols...))
}

func (u userVipRecordDo) Having(conds ...gen.Condition) IUserVipRecordDo {
	return u.withDO(u.DO.Having(conds...))
}

func (u userVipRecordDo) Limit(limit int) IUserVipRecordDo {
	return u.withDO(u.DO.Limit(limit))
}

func (u userVipRecordDo) Offset(offset int) IUserVipRecordDo {
	return u.withDO(u.DO.Offset(offset))
}

func (u userVipRecordDo) Scopes(funcs ...func(gen.Dao) gen.Dao) IUserVipRecordDo {
	return u.withDO(u.DO.Scopes(funcs...))
}

func (u userVipRecordDo) Unscoped() IUserVipRecordDo {
	return u.withDO(u.DO.Unscoped())
}

func (u userVipRecordDo) Create(values ...*model.UserVipRecord) error {
	if len(values) == 0 {
		return nil
	}
	return u.DO.Create(values)
}

func (u userVipRecordDo) CreateInBatches(values []*model.UserVipRecord, batchSize int) error {
	return u.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (u userVipRecordDo) Save(values ...*model.UserVipRecord) error {
	if len(values) == 0 {
		return nil
	}
	return u.DO.Save(values)
}

func (u userVipRecordDo) First() (*model.UserVipRecord, error) {
	if result, err := u.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.UserVipRecord), nil
	}
}

func (u userVipRecordDo) Take() (*model.UserVipRecord, error) {
	if result, err := u.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.UserVipRecord), nil
	}
}

func (u userVipRecordDo) Last() (*model.UserVipRecord, error) {
	if result, err := u.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.UserVipRecord), nil
	}
}

func (u userVipRecordDo) Find() ([]*model.UserVipRecord, error) {
	result, err := u.DO.Find()
	return result.([]*model.UserVipRecord), err
}

func (u userVipRecordDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.UserVipRecord, err error) {
	buf := make([]*model.UserVipRecord, 0, batchSize)
	err = u.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (u userVipRecordDo) FindInBatches(result *[]*model.UserVipRecord, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return u.DO.FindInBatches(result, batchSize, fc)
}

func (u userVipRecordDo) Attrs(attrs ...field.AssignExpr) IUserVipRecordDo {
	return u.withDO(u.DO.Attrs(attrs...))
}

func (u userVipRecordDo) Assign(attrs ...field.AssignExpr) IUserVipRecordDo {
	return u.withDO(u.DO.Assign(attrs...))
}

func (u userVipRecordDo) Joins(fields ...field.RelationField) IUserVipRecordDo {
	for _, _f := range fields {
		u = *u.withDO(u.DO.Joins(_f))
	}
	return &u
}

func (u userVipRecordDo) Preload(fields ...field.RelationField) IUserVipRecordDo {
	for _, _f := range fields {
		u = *u.withDO(u.DO.Preload(_f))
	}
	return &u
}

func (u userVipRecordDo) FirstOrInit() (*model.UserVipRecord, error) {
	if result, err := u.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.UserVipRecord), nil
	}
}

func (u userVipRecordDo) FirstOrCreate() (*model.UserVipRecord, error) {
	if result, err := u.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.UserVipRecord), nil
	}
}

func (u userVipRecordDo) FindByPage(offset int, limit int) (result []*model.UserVipRecord, count int64, err error) {
	result, err = u.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = u.Offset(-1).Limit(-1).Count()
	return
}

func (u userVipRecordDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = u.Count()
	if err != nil {
		return
	}

	err = u.Offset(offset).Limit(limit).Scan(result)
	return
}

func (u userVipRecordDo) Scan(result interface{}) (err error) {
	return u.DO.Scan(result)
}

func (u userVipRecordDo) Delete(models ...*model.UserVipRecord) (result gen.ResultInfo, err error) {
	return u.DO.Delete(models)
}

func (u *userVipRecordDo) withDO(do gen.Dao) *userVipRecordDo {
	u.DO = *do.(*gen.DO)
	return u
}
