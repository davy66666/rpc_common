// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package query

import (
	"context"
	"database/sql"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"github.com/davy66666/rpc_common/dao/model"
)

func newDepositChannelType(db *gorm.DB, opts ...gen.DOOption) depositChannelType {
	_depositChannelType := depositChannelType{}

	_depositChannelType.depositChannelTypeDo.UseDB(db, opts...)
	_depositChannelType.depositChannelTypeDo.UseModel(&model.DepositChannelType{})

	tableName := _depositChannelType.depositChannelTypeDo.TableName()
	_depositChannelType.ALL = field.NewAsterisk(tableName)
	_depositChannelType.ID = field.NewInt64(tableName, "id")
	_depositChannelType.Platform = field.NewString(tableName, "platform")
	_depositChannelType.PayLevelIds = field.NewString(tableName, "pay_level_ids")
	_depositChannelType.FundsType = field.NewInt64(tableName, "funds_type")
	_depositChannelType.Sort = field.NewInt64(tableName, "sort")
	_depositChannelType.AdminUser = field.NewString(tableName, "admin_user")
	_depositChannelType.IsOpen = field.NewInt64(tableName, "is_open")
	_depositChannelType.Remark = field.NewString(tableName, "remark")
	_depositChannelType.CreatedAt = field.NewField(tableName, "created_at")
	_depositChannelType.UpdatedAt = field.NewField(tableName, "updated_at")

	_depositChannelType.fillFieldMap()

	return _depositChannelType
}

// depositChannelType 充值渠道类型
type depositChannelType struct {
	depositChannelTypeDo depositChannelTypeDo

	ALL         field.Asterisk
	ID          field.Int64
	Platform    field.String // 支付平台,1:手机端;4:pc端
	PayLevelIds field.String // 支付层级id,多个逗号分隔
	FundsType   field.Int64  // 资金类型：1 rmb，2 usdt 3钱包
	Sort        field.Int64  // 排序
	AdminUser   field.String // 操作人员
	IsOpen      field.Int64  // 是否开启 0:否; 1:是
	Remark      field.String // 备注
	CreatedAt   field.Field
	UpdatedAt   field.Field

	fieldMap map[string]field.Expr
}

func (d depositChannelType) Table(newTableName string) *depositChannelType {
	d.depositChannelTypeDo.UseTable(newTableName)
	return d.updateTableName(newTableName)
}

func (d depositChannelType) As(alias string) *depositChannelType {
	d.depositChannelTypeDo.DO = *(d.depositChannelTypeDo.As(alias).(*gen.DO))
	return d.updateTableName(alias)
}

func (d *depositChannelType) updateTableName(table string) *depositChannelType {
	d.ALL = field.NewAsterisk(table)
	d.ID = field.NewInt64(table, "id")
	d.Platform = field.NewString(table, "platform")
	d.PayLevelIds = field.NewString(table, "pay_level_ids")
	d.FundsType = field.NewInt64(table, "funds_type")
	d.Sort = field.NewInt64(table, "sort")
	d.AdminUser = field.NewString(table, "admin_user")
	d.IsOpen = field.NewInt64(table, "is_open")
	d.Remark = field.NewString(table, "remark")
	d.CreatedAt = field.NewField(table, "created_at")
	d.UpdatedAt = field.NewField(table, "updated_at")

	d.fillFieldMap()

	return d
}

func (d *depositChannelType) WithContext(ctx context.Context) IDepositChannelTypeDo {
	return d.depositChannelTypeDo.WithContext(ctx)
}

func (d depositChannelType) TableName() string { return d.depositChannelTypeDo.TableName() }

func (d depositChannelType) Alias() string { return d.depositChannelTypeDo.Alias() }

func (d depositChannelType) Columns(cols ...field.Expr) gen.Columns {
	return d.depositChannelTypeDo.Columns(cols...)
}

func (d *depositChannelType) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := d.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (d *depositChannelType) fillFieldMap() {
	d.fieldMap = make(map[string]field.Expr, 10)
	d.fieldMap["id"] = d.ID
	d.fieldMap["platform"] = d.Platform
	d.fieldMap["pay_level_ids"] = d.PayLevelIds
	d.fieldMap["funds_type"] = d.FundsType
	d.fieldMap["sort"] = d.Sort
	d.fieldMap["admin_user"] = d.AdminUser
	d.fieldMap["is_open"] = d.IsOpen
	d.fieldMap["remark"] = d.Remark
	d.fieldMap["created_at"] = d.CreatedAt
	d.fieldMap["updated_at"] = d.UpdatedAt
}

func (d depositChannelType) clone(db *gorm.DB) depositChannelType {
	d.depositChannelTypeDo.ReplaceConnPool(db.Statement.ConnPool)
	return d
}

func (d depositChannelType) replaceDB(db *gorm.DB) depositChannelType {
	d.depositChannelTypeDo.ReplaceDB(db)
	return d
}

type depositChannelTypeDo struct{ gen.DO }

type IDepositChannelTypeDo interface {
	gen.SubQuery
	Debug() IDepositChannelTypeDo
	WithContext(ctx context.Context) IDepositChannelTypeDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() IDepositChannelTypeDo
	WriteDB() IDepositChannelTypeDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) IDepositChannelTypeDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) IDepositChannelTypeDo
	Not(conds ...gen.Condition) IDepositChannelTypeDo
	Or(conds ...gen.Condition) IDepositChannelTypeDo
	Select(conds ...field.Expr) IDepositChannelTypeDo
	Where(conds ...gen.Condition) IDepositChannelTypeDo
	Order(conds ...field.Expr) IDepositChannelTypeDo
	Distinct(cols ...field.Expr) IDepositChannelTypeDo
	Omit(cols ...field.Expr) IDepositChannelTypeDo
	Join(table schema.Tabler, on ...field.Expr) IDepositChannelTypeDo
	LeftJoin(table schema.Tabler, on ...field.Expr) IDepositChannelTypeDo
	RightJoin(table schema.Tabler, on ...field.Expr) IDepositChannelTypeDo
	Group(cols ...field.Expr) IDepositChannelTypeDo
	Having(conds ...gen.Condition) IDepositChannelTypeDo
	Limit(limit int) IDepositChannelTypeDo
	Offset(offset int) IDepositChannelTypeDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) IDepositChannelTypeDo
	Unscoped() IDepositChannelTypeDo
	Create(values ...*model.DepositChannelType) error
	CreateInBatches(values []*model.DepositChannelType, batchSize int) error
	Save(values ...*model.DepositChannelType) error
	First() (*model.DepositChannelType, error)
	Take() (*model.DepositChannelType, error)
	Last() (*model.DepositChannelType, error)
	Find() ([]*model.DepositChannelType, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.DepositChannelType, err error)
	FindInBatches(result *[]*model.DepositChannelType, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.DepositChannelType) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) IDepositChannelTypeDo
	Assign(attrs ...field.AssignExpr) IDepositChannelTypeDo
	Joins(fields ...field.RelationField) IDepositChannelTypeDo
	Preload(fields ...field.RelationField) IDepositChannelTypeDo
	FirstOrInit() (*model.DepositChannelType, error)
	FirstOrCreate() (*model.DepositChannelType, error)
	FindByPage(offset int, limit int) (result []*model.DepositChannelType, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Rows() (*sql.Rows, error)
	Row() *sql.Row
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) IDepositChannelTypeDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (d depositChannelTypeDo) Debug() IDepositChannelTypeDo {
	return d.withDO(d.DO.Debug())
}

func (d depositChannelTypeDo) WithContext(ctx context.Context) IDepositChannelTypeDo {
	return d.withDO(d.DO.WithContext(ctx))
}

func (d depositChannelTypeDo) ReadDB() IDepositChannelTypeDo {
	return d.Clauses(dbresolver.Read)
}

func (d depositChannelTypeDo) WriteDB() IDepositChannelTypeDo {
	return d.Clauses(dbresolver.Write)
}

func (d depositChannelTypeDo) Session(config *gorm.Session) IDepositChannelTypeDo {
	return d.withDO(d.DO.Session(config))
}

func (d depositChannelTypeDo) Clauses(conds ...clause.Expression) IDepositChannelTypeDo {
	return d.withDO(d.DO.Clauses(conds...))
}

func (d depositChannelTypeDo) Returning(value interface{}, columns ...string) IDepositChannelTypeDo {
	return d.withDO(d.DO.Returning(value, columns...))
}

func (d depositChannelTypeDo) Not(conds ...gen.Condition) IDepositChannelTypeDo {
	return d.withDO(d.DO.Not(conds...))
}

func (d depositChannelTypeDo) Or(conds ...gen.Condition) IDepositChannelTypeDo {
	return d.withDO(d.DO.Or(conds...))
}

func (d depositChannelTypeDo) Select(conds ...field.Expr) IDepositChannelTypeDo {
	return d.withDO(d.DO.Select(conds...))
}

func (d depositChannelTypeDo) Where(conds ...gen.Condition) IDepositChannelTypeDo {
	return d.withDO(d.DO.Where(conds...))
}

func (d depositChannelTypeDo) Order(conds ...field.Expr) IDepositChannelTypeDo {
	return d.withDO(d.DO.Order(conds...))
}

func (d depositChannelTypeDo) Distinct(cols ...field.Expr) IDepositChannelTypeDo {
	return d.withDO(d.DO.Distinct(cols...))
}

func (d depositChannelTypeDo) Omit(cols ...field.Expr) IDepositChannelTypeDo {
	return d.withDO(d.DO.Omit(cols...))
}

func (d depositChannelTypeDo) Join(table schema.Tabler, on ...field.Expr) IDepositChannelTypeDo {
	return d.withDO(d.DO.Join(table, on...))
}

func (d depositChannelTypeDo) LeftJoin(table schema.Tabler, on ...field.Expr) IDepositChannelTypeDo {
	return d.withDO(d.DO.LeftJoin(table, on...))
}

func (d depositChannelTypeDo) RightJoin(table schema.Tabler, on ...field.Expr) IDepositChannelTypeDo {
	return d.withDO(d.DO.RightJoin(table, on...))
}

func (d depositChannelTypeDo) Group(cols ...field.Expr) IDepositChannelTypeDo {
	return d.withDO(d.DO.Group(cols...))
}

func (d depositChannelTypeDo) Having(conds ...gen.Condition) IDepositChannelTypeDo {
	return d.withDO(d.DO.Having(conds...))
}

func (d depositChannelTypeDo) Limit(limit int) IDepositChannelTypeDo {
	return d.withDO(d.DO.Limit(limit))
}

func (d depositChannelTypeDo) Offset(offset int) IDepositChannelTypeDo {
	return d.withDO(d.DO.Offset(offset))
}

func (d depositChannelTypeDo) Scopes(funcs ...func(gen.Dao) gen.Dao) IDepositChannelTypeDo {
	return d.withDO(d.DO.Scopes(funcs...))
}

func (d depositChannelTypeDo) Unscoped() IDepositChannelTypeDo {
	return d.withDO(d.DO.Unscoped())
}

func (d depositChannelTypeDo) Create(values ...*model.DepositChannelType) error {
	if len(values) == 0 {
		return nil
	}
	return d.DO.Create(values)
}

func (d depositChannelTypeDo) CreateInBatches(values []*model.DepositChannelType, batchSize int) error {
	return d.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (d depositChannelTypeDo) Save(values ...*model.DepositChannelType) error {
	if len(values) == 0 {
		return nil
	}
	return d.DO.Save(values)
}

func (d depositChannelTypeDo) First() (*model.DepositChannelType, error) {
	if result, err := d.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.DepositChannelType), nil
	}
}

func (d depositChannelTypeDo) Take() (*model.DepositChannelType, error) {
	if result, err := d.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.DepositChannelType), nil
	}
}

func (d depositChannelTypeDo) Last() (*model.DepositChannelType, error) {
	if result, err := d.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.DepositChannelType), nil
	}
}

func (d depositChannelTypeDo) Find() ([]*model.DepositChannelType, error) {
	result, err := d.DO.Find()
	return result.([]*model.DepositChannelType), err
}

func (d depositChannelTypeDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.DepositChannelType, err error) {
	buf := make([]*model.DepositChannelType, 0, batchSize)
	err = d.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (d depositChannelTypeDo) FindInBatches(result *[]*model.DepositChannelType, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return d.DO.FindInBatches(result, batchSize, fc)
}

func (d depositChannelTypeDo) Attrs(attrs ...field.AssignExpr) IDepositChannelTypeDo {
	return d.withDO(d.DO.Attrs(attrs...))
}

func (d depositChannelTypeDo) Assign(attrs ...field.AssignExpr) IDepositChannelTypeDo {
	return d.withDO(d.DO.Assign(attrs...))
}

func (d depositChannelTypeDo) Joins(fields ...field.RelationField) IDepositChannelTypeDo {
	for _, _f := range fields {
		d = *d.withDO(d.DO.Joins(_f))
	}
	return &d
}

func (d depositChannelTypeDo) Preload(fields ...field.RelationField) IDepositChannelTypeDo {
	for _, _f := range fields {
		d = *d.withDO(d.DO.Preload(_f))
	}
	return &d
}

func (d depositChannelTypeDo) FirstOrInit() (*model.DepositChannelType, error) {
	if result, err := d.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.DepositChannelType), nil
	}
}

func (d depositChannelTypeDo) FirstOrCreate() (*model.DepositChannelType, error) {
	if result, err := d.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.DepositChannelType), nil
	}
}

func (d depositChannelTypeDo) FindByPage(offset int, limit int) (result []*model.DepositChannelType, count int64, err error) {
	result, err = d.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = d.Offset(-1).Limit(-1).Count()
	return
}

func (d depositChannelTypeDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = d.Count()
	if err != nil {
		return
	}

	err = d.Offset(offset).Limit(limit).Scan(result)
	return
}

func (d depositChannelTypeDo) Scan(result interface{}) (err error) {
	return d.DO.Scan(result)
}

func (d depositChannelTypeDo) Delete(models ...*model.DepositChannelType) (result gen.ResultInfo, err error) {
	return d.DO.Delete(models)
}

func (d *depositChannelTypeDo) withDO(do gen.Dao) *depositChannelTypeDo {
	d.DO = *do.(*gen.DO)
	return d
}
