// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package query

import (
	"context"
	"database/sql"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"github.com/davy66666/rpc_common/dao/model"
)

func newLiveBroadcastPushStat(db *gorm.DB, opts ...gen.DOOption) liveBroadcastPushStat {
	_liveBroadcastPushStat := liveBroadcastPushStat{}

	_liveBroadcastPushStat.liveBroadcastPushStatDo.UseDB(db, opts...)
	_liveBroadcastPushStat.liveBroadcastPushStatDo.UseModel(&model.LiveBroadcastPushStat{})

	tableName := _liveBroadcastPushStat.liveBroadcastPushStatDo.TableName()
	_liveBroadcastPushStat.ALL = field.NewAsterisk(tableName)
	_liveBroadcastPushStat.ID = field.NewInt64(tableName, "id")
	_liveBroadcastPushStat.DateAt = field.NewTime(tableName, "date_at")
	_liveBroadcastPushStat.LiveType = field.NewInt64(tableName, "live_type")
	_liveBroadcastPushStat.AnchorNum = field.NewInt64(tableName, "anchor_num")
	_liveBroadcastPushStat.FirstLiveTime = field.NewField(tableName, "first_live_time")
	_liveBroadcastPushStat.FinallyLiveTime = field.NewField(tableName, "finally_live_time")
	_liveBroadcastPushStat.TotalDuration = field.NewInt64(tableName, "total_duration")
	_liveBroadcastPushStat.WatchNum = field.NewInt64(tableName, "watch_num")
	_liveBroadcastPushStat.OldUserNum = field.NewInt64(tableName, "old_user_num")
	_liveBroadcastPushStat.NoOpenUserNum = field.NewInt64(tableName, "no_open_user_num")
	_liveBroadcastPushStat.OpenUserNum = field.NewInt64(tableName, "open_user_num")
	_liveBroadcastPushStat.FirstRechargeAmount = field.NewFloat64(tableName, "first_recharge_amount")
	_liveBroadcastPushStat.OpenUserDepositAmount = field.NewFloat64(tableName, "open_user_deposit_amount")
	_liveBroadcastPushStat.OldUserDepositAmount = field.NewFloat64(tableName, "old_user_deposit_amount")
	_liveBroadcastPushStat.OpenUserWithdrawAmount = field.NewFloat64(tableName, "open_user_withdraw_amount")
	_liveBroadcastPushStat.OldUserWithdrawAmount = field.NewFloat64(tableName, "old_user_withdraw_amount")
	_liveBroadcastPushStat.OpenUserRate = field.NewFloat64(tableName, "open_user_rate")
	_liveBroadcastPushStat.OpenUserCustomerUnitPrice = field.NewFloat64(tableName, "open_user_customer_unit_price")
	_liveBroadcastPushStat.CreatedAt = field.NewField(tableName, "created_at")
	_liveBroadcastPushStat.UpdatedAt = field.NewField(tableName, "updated_at")

	_liveBroadcastPushStat.fillFieldMap()

	return _liveBroadcastPushStat
}

// liveBroadcastPushStat 直播推送统计表
type liveBroadcastPushStat struct {
	liveBroadcastPushStatDo liveBroadcastPushStatDo

	ALL                       field.Asterisk
	ID                        field.Int64
	DateAt                    field.Time    // 统计日期
	LiveType                  field.Int64   // 直播游戏类型
	AnchorNum                 field.Int64   // 主播人数
	FirstLiveTime             field.Field   // 直播第一场时间
	FinallyLiveTime           field.Field   // 直播最后一场时间
	TotalDuration             field.Int64   // 直播总时长
	WatchNum                  field.Int64   // 合计观看人数
	OldUserNum                field.Int64   // 老客户个数
	NoOpenUserNum             field.Int64   // 未开户个数
	OpenUserNum               field.Int64   // 直播间-开户个数
	FirstRechargeAmount       field.Float64 // 开户首存金额
	OpenUserDepositAmount     field.Float64 // 开户存款总额
	OldUserDepositAmount      field.Float64 // 老会员存款总额
	OpenUserWithdrawAmount    field.Float64 // 开户取款总额
	OldUserWithdrawAmount     field.Float64 // 老会员取款总额
	OpenUserRate              field.Float64 // 开户占比
	OpenUserCustomerUnitPrice field.Float64 // 开户客单价
	CreatedAt                 field.Field
	UpdatedAt                 field.Field

	fieldMap map[string]field.Expr
}

func (l liveBroadcastPushStat) Table(newTableName string) *liveBroadcastPushStat {
	l.liveBroadcastPushStatDo.UseTable(newTableName)
	return l.updateTableName(newTableName)
}

func (l liveBroadcastPushStat) As(alias string) *liveBroadcastPushStat {
	l.liveBroadcastPushStatDo.DO = *(l.liveBroadcastPushStatDo.As(alias).(*gen.DO))
	return l.updateTableName(alias)
}

func (l *liveBroadcastPushStat) updateTableName(table string) *liveBroadcastPushStat {
	l.ALL = field.NewAsterisk(table)
	l.ID = field.NewInt64(table, "id")
	l.DateAt = field.NewTime(table, "date_at")
	l.LiveType = field.NewInt64(table, "live_type")
	l.AnchorNum = field.NewInt64(table, "anchor_num")
	l.FirstLiveTime = field.NewField(table, "first_live_time")
	l.FinallyLiveTime = field.NewField(table, "finally_live_time")
	l.TotalDuration = field.NewInt64(table, "total_duration")
	l.WatchNum = field.NewInt64(table, "watch_num")
	l.OldUserNum = field.NewInt64(table, "old_user_num")
	l.NoOpenUserNum = field.NewInt64(table, "no_open_user_num")
	l.OpenUserNum = field.NewInt64(table, "open_user_num")
	l.FirstRechargeAmount = field.NewFloat64(table, "first_recharge_amount")
	l.OpenUserDepositAmount = field.NewFloat64(table, "open_user_deposit_amount")
	l.OldUserDepositAmount = field.NewFloat64(table, "old_user_deposit_amount")
	l.OpenUserWithdrawAmount = field.NewFloat64(table, "open_user_withdraw_amount")
	l.OldUserWithdrawAmount = field.NewFloat64(table, "old_user_withdraw_amount")
	l.OpenUserRate = field.NewFloat64(table, "open_user_rate")
	l.OpenUserCustomerUnitPrice = field.NewFloat64(table, "open_user_customer_unit_price")
	l.CreatedAt = field.NewField(table, "created_at")
	l.UpdatedAt = field.NewField(table, "updated_at")

	l.fillFieldMap()

	return l
}

func (l *liveBroadcastPushStat) WithContext(ctx context.Context) ILiveBroadcastPushStatDo {
	return l.liveBroadcastPushStatDo.WithContext(ctx)
}

func (l liveBroadcastPushStat) TableName() string { return l.liveBroadcastPushStatDo.TableName() }

func (l liveBroadcastPushStat) Alias() string { return l.liveBroadcastPushStatDo.Alias() }

func (l liveBroadcastPushStat) Columns(cols ...field.Expr) gen.Columns {
	return l.liveBroadcastPushStatDo.Columns(cols...)
}

func (l *liveBroadcastPushStat) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := l.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (l *liveBroadcastPushStat) fillFieldMap() {
	l.fieldMap = make(map[string]field.Expr, 20)
	l.fieldMap["id"] = l.ID
	l.fieldMap["date_at"] = l.DateAt
	l.fieldMap["live_type"] = l.LiveType
	l.fieldMap["anchor_num"] = l.AnchorNum
	l.fieldMap["first_live_time"] = l.FirstLiveTime
	l.fieldMap["finally_live_time"] = l.FinallyLiveTime
	l.fieldMap["total_duration"] = l.TotalDuration
	l.fieldMap["watch_num"] = l.WatchNum
	l.fieldMap["old_user_num"] = l.OldUserNum
	l.fieldMap["no_open_user_num"] = l.NoOpenUserNum
	l.fieldMap["open_user_num"] = l.OpenUserNum
	l.fieldMap["first_recharge_amount"] = l.FirstRechargeAmount
	l.fieldMap["open_user_deposit_amount"] = l.OpenUserDepositAmount
	l.fieldMap["old_user_deposit_amount"] = l.OldUserDepositAmount
	l.fieldMap["open_user_withdraw_amount"] = l.OpenUserWithdrawAmount
	l.fieldMap["old_user_withdraw_amount"] = l.OldUserWithdrawAmount
	l.fieldMap["open_user_rate"] = l.OpenUserRate
	l.fieldMap["open_user_customer_unit_price"] = l.OpenUserCustomerUnitPrice
	l.fieldMap["created_at"] = l.CreatedAt
	l.fieldMap["updated_at"] = l.UpdatedAt
}

func (l liveBroadcastPushStat) clone(db *gorm.DB) liveBroadcastPushStat {
	l.liveBroadcastPushStatDo.ReplaceConnPool(db.Statement.ConnPool)
	return l
}

func (l liveBroadcastPushStat) replaceDB(db *gorm.DB) liveBroadcastPushStat {
	l.liveBroadcastPushStatDo.ReplaceDB(db)
	return l
}

type liveBroadcastPushStatDo struct{ gen.DO }

type ILiveBroadcastPushStatDo interface {
	gen.SubQuery
	Debug() ILiveBroadcastPushStatDo
	WithContext(ctx context.Context) ILiveBroadcastPushStatDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() ILiveBroadcastPushStatDo
	WriteDB() ILiveBroadcastPushStatDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) ILiveBroadcastPushStatDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) ILiveBroadcastPushStatDo
	Not(conds ...gen.Condition) ILiveBroadcastPushStatDo
	Or(conds ...gen.Condition) ILiveBroadcastPushStatDo
	Select(conds ...field.Expr) ILiveBroadcastPushStatDo
	Where(conds ...gen.Condition) ILiveBroadcastPushStatDo
	Order(conds ...field.Expr) ILiveBroadcastPushStatDo
	Distinct(cols ...field.Expr) ILiveBroadcastPushStatDo
	Omit(cols ...field.Expr) ILiveBroadcastPushStatDo
	Join(table schema.Tabler, on ...field.Expr) ILiveBroadcastPushStatDo
	LeftJoin(table schema.Tabler, on ...field.Expr) ILiveBroadcastPushStatDo
	RightJoin(table schema.Tabler, on ...field.Expr) ILiveBroadcastPushStatDo
	Group(cols ...field.Expr) ILiveBroadcastPushStatDo
	Having(conds ...gen.Condition) ILiveBroadcastPushStatDo
	Limit(limit int) ILiveBroadcastPushStatDo
	Offset(offset int) ILiveBroadcastPushStatDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) ILiveBroadcastPushStatDo
	Unscoped() ILiveBroadcastPushStatDo
	Create(values ...*model.LiveBroadcastPushStat) error
	CreateInBatches(values []*model.LiveBroadcastPushStat, batchSize int) error
	Save(values ...*model.LiveBroadcastPushStat) error
	First() (*model.LiveBroadcastPushStat, error)
	Take() (*model.LiveBroadcastPushStat, error)
	Last() (*model.LiveBroadcastPushStat, error)
	Find() ([]*model.LiveBroadcastPushStat, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.LiveBroadcastPushStat, err error)
	FindInBatches(result *[]*model.LiveBroadcastPushStat, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.LiveBroadcastPushStat) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) ILiveBroadcastPushStatDo
	Assign(attrs ...field.AssignExpr) ILiveBroadcastPushStatDo
	Joins(fields ...field.RelationField) ILiveBroadcastPushStatDo
	Preload(fields ...field.RelationField) ILiveBroadcastPushStatDo
	FirstOrInit() (*model.LiveBroadcastPushStat, error)
	FirstOrCreate() (*model.LiveBroadcastPushStat, error)
	FindByPage(offset int, limit int) (result []*model.LiveBroadcastPushStat, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Rows() (*sql.Rows, error)
	Row() *sql.Row
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) ILiveBroadcastPushStatDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (l liveBroadcastPushStatDo) Debug() ILiveBroadcastPushStatDo {
	return l.withDO(l.DO.Debug())
}

func (l liveBroadcastPushStatDo) WithContext(ctx context.Context) ILiveBroadcastPushStatDo {
	return l.withDO(l.DO.WithContext(ctx))
}

func (l liveBroadcastPushStatDo) ReadDB() ILiveBroadcastPushStatDo {
	return l.Clauses(dbresolver.Read)
}

func (l liveBroadcastPushStatDo) WriteDB() ILiveBroadcastPushStatDo {
	return l.Clauses(dbresolver.Write)
}

func (l liveBroadcastPushStatDo) Session(config *gorm.Session) ILiveBroadcastPushStatDo {
	return l.withDO(l.DO.Session(config))
}

func (l liveBroadcastPushStatDo) Clauses(conds ...clause.Expression) ILiveBroadcastPushStatDo {
	return l.withDO(l.DO.Clauses(conds...))
}

func (l liveBroadcastPushStatDo) Returning(value interface{}, columns ...string) ILiveBroadcastPushStatDo {
	return l.withDO(l.DO.Returning(value, columns...))
}

func (l liveBroadcastPushStatDo) Not(conds ...gen.Condition) ILiveBroadcastPushStatDo {
	return l.withDO(l.DO.Not(conds...))
}

func (l liveBroadcastPushStatDo) Or(conds ...gen.Condition) ILiveBroadcastPushStatDo {
	return l.withDO(l.DO.Or(conds...))
}

func (l liveBroadcastPushStatDo) Select(conds ...field.Expr) ILiveBroadcastPushStatDo {
	return l.withDO(l.DO.Select(conds...))
}

func (l liveBroadcastPushStatDo) Where(conds ...gen.Condition) ILiveBroadcastPushStatDo {
	return l.withDO(l.DO.Where(conds...))
}

func (l liveBroadcastPushStatDo) Order(conds ...field.Expr) ILiveBroadcastPushStatDo {
	return l.withDO(l.DO.Order(conds...))
}

func (l liveBroadcastPushStatDo) Distinct(cols ...field.Expr) ILiveBroadcastPushStatDo {
	return l.withDO(l.DO.Distinct(cols...))
}

func (l liveBroadcastPushStatDo) Omit(cols ...field.Expr) ILiveBroadcastPushStatDo {
	return l.withDO(l.DO.Omit(cols...))
}

func (l liveBroadcastPushStatDo) Join(table schema.Tabler, on ...field.Expr) ILiveBroadcastPushStatDo {
	return l.withDO(l.DO.Join(table, on...))
}

func (l liveBroadcastPushStatDo) LeftJoin(table schema.Tabler, on ...field.Expr) ILiveBroadcastPushStatDo {
	return l.withDO(l.DO.LeftJoin(table, on...))
}

func (l liveBroadcastPushStatDo) RightJoin(table schema.Tabler, on ...field.Expr) ILiveBroadcastPushStatDo {
	return l.withDO(l.DO.RightJoin(table, on...))
}

func (l liveBroadcastPushStatDo) Group(cols ...field.Expr) ILiveBroadcastPushStatDo {
	return l.withDO(l.DO.Group(cols...))
}

func (l liveBroadcastPushStatDo) Having(conds ...gen.Condition) ILiveBroadcastPushStatDo {
	return l.withDO(l.DO.Having(conds...))
}

func (l liveBroadcastPushStatDo) Limit(limit int) ILiveBroadcastPushStatDo {
	return l.withDO(l.DO.Limit(limit))
}

func (l liveBroadcastPushStatDo) Offset(offset int) ILiveBroadcastPushStatDo {
	return l.withDO(l.DO.Offset(offset))
}

func (l liveBroadcastPushStatDo) Scopes(funcs ...func(gen.Dao) gen.Dao) ILiveBroadcastPushStatDo {
	return l.withDO(l.DO.Scopes(funcs...))
}

func (l liveBroadcastPushStatDo) Unscoped() ILiveBroadcastPushStatDo {
	return l.withDO(l.DO.Unscoped())
}

func (l liveBroadcastPushStatDo) Create(values ...*model.LiveBroadcastPushStat) error {
	if len(values) == 0 {
		return nil
	}
	return l.DO.Create(values)
}

func (l liveBroadcastPushStatDo) CreateInBatches(values []*model.LiveBroadcastPushStat, batchSize int) error {
	return l.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (l liveBroadcastPushStatDo) Save(values ...*model.LiveBroadcastPushStat) error {
	if len(values) == 0 {
		return nil
	}
	return l.DO.Save(values)
}

func (l liveBroadcastPushStatDo) First() (*model.LiveBroadcastPushStat, error) {
	if result, err := l.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.LiveBroadcastPushStat), nil
	}
}

func (l liveBroadcastPushStatDo) Take() (*model.LiveBroadcastPushStat, error) {
	if result, err := l.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.LiveBroadcastPushStat), nil
	}
}

func (l liveBroadcastPushStatDo) Last() (*model.LiveBroadcastPushStat, error) {
	if result, err := l.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.LiveBroadcastPushStat), nil
	}
}

func (l liveBroadcastPushStatDo) Find() ([]*model.LiveBroadcastPushStat, error) {
	result, err := l.DO.Find()
	return result.([]*model.LiveBroadcastPushStat), err
}

func (l liveBroadcastPushStatDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.LiveBroadcastPushStat, err error) {
	buf := make([]*model.LiveBroadcastPushStat, 0, batchSize)
	err = l.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (l liveBroadcastPushStatDo) FindInBatches(result *[]*model.LiveBroadcastPushStat, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return l.DO.FindInBatches(result, batchSize, fc)
}

func (l liveBroadcastPushStatDo) Attrs(attrs ...field.AssignExpr) ILiveBroadcastPushStatDo {
	return l.withDO(l.DO.Attrs(attrs...))
}

func (l liveBroadcastPushStatDo) Assign(attrs ...field.AssignExpr) ILiveBroadcastPushStatDo {
	return l.withDO(l.DO.Assign(attrs...))
}

func (l liveBroadcastPushStatDo) Joins(fields ...field.RelationField) ILiveBroadcastPushStatDo {
	for _, _f := range fields {
		l = *l.withDO(l.DO.Joins(_f))
	}
	return &l
}

func (l liveBroadcastPushStatDo) Preload(fields ...field.RelationField) ILiveBroadcastPushStatDo {
	for _, _f := range fields {
		l = *l.withDO(l.DO.Preload(_f))
	}
	return &l
}

func (l liveBroadcastPushStatDo) FirstOrInit() (*model.LiveBroadcastPushStat, error) {
	if result, err := l.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.LiveBroadcastPushStat), nil
	}
}

func (l liveBroadcastPushStatDo) FirstOrCreate() (*model.LiveBroadcastPushStat, error) {
	if result, err := l.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.LiveBroadcastPushStat), nil
	}
}

func (l liveBroadcastPushStatDo) FindByPage(offset int, limit int) (result []*model.LiveBroadcastPushStat, count int64, err error) {
	result, err = l.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = l.Offset(-1).Limit(-1).Count()
	return
}

func (l liveBroadcastPushStatDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = l.Count()
	if err != nil {
		return
	}

	err = l.Offset(offset).Limit(limit).Scan(result)
	return
}

func (l liveBroadcastPushStatDo) Scan(result interface{}) (err error) {
	return l.DO.Scan(result)
}

func (l liveBroadcastPushStatDo) Delete(models ...*model.LiveBroadcastPushStat) (result gen.ResultInfo, err error) {
	return l.DO.Delete(models)
}

func (l *liveBroadcastPushStatDo) withDO(do gen.Dao) *liveBroadcastPushStatDo {
	l.DO = *do.(*gen.DO)
	return l
}
