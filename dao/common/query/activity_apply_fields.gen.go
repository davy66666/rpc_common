// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package query

import (
	"context"
	"database/sql"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"github.com/davy66666/rpc_common/dao/model"
)

func newActivityApplyField(db *gorm.DB, opts ...gen.DOOption) activityApplyField {
	_activityApplyField := activityApplyField{}

	_activityApplyField.activityApplyFieldDo.UseDB(db, opts...)
	_activityApplyField.activityApplyFieldDo.UseModel(&model.ActivityApplyField{})

	tableName := _activityApplyField.activityApplyFieldDo.TableName()
	_activityApplyField.ALL = field.NewAsterisk(tableName)
	_activityApplyField.ID = field.NewInt64(tableName, "id")
	_activityApplyField.ActivityID = field.NewInt64(tableName, "activity_id")
	_activityApplyField.Title = field.NewString(tableName, "title")
	_activityApplyField.FieldName = field.NewString(tableName, "field_name")
	_activityApplyField.OptionValue = field.NewString(tableName, "option_value")
	_activityApplyField.Type = field.NewInt64(tableName, "type")
	_activityApplyField.Status = field.NewInt64(tableName, "status")
	_activityApplyField.Sort = field.NewInt64(tableName, "sort")
	_activityApplyField.Remark = field.NewString(tableName, "remark")
	_activityApplyField.CreatedAt = field.NewField(tableName, "created_at")
	_activityApplyField.UpdatedAt = field.NewField(tableName, "updated_at")

	_activityApplyField.fillFieldMap()

	return _activityApplyField
}

// activityApplyField 活动申请字段配置表
type activityApplyField struct {
	activityApplyFieldDo activityApplyFieldDo

	ALL         field.Asterisk
	ID          field.Int64
	ActivityID  field.Int64  // 活动id
	Title       field.String // 字段中文描述
	FieldName   field.String // 字段名称
	OptionValue field.String // 选项值
	Type        field.Int64  // 0:字符串 1:数字,2:下拉选择框
	Status      field.Int64  // 0:未启用, 1:启用
	Sort        field.Int64  // 排序, 值越小越靠前
	Remark      field.String // 备注
	CreatedAt   field.Field  // 创建时间
	UpdatedAt   field.Field  // 更新时间

	fieldMap map[string]field.Expr
}

func (a activityApplyField) Table(newTableName string) *activityApplyField {
	a.activityApplyFieldDo.UseTable(newTableName)
	return a.updateTableName(newTableName)
}

func (a activityApplyField) As(alias string) *activityApplyField {
	a.activityApplyFieldDo.DO = *(a.activityApplyFieldDo.As(alias).(*gen.DO))
	return a.updateTableName(alias)
}

func (a *activityApplyField) updateTableName(table string) *activityApplyField {
	a.ALL = field.NewAsterisk(table)
	a.ID = field.NewInt64(table, "id")
	a.ActivityID = field.NewInt64(table, "activity_id")
	a.Title = field.NewString(table, "title")
	a.FieldName = field.NewString(table, "field_name")
	a.OptionValue = field.NewString(table, "option_value")
	a.Type = field.NewInt64(table, "type")
	a.Status = field.NewInt64(table, "status")
	a.Sort = field.NewInt64(table, "sort")
	a.Remark = field.NewString(table, "remark")
	a.CreatedAt = field.NewField(table, "created_at")
	a.UpdatedAt = field.NewField(table, "updated_at")

	a.fillFieldMap()

	return a
}

func (a *activityApplyField) WithContext(ctx context.Context) IActivityApplyFieldDo {
	return a.activityApplyFieldDo.WithContext(ctx)
}

func (a activityApplyField) TableName() string { return a.activityApplyFieldDo.TableName() }

func (a activityApplyField) Alias() string { return a.activityApplyFieldDo.Alias() }

func (a activityApplyField) Columns(cols ...field.Expr) gen.Columns {
	return a.activityApplyFieldDo.Columns(cols...)
}

func (a *activityApplyField) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := a.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (a *activityApplyField) fillFieldMap() {
	a.fieldMap = make(map[string]field.Expr, 11)
	a.fieldMap["id"] = a.ID
	a.fieldMap["activity_id"] = a.ActivityID
	a.fieldMap["title"] = a.Title
	a.fieldMap["field_name"] = a.FieldName
	a.fieldMap["option_value"] = a.OptionValue
	a.fieldMap["type"] = a.Type
	a.fieldMap["status"] = a.Status
	a.fieldMap["sort"] = a.Sort
	a.fieldMap["remark"] = a.Remark
	a.fieldMap["created_at"] = a.CreatedAt
	a.fieldMap["updated_at"] = a.UpdatedAt
}

func (a activityApplyField) clone(db *gorm.DB) activityApplyField {
	a.activityApplyFieldDo.ReplaceConnPool(db.Statement.ConnPool)
	return a
}

func (a activityApplyField) replaceDB(db *gorm.DB) activityApplyField {
	a.activityApplyFieldDo.ReplaceDB(db)
	return a
}

type activityApplyFieldDo struct{ gen.DO }

type IActivityApplyFieldDo interface {
	gen.SubQuery
	Debug() IActivityApplyFieldDo
	WithContext(ctx context.Context) IActivityApplyFieldDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() IActivityApplyFieldDo
	WriteDB() IActivityApplyFieldDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) IActivityApplyFieldDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) IActivityApplyFieldDo
	Not(conds ...gen.Condition) IActivityApplyFieldDo
	Or(conds ...gen.Condition) IActivityApplyFieldDo
	Select(conds ...field.Expr) IActivityApplyFieldDo
	Where(conds ...gen.Condition) IActivityApplyFieldDo
	Order(conds ...field.Expr) IActivityApplyFieldDo
	Distinct(cols ...field.Expr) IActivityApplyFieldDo
	Omit(cols ...field.Expr) IActivityApplyFieldDo
	Join(table schema.Tabler, on ...field.Expr) IActivityApplyFieldDo
	LeftJoin(table schema.Tabler, on ...field.Expr) IActivityApplyFieldDo
	RightJoin(table schema.Tabler, on ...field.Expr) IActivityApplyFieldDo
	Group(cols ...field.Expr) IActivityApplyFieldDo
	Having(conds ...gen.Condition) IActivityApplyFieldDo
	Limit(limit int) IActivityApplyFieldDo
	Offset(offset int) IActivityApplyFieldDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) IActivityApplyFieldDo
	Unscoped() IActivityApplyFieldDo
	Create(values ...*model.ActivityApplyField) error
	CreateInBatches(values []*model.ActivityApplyField, batchSize int) error
	Save(values ...*model.ActivityApplyField) error
	First() (*model.ActivityApplyField, error)
	Take() (*model.ActivityApplyField, error)
	Last() (*model.ActivityApplyField, error)
	Find() ([]*model.ActivityApplyField, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.ActivityApplyField, err error)
	FindInBatches(result *[]*model.ActivityApplyField, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.ActivityApplyField) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) IActivityApplyFieldDo
	Assign(attrs ...field.AssignExpr) IActivityApplyFieldDo
	Joins(fields ...field.RelationField) IActivityApplyFieldDo
	Preload(fields ...field.RelationField) IActivityApplyFieldDo
	FirstOrInit() (*model.ActivityApplyField, error)
	FirstOrCreate() (*model.ActivityApplyField, error)
	FindByPage(offset int, limit int) (result []*model.ActivityApplyField, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Rows() (*sql.Rows, error)
	Row() *sql.Row
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) IActivityApplyFieldDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (a activityApplyFieldDo) Debug() IActivityApplyFieldDo {
	return a.withDO(a.DO.Debug())
}

func (a activityApplyFieldDo) WithContext(ctx context.Context) IActivityApplyFieldDo {
	return a.withDO(a.DO.WithContext(ctx))
}

func (a activityApplyFieldDo) ReadDB() IActivityApplyFieldDo {
	return a.Clauses(dbresolver.Read)
}

func (a activityApplyFieldDo) WriteDB() IActivityApplyFieldDo {
	return a.Clauses(dbresolver.Write)
}

func (a activityApplyFieldDo) Session(config *gorm.Session) IActivityApplyFieldDo {
	return a.withDO(a.DO.Session(config))
}

func (a activityApplyFieldDo) Clauses(conds ...clause.Expression) IActivityApplyFieldDo {
	return a.withDO(a.DO.Clauses(conds...))
}

func (a activityApplyFieldDo) Returning(value interface{}, columns ...string) IActivityApplyFieldDo {
	return a.withDO(a.DO.Returning(value, columns...))
}

func (a activityApplyFieldDo) Not(conds ...gen.Condition) IActivityApplyFieldDo {
	return a.withDO(a.DO.Not(conds...))
}

func (a activityApplyFieldDo) Or(conds ...gen.Condition) IActivityApplyFieldDo {
	return a.withDO(a.DO.Or(conds...))
}

func (a activityApplyFieldDo) Select(conds ...field.Expr) IActivityApplyFieldDo {
	return a.withDO(a.DO.Select(conds...))
}

func (a activityApplyFieldDo) Where(conds ...gen.Condition) IActivityApplyFieldDo {
	return a.withDO(a.DO.Where(conds...))
}

func (a activityApplyFieldDo) Order(conds ...field.Expr) IActivityApplyFieldDo {
	return a.withDO(a.DO.Order(conds...))
}

func (a activityApplyFieldDo) Distinct(cols ...field.Expr) IActivityApplyFieldDo {
	return a.withDO(a.DO.Distinct(cols...))
}

func (a activityApplyFieldDo) Omit(cols ...field.Expr) IActivityApplyFieldDo {
	return a.withDO(a.DO.Omit(cols...))
}

func (a activityApplyFieldDo) Join(table schema.Tabler, on ...field.Expr) IActivityApplyFieldDo {
	return a.withDO(a.DO.Join(table, on...))
}

func (a activityApplyFieldDo) LeftJoin(table schema.Tabler, on ...field.Expr) IActivityApplyFieldDo {
	return a.withDO(a.DO.LeftJoin(table, on...))
}

func (a activityApplyFieldDo) RightJoin(table schema.Tabler, on ...field.Expr) IActivityApplyFieldDo {
	return a.withDO(a.DO.RightJoin(table, on...))
}

func (a activityApplyFieldDo) Group(cols ...field.Expr) IActivityApplyFieldDo {
	return a.withDO(a.DO.Group(cols...))
}

func (a activityApplyFieldDo) Having(conds ...gen.Condition) IActivityApplyFieldDo {
	return a.withDO(a.DO.Having(conds...))
}

func (a activityApplyFieldDo) Limit(limit int) IActivityApplyFieldDo {
	return a.withDO(a.DO.Limit(limit))
}

func (a activityApplyFieldDo) Offset(offset int) IActivityApplyFieldDo {
	return a.withDO(a.DO.Offset(offset))
}

func (a activityApplyFieldDo) Scopes(funcs ...func(gen.Dao) gen.Dao) IActivityApplyFieldDo {
	return a.withDO(a.DO.Scopes(funcs...))
}

func (a activityApplyFieldDo) Unscoped() IActivityApplyFieldDo {
	return a.withDO(a.DO.Unscoped())
}

func (a activityApplyFieldDo) Create(values ...*model.ActivityApplyField) error {
	if len(values) == 0 {
		return nil
	}
	return a.DO.Create(values)
}

func (a activityApplyFieldDo) CreateInBatches(values []*model.ActivityApplyField, batchSize int) error {
	return a.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (a activityApplyFieldDo) Save(values ...*model.ActivityApplyField) error {
	if len(values) == 0 {
		return nil
	}
	return a.DO.Save(values)
}

func (a activityApplyFieldDo) First() (*model.ActivityApplyField, error) {
	if result, err := a.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.ActivityApplyField), nil
	}
}

func (a activityApplyFieldDo) Take() (*model.ActivityApplyField, error) {
	if result, err := a.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.ActivityApplyField), nil
	}
}

func (a activityApplyFieldDo) Last() (*model.ActivityApplyField, error) {
	if result, err := a.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.ActivityApplyField), nil
	}
}

func (a activityApplyFieldDo) Find() ([]*model.ActivityApplyField, error) {
	result, err := a.DO.Find()
	return result.([]*model.ActivityApplyField), err
}

func (a activityApplyFieldDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.ActivityApplyField, err error) {
	buf := make([]*model.ActivityApplyField, 0, batchSize)
	err = a.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (a activityApplyFieldDo) FindInBatches(result *[]*model.ActivityApplyField, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return a.DO.FindInBatches(result, batchSize, fc)
}

func (a activityApplyFieldDo) Attrs(attrs ...field.AssignExpr) IActivityApplyFieldDo {
	return a.withDO(a.DO.Attrs(attrs...))
}

func (a activityApplyFieldDo) Assign(attrs ...field.AssignExpr) IActivityApplyFieldDo {
	return a.withDO(a.DO.Assign(attrs...))
}

func (a activityApplyFieldDo) Joins(fields ...field.RelationField) IActivityApplyFieldDo {
	for _, _f := range fields {
		a = *a.withDO(a.DO.Joins(_f))
	}
	return &a
}

func (a activityApplyFieldDo) Preload(fields ...field.RelationField) IActivityApplyFieldDo {
	for _, _f := range fields {
		a = *a.withDO(a.DO.Preload(_f))
	}
	return &a
}

func (a activityApplyFieldDo) FirstOrInit() (*model.ActivityApplyField, error) {
	if result, err := a.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.ActivityApplyField), nil
	}
}

func (a activityApplyFieldDo) FirstOrCreate() (*model.ActivityApplyField, error) {
	if result, err := a.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.ActivityApplyField), nil
	}
}

func (a activityApplyFieldDo) FindByPage(offset int, limit int) (result []*model.ActivityApplyField, count int64, err error) {
	result, err = a.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = a.Offset(-1).Limit(-1).Count()
	return
}

func (a activityApplyFieldDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = a.Count()
	if err != nil {
		return
	}

	err = a.Offset(offset).Limit(limit).Scan(result)
	return
}

func (a activityApplyFieldDo) Scan(result interface{}) (err error) {
	return a.DO.Scan(result)
}

func (a activityApplyFieldDo) Delete(models ...*model.ActivityApplyField) (result gen.ResultInfo, err error) {
	return a.DO.Delete(models)
}

func (a *activityApplyFieldDo) withDO(do gen.Dao) *activityApplyFieldDo {
	a.DO = *do.(*gen.DO)
	return a
}
