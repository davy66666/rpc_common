// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package query

import (
	"context"
	"database/sql"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"github.com/davy66666/rpc_common/dao/model"
)

func newDataIP(db *gorm.DB, opts ...gen.DOOption) dataIP {
	_dataIP := dataIP{}

	_dataIP.dataIPDo.UseDB(db, opts...)
	_dataIP.dataIPDo.UseModel(&model.DataIP{})

	tableName := _dataIP.dataIPDo.TableName()
	_dataIP.ALL = field.NewAsterisk(tableName)
	_dataIP.ID = field.NewInt64(tableName, "id")
	_dataIP.IPStart = field.NewString(tableName, "ip_start")
	_dataIP.IPEnd = field.NewString(tableName, "ip_end")
	_dataIP.NumStart = field.NewInt64(tableName, "num_start")
	_dataIP.NumEnd = field.NewInt64(tableName, "num_end")
	_dataIP.Num = field.NewInt64(tableName, "num")
	_dataIP.Land = field.NewString(tableName, "land")
	_dataIP.Region = field.NewString(tableName, "region")
	_dataIP.City = field.NewString(tableName, "city")
	_dataIP.Area = field.NewString(tableName, "area")
	_dataIP.Country = field.NewString(tableName, "country")
	_dataIP.CountryEnglish = field.NewString(tableName, "country_english")
	_dataIP.Isp = field.NewString(tableName, "isp")
	_dataIP.CountryID = field.NewString(tableName, "country_id")
	_dataIP.InternationalCode = field.NewString(tableName, "international_code")
	_dataIP.RegionID = field.NewString(tableName, "region_id")
	_dataIP.CityID = field.NewString(tableName, "city_id")
	_dataIP.AreaID = field.NewString(tableName, "area_id")
	_dataIP.Lat = field.NewString(tableName, "lat")
	_dataIP.Lng = field.NewString(tableName, "lng")

	_dataIP.fillFieldMap()

	return _dataIP
}

type dataIP struct {
	dataIPDo dataIPDo

	ALL               field.Asterisk
	ID                field.Int64
	IPStart           field.String // 起始IP
	IPEnd             field.String // 结束IP
	NumStart          field.Int64  // 数字起始IP
	NumEnd            field.Int64  // 数字结束IP
	Num               field.Int64  // IP数量
	Land              field.String // 大州
	Region            field.String // 省份
	City              field.String // 城市
	Area              field.String // 区县
	Country           field.String // 国家
	CountryEnglish    field.String // 国家英文
	Isp               field.String // 运营商
	CountryID         field.String // 国家代码
	InternationalCode field.String // 国际区号
	RegionID          field.String // 一级行政代码
	CityID            field.String // 二级行政代码
	AreaID            field.String // 三级行政代码
	Lat               field.String // 经度
	Lng               field.String // 纬度

	fieldMap map[string]field.Expr
}

func (d dataIP) Table(newTableName string) *dataIP {
	d.dataIPDo.UseTable(newTableName)
	return d.updateTableName(newTableName)
}

func (d dataIP) As(alias string) *dataIP {
	d.dataIPDo.DO = *(d.dataIPDo.As(alias).(*gen.DO))
	return d.updateTableName(alias)
}

func (d *dataIP) updateTableName(table string) *dataIP {
	d.ALL = field.NewAsterisk(table)
	d.ID = field.NewInt64(table, "id")
	d.IPStart = field.NewString(table, "ip_start")
	d.IPEnd = field.NewString(table, "ip_end")
	d.NumStart = field.NewInt64(table, "num_start")
	d.NumEnd = field.NewInt64(table, "num_end")
	d.Num = field.NewInt64(table, "num")
	d.Land = field.NewString(table, "land")
	d.Region = field.NewString(table, "region")
	d.City = field.NewString(table, "city")
	d.Area = field.NewString(table, "area")
	d.Country = field.NewString(table, "country")
	d.CountryEnglish = field.NewString(table, "country_english")
	d.Isp = field.NewString(table, "isp")
	d.CountryID = field.NewString(table, "country_id")
	d.InternationalCode = field.NewString(table, "international_code")
	d.RegionID = field.NewString(table, "region_id")
	d.CityID = field.NewString(table, "city_id")
	d.AreaID = field.NewString(table, "area_id")
	d.Lat = field.NewString(table, "lat")
	d.Lng = field.NewString(table, "lng")

	d.fillFieldMap()

	return d
}

func (d *dataIP) WithContext(ctx context.Context) IDataIPDo { return d.dataIPDo.WithContext(ctx) }

func (d dataIP) TableName() string { return d.dataIPDo.TableName() }

func (d dataIP) Alias() string { return d.dataIPDo.Alias() }

func (d dataIP) Columns(cols ...field.Expr) gen.Columns { return d.dataIPDo.Columns(cols...) }

func (d *dataIP) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := d.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (d *dataIP) fillFieldMap() {
	d.fieldMap = make(map[string]field.Expr, 20)
	d.fieldMap["id"] = d.ID
	d.fieldMap["ip_start"] = d.IPStart
	d.fieldMap["ip_end"] = d.IPEnd
	d.fieldMap["num_start"] = d.NumStart
	d.fieldMap["num_end"] = d.NumEnd
	d.fieldMap["num"] = d.Num
	d.fieldMap["land"] = d.Land
	d.fieldMap["region"] = d.Region
	d.fieldMap["city"] = d.City
	d.fieldMap["area"] = d.Area
	d.fieldMap["country"] = d.Country
	d.fieldMap["country_english"] = d.CountryEnglish
	d.fieldMap["isp"] = d.Isp
	d.fieldMap["country_id"] = d.CountryID
	d.fieldMap["international_code"] = d.InternationalCode
	d.fieldMap["region_id"] = d.RegionID
	d.fieldMap["city_id"] = d.CityID
	d.fieldMap["area_id"] = d.AreaID
	d.fieldMap["lat"] = d.Lat
	d.fieldMap["lng"] = d.Lng
}

func (d dataIP) clone(db *gorm.DB) dataIP {
	d.dataIPDo.ReplaceConnPool(db.Statement.ConnPool)
	return d
}

func (d dataIP) replaceDB(db *gorm.DB) dataIP {
	d.dataIPDo.ReplaceDB(db)
	return d
}

type dataIPDo struct{ gen.DO }

type IDataIPDo interface {
	gen.SubQuery
	Debug() IDataIPDo
	WithContext(ctx context.Context) IDataIPDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() IDataIPDo
	WriteDB() IDataIPDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) IDataIPDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) IDataIPDo
	Not(conds ...gen.Condition) IDataIPDo
	Or(conds ...gen.Condition) IDataIPDo
	Select(conds ...field.Expr) IDataIPDo
	Where(conds ...gen.Condition) IDataIPDo
	Order(conds ...field.Expr) IDataIPDo
	Distinct(cols ...field.Expr) IDataIPDo
	Omit(cols ...field.Expr) IDataIPDo
	Join(table schema.Tabler, on ...field.Expr) IDataIPDo
	LeftJoin(table schema.Tabler, on ...field.Expr) IDataIPDo
	RightJoin(table schema.Tabler, on ...field.Expr) IDataIPDo
	Group(cols ...field.Expr) IDataIPDo
	Having(conds ...gen.Condition) IDataIPDo
	Limit(limit int) IDataIPDo
	Offset(offset int) IDataIPDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) IDataIPDo
	Unscoped() IDataIPDo
	Create(values ...*model.DataIP) error
	CreateInBatches(values []*model.DataIP, batchSize int) error
	Save(values ...*model.DataIP) error
	First() (*model.DataIP, error)
	Take() (*model.DataIP, error)
	Last() (*model.DataIP, error)
	Find() ([]*model.DataIP, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.DataIP, err error)
	FindInBatches(result *[]*model.DataIP, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.DataIP) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) IDataIPDo
	Assign(attrs ...field.AssignExpr) IDataIPDo
	Joins(fields ...field.RelationField) IDataIPDo
	Preload(fields ...field.RelationField) IDataIPDo
	FirstOrInit() (*model.DataIP, error)
	FirstOrCreate() (*model.DataIP, error)
	FindByPage(offset int, limit int) (result []*model.DataIP, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Rows() (*sql.Rows, error)
	Row() *sql.Row
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) IDataIPDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (d dataIPDo) Debug() IDataIPDo {
	return d.withDO(d.DO.Debug())
}

func (d dataIPDo) WithContext(ctx context.Context) IDataIPDo {
	return d.withDO(d.DO.WithContext(ctx))
}

func (d dataIPDo) ReadDB() IDataIPDo {
	return d.Clauses(dbresolver.Read)
}

func (d dataIPDo) WriteDB() IDataIPDo {
	return d.Clauses(dbresolver.Write)
}

func (d dataIPDo) Session(config *gorm.Session) IDataIPDo {
	return d.withDO(d.DO.Session(config))
}

func (d dataIPDo) Clauses(conds ...clause.Expression) IDataIPDo {
	return d.withDO(d.DO.Clauses(conds...))
}

func (d dataIPDo) Returning(value interface{}, columns ...string) IDataIPDo {
	return d.withDO(d.DO.Returning(value, columns...))
}

func (d dataIPDo) Not(conds ...gen.Condition) IDataIPDo {
	return d.withDO(d.DO.Not(conds...))
}

func (d dataIPDo) Or(conds ...gen.Condition) IDataIPDo {
	return d.withDO(d.DO.Or(conds...))
}

func (d dataIPDo) Select(conds ...field.Expr) IDataIPDo {
	return d.withDO(d.DO.Select(conds...))
}

func (d dataIPDo) Where(conds ...gen.Condition) IDataIPDo {
	return d.withDO(d.DO.Where(conds...))
}

func (d dataIPDo) Order(conds ...field.Expr) IDataIPDo {
	return d.withDO(d.DO.Order(conds...))
}

func (d dataIPDo) Distinct(cols ...field.Expr) IDataIPDo {
	return d.withDO(d.DO.Distinct(cols...))
}

func (d dataIPDo) Omit(cols ...field.Expr) IDataIPDo {
	return d.withDO(d.DO.Omit(cols...))
}

func (d dataIPDo) Join(table schema.Tabler, on ...field.Expr) IDataIPDo {
	return d.withDO(d.DO.Join(table, on...))
}

func (d dataIPDo) LeftJoin(table schema.Tabler, on ...field.Expr) IDataIPDo {
	return d.withDO(d.DO.LeftJoin(table, on...))
}

func (d dataIPDo) RightJoin(table schema.Tabler, on ...field.Expr) IDataIPDo {
	return d.withDO(d.DO.RightJoin(table, on...))
}

func (d dataIPDo) Group(cols ...field.Expr) IDataIPDo {
	return d.withDO(d.DO.Group(cols...))
}

func (d dataIPDo) Having(conds ...gen.Condition) IDataIPDo {
	return d.withDO(d.DO.Having(conds...))
}

func (d dataIPDo) Limit(limit int) IDataIPDo {
	return d.withDO(d.DO.Limit(limit))
}

func (d dataIPDo) Offset(offset int) IDataIPDo {
	return d.withDO(d.DO.Offset(offset))
}

func (d dataIPDo) Scopes(funcs ...func(gen.Dao) gen.Dao) IDataIPDo {
	return d.withDO(d.DO.Scopes(funcs...))
}

func (d dataIPDo) Unscoped() IDataIPDo {
	return d.withDO(d.DO.Unscoped())
}

func (d dataIPDo) Create(values ...*model.DataIP) error {
	if len(values) == 0 {
		return nil
	}
	return d.DO.Create(values)
}

func (d dataIPDo) CreateInBatches(values []*model.DataIP, batchSize int) error {
	return d.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (d dataIPDo) Save(values ...*model.DataIP) error {
	if len(values) == 0 {
		return nil
	}
	return d.DO.Save(values)
}

func (d dataIPDo) First() (*model.DataIP, error) {
	if result, err := d.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.DataIP), nil
	}
}

func (d dataIPDo) Take() (*model.DataIP, error) {
	if result, err := d.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.DataIP), nil
	}
}

func (d dataIPDo) Last() (*model.DataIP, error) {
	if result, err := d.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.DataIP), nil
	}
}

func (d dataIPDo) Find() ([]*model.DataIP, error) {
	result, err := d.DO.Find()
	return result.([]*model.DataIP), err
}

func (d dataIPDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.DataIP, err error) {
	buf := make([]*model.DataIP, 0, batchSize)
	err = d.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (d dataIPDo) FindInBatches(result *[]*model.DataIP, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return d.DO.FindInBatches(result, batchSize, fc)
}

func (d dataIPDo) Attrs(attrs ...field.AssignExpr) IDataIPDo {
	return d.withDO(d.DO.Attrs(attrs...))
}

func (d dataIPDo) Assign(attrs ...field.AssignExpr) IDataIPDo {
	return d.withDO(d.DO.Assign(attrs...))
}

func (d dataIPDo) Joins(fields ...field.RelationField) IDataIPDo {
	for _, _f := range fields {
		d = *d.withDO(d.DO.Joins(_f))
	}
	return &d
}

func (d dataIPDo) Preload(fields ...field.RelationField) IDataIPDo {
	for _, _f := range fields {
		d = *d.withDO(d.DO.Preload(_f))
	}
	return &d
}

func (d dataIPDo) FirstOrInit() (*model.DataIP, error) {
	if result, err := d.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.DataIP), nil
	}
}

func (d dataIPDo) FirstOrCreate() (*model.DataIP, error) {
	if result, err := d.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.DataIP), nil
	}
}

func (d dataIPDo) FindByPage(offset int, limit int) (result []*model.DataIP, count int64, err error) {
	result, err = d.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = d.Offset(-1).Limit(-1).Count()
	return
}

func (d dataIPDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = d.Count()
	if err != nil {
		return
	}

	err = d.Offset(offset).Limit(limit).Scan(result)
	return
}

func (d dataIPDo) Scan(result interface{}) (err error) {
	return d.DO.Scan(result)
}

func (d dataIPDo) Delete(models ...*model.DataIP) (result gen.ResultInfo, err error) {
	return d.DO.Delete(models)
}

func (d *dataIPDo) withDO(do gen.Dao) *dataIPDo {
	d.DO = *do.(*gen.DO)
	return d
}
