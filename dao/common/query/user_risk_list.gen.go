// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package query

import (
	"context"
	"database/sql"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"github.com/davy66666/rpc_common/dao/model"
)

func newUserRiskList(db *gorm.DB, opts ...gen.DOOption) userRiskList {
	_userRiskList := userRiskList{}

	_userRiskList.userRiskListDo.UseDB(db, opts...)
	_userRiskList.userRiskListDo.UseModel(&model.UserRiskList{})

	tableName := _userRiskList.userRiskListDo.TableName()
	_userRiskList.ALL = field.NewAsterisk(tableName)
	_userRiskList.ID = field.NewInt64(tableName, "id")
	_userRiskList.UserID = field.NewInt64(tableName, "user_id")
	_userRiskList.Username = field.NewString(tableName, "username")
	_userRiskList.RealName = field.NewString(tableName, "real_name")
	_userRiskList.RegisterTime = field.NewInt64(tableName, "register_time")
	_userRiskList.IPAddress = field.NewString(tableName, "ip_address")
	_userRiskList.WithdrawalAccount = field.NewString(tableName, "withdrawal_account")
	_userRiskList.Phone = field.NewString(tableName, "phone")
	_userRiskList.AssociationAccount = field.NewString(tableName, "association_account")
	_userRiskList.SystemWarning = field.NewInt64(tableName, "system_warning")
	_userRiskList.AdminID = field.NewInt64(tableName, "admin_id")
	_userRiskList.AdminName = field.NewString(tableName, "admin_name")
	_userRiskList.Remark = field.NewString(tableName, "remark")
	_userRiskList.CreatedAt = field.NewField(tableName, "created_at")
	_userRiskList.UpdatedAt = field.NewField(tableName, "updated_at")

	_userRiskList.fillFieldMap()

	return _userRiskList
}

// userRiskList 风险名单库
type userRiskList struct {
	userRiskListDo userRiskListDo

	ALL                field.Asterisk
	ID                 field.Int64
	UserID             field.Int64  // 用户uid
	Username           field.String // 用户账号
	RealName           field.String // 用户真实姓名
	RegisterTime       field.Int64  // 注册时间
	IPAddress          field.String // ip地址
	WithdrawalAccount  field.String // 取款账户
	Phone              field.String // 手机号
	AssociationAccount field.String // 关联账号
	SystemWarning      field.Int64  // 系统警告
	AdminID            field.Int64  // 操作人id
	AdminName          field.String // 操作人
	Remark             field.String // 备注
	CreatedAt          field.Field
	UpdatedAt          field.Field

	fieldMap map[string]field.Expr
}

func (u userRiskList) Table(newTableName string) *userRiskList {
	u.userRiskListDo.UseTable(newTableName)
	return u.updateTableName(newTableName)
}

func (u userRiskList) As(alias string) *userRiskList {
	u.userRiskListDo.DO = *(u.userRiskListDo.As(alias).(*gen.DO))
	return u.updateTableName(alias)
}

func (u *userRiskList) updateTableName(table string) *userRiskList {
	u.ALL = field.NewAsterisk(table)
	u.ID = field.NewInt64(table, "id")
	u.UserID = field.NewInt64(table, "user_id")
	u.Username = field.NewString(table, "username")
	u.RealName = field.NewString(table, "real_name")
	u.RegisterTime = field.NewInt64(table, "register_time")
	u.IPAddress = field.NewString(table, "ip_address")
	u.WithdrawalAccount = field.NewString(table, "withdrawal_account")
	u.Phone = field.NewString(table, "phone")
	u.AssociationAccount = field.NewString(table, "association_account")
	u.SystemWarning = field.NewInt64(table, "system_warning")
	u.AdminID = field.NewInt64(table, "admin_id")
	u.AdminName = field.NewString(table, "admin_name")
	u.Remark = field.NewString(table, "remark")
	u.CreatedAt = field.NewField(table, "created_at")
	u.UpdatedAt = field.NewField(table, "updated_at")

	u.fillFieldMap()

	return u
}

func (u *userRiskList) WithContext(ctx context.Context) IUserRiskListDo {
	return u.userRiskListDo.WithContext(ctx)
}

func (u userRiskList) TableName() string { return u.userRiskListDo.TableName() }

func (u userRiskList) Alias() string { return u.userRiskListDo.Alias() }

func (u userRiskList) Columns(cols ...field.Expr) gen.Columns {
	return u.userRiskListDo.Columns(cols...)
}

func (u *userRiskList) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := u.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (u *userRiskList) fillFieldMap() {
	u.fieldMap = make(map[string]field.Expr, 15)
	u.fieldMap["id"] = u.ID
	u.fieldMap["user_id"] = u.UserID
	u.fieldMap["username"] = u.Username
	u.fieldMap["real_name"] = u.RealName
	u.fieldMap["register_time"] = u.RegisterTime
	u.fieldMap["ip_address"] = u.IPAddress
	u.fieldMap["withdrawal_account"] = u.WithdrawalAccount
	u.fieldMap["phone"] = u.Phone
	u.fieldMap["association_account"] = u.AssociationAccount
	u.fieldMap["system_warning"] = u.SystemWarning
	u.fieldMap["admin_id"] = u.AdminID
	u.fieldMap["admin_name"] = u.AdminName
	u.fieldMap["remark"] = u.Remark
	u.fieldMap["created_at"] = u.CreatedAt
	u.fieldMap["updated_at"] = u.UpdatedAt
}

func (u userRiskList) clone(db *gorm.DB) userRiskList {
	u.userRiskListDo.ReplaceConnPool(db.Statement.ConnPool)
	return u
}

func (u userRiskList) replaceDB(db *gorm.DB) userRiskList {
	u.userRiskListDo.ReplaceDB(db)
	return u
}

type userRiskListDo struct{ gen.DO }

type IUserRiskListDo interface {
	gen.SubQuery
	Debug() IUserRiskListDo
	WithContext(ctx context.Context) IUserRiskListDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() IUserRiskListDo
	WriteDB() IUserRiskListDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) IUserRiskListDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) IUserRiskListDo
	Not(conds ...gen.Condition) IUserRiskListDo
	Or(conds ...gen.Condition) IUserRiskListDo
	Select(conds ...field.Expr) IUserRiskListDo
	Where(conds ...gen.Condition) IUserRiskListDo
	Order(conds ...field.Expr) IUserRiskListDo
	Distinct(cols ...field.Expr) IUserRiskListDo
	Omit(cols ...field.Expr) IUserRiskListDo
	Join(table schema.Tabler, on ...field.Expr) IUserRiskListDo
	LeftJoin(table schema.Tabler, on ...field.Expr) IUserRiskListDo
	RightJoin(table schema.Tabler, on ...field.Expr) IUserRiskListDo
	Group(cols ...field.Expr) IUserRiskListDo
	Having(conds ...gen.Condition) IUserRiskListDo
	Limit(limit int) IUserRiskListDo
	Offset(offset int) IUserRiskListDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) IUserRiskListDo
	Unscoped() IUserRiskListDo
	Create(values ...*model.UserRiskList) error
	CreateInBatches(values []*model.UserRiskList, batchSize int) error
	Save(values ...*model.UserRiskList) error
	First() (*model.UserRiskList, error)
	Take() (*model.UserRiskList, error)
	Last() (*model.UserRiskList, error)
	Find() ([]*model.UserRiskList, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.UserRiskList, err error)
	FindInBatches(result *[]*model.UserRiskList, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.UserRiskList) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) IUserRiskListDo
	Assign(attrs ...field.AssignExpr) IUserRiskListDo
	Joins(fields ...field.RelationField) IUserRiskListDo
	Preload(fields ...field.RelationField) IUserRiskListDo
	FirstOrInit() (*model.UserRiskList, error)
	FirstOrCreate() (*model.UserRiskList, error)
	FindByPage(offset int, limit int) (result []*model.UserRiskList, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Rows() (*sql.Rows, error)
	Row() *sql.Row
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) IUserRiskListDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (u userRiskListDo) Debug() IUserRiskListDo {
	return u.withDO(u.DO.Debug())
}

func (u userRiskListDo) WithContext(ctx context.Context) IUserRiskListDo {
	return u.withDO(u.DO.WithContext(ctx))
}

func (u userRiskListDo) ReadDB() IUserRiskListDo {
	return u.Clauses(dbresolver.Read)
}

func (u userRiskListDo) WriteDB() IUserRiskListDo {
	return u.Clauses(dbresolver.Write)
}

func (u userRiskListDo) Session(config *gorm.Session) IUserRiskListDo {
	return u.withDO(u.DO.Session(config))
}

func (u userRiskListDo) Clauses(conds ...clause.Expression) IUserRiskListDo {
	return u.withDO(u.DO.Clauses(conds...))
}

func (u userRiskListDo) Returning(value interface{}, columns ...string) IUserRiskListDo {
	return u.withDO(u.DO.Returning(value, columns...))
}

func (u userRiskListDo) Not(conds ...gen.Condition) IUserRiskListDo {
	return u.withDO(u.DO.Not(conds...))
}

func (u userRiskListDo) Or(conds ...gen.Condition) IUserRiskListDo {
	return u.withDO(u.DO.Or(conds...))
}

func (u userRiskListDo) Select(conds ...field.Expr) IUserRiskListDo {
	return u.withDO(u.DO.Select(conds...))
}

func (u userRiskListDo) Where(conds ...gen.Condition) IUserRiskListDo {
	return u.withDO(u.DO.Where(conds...))
}

func (u userRiskListDo) Order(conds ...field.Expr) IUserRiskListDo {
	return u.withDO(u.DO.Order(conds...))
}

func (u userRiskListDo) Distinct(cols ...field.Expr) IUserRiskListDo {
	return u.withDO(u.DO.Distinct(cols...))
}

func (u userRiskListDo) Omit(cols ...field.Expr) IUserRiskListDo {
	return u.withDO(u.DO.Omit(cols...))
}

func (u userRiskListDo) Join(table schema.Tabler, on ...field.Expr) IUserRiskListDo {
	return u.withDO(u.DO.Join(table, on...))
}

func (u userRiskListDo) LeftJoin(table schema.Tabler, on ...field.Expr) IUserRiskListDo {
	return u.withDO(u.DO.LeftJoin(table, on...))
}

func (u userRiskListDo) RightJoin(table schema.Tabler, on ...field.Expr) IUserRiskListDo {
	return u.withDO(u.DO.RightJoin(table, on...))
}

func (u userRiskListDo) Group(cols ...field.Expr) IUserRiskListDo {
	return u.withDO(u.DO.Group(cols...))
}

func (u userRiskListDo) Having(conds ...gen.Condition) IUserRiskListDo {
	return u.withDO(u.DO.Having(conds...))
}

func (u userRiskListDo) Limit(limit int) IUserRiskListDo {
	return u.withDO(u.DO.Limit(limit))
}

func (u userRiskListDo) Offset(offset int) IUserRiskListDo {
	return u.withDO(u.DO.Offset(offset))
}

func (u userRiskListDo) Scopes(funcs ...func(gen.Dao) gen.Dao) IUserRiskListDo {
	return u.withDO(u.DO.Scopes(funcs...))
}

func (u userRiskListDo) Unscoped() IUserRiskListDo {
	return u.withDO(u.DO.Unscoped())
}

func (u userRiskListDo) Create(values ...*model.UserRiskList) error {
	if len(values) == 0 {
		return nil
	}
	return u.DO.Create(values)
}

func (u userRiskListDo) CreateInBatches(values []*model.UserRiskList, batchSize int) error {
	return u.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (u userRiskListDo) Save(values ...*model.UserRiskList) error {
	if len(values) == 0 {
		return nil
	}
	return u.DO.Save(values)
}

func (u userRiskListDo) First() (*model.UserRiskList, error) {
	if result, err := u.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.UserRiskList), nil
	}
}

func (u userRiskListDo) Take() (*model.UserRiskList, error) {
	if result, err := u.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.UserRiskList), nil
	}
}

func (u userRiskListDo) Last() (*model.UserRiskList, error) {
	if result, err := u.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.UserRiskList), nil
	}
}

func (u userRiskListDo) Find() ([]*model.UserRiskList, error) {
	result, err := u.DO.Find()
	return result.([]*model.UserRiskList), err
}

func (u userRiskListDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.UserRiskList, err error) {
	buf := make([]*model.UserRiskList, 0, batchSize)
	err = u.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (u userRiskListDo) FindInBatches(result *[]*model.UserRiskList, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return u.DO.FindInBatches(result, batchSize, fc)
}

func (u userRiskListDo) Attrs(attrs ...field.AssignExpr) IUserRiskListDo {
	return u.withDO(u.DO.Attrs(attrs...))
}

func (u userRiskListDo) Assign(attrs ...field.AssignExpr) IUserRiskListDo {
	return u.withDO(u.DO.Assign(attrs...))
}

func (u userRiskListDo) Joins(fields ...field.RelationField) IUserRiskListDo {
	for _, _f := range fields {
		u = *u.withDO(u.DO.Joins(_f))
	}
	return &u
}

func (u userRiskListDo) Preload(fields ...field.RelationField) IUserRiskListDo {
	for _, _f := range fields {
		u = *u.withDO(u.DO.Preload(_f))
	}
	return &u
}

func (u userRiskListDo) FirstOrInit() (*model.UserRiskList, error) {
	if result, err := u.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.UserRiskList), nil
	}
}

func (u userRiskListDo) FirstOrCreate() (*model.UserRiskList, error) {
	if result, err := u.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.UserRiskList), nil
	}
}

func (u userRiskListDo) FindByPage(offset int, limit int) (result []*model.UserRiskList, count int64, err error) {
	result, err = u.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = u.Offset(-1).Limit(-1).Count()
	return
}

func (u userRiskListDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = u.Count()
	if err != nil {
		return
	}

	err = u.Offset(offset).Limit(limit).Scan(result)
	return
}

func (u userRiskListDo) Scan(result interface{}) (err error) {
	return u.DO.Scan(result)
}

func (u userRiskListDo) Delete(models ...*model.UserRiskList) (result gen.ResultInfo, err error) {
	return u.DO.Delete(models)
}

func (u *userRiskListDo) withDO(do gen.Dao) *userRiskListDo {
	u.DO = *do.(*gen.DO)
	return u
}
