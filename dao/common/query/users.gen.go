// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package query

import (
	"context"
	"database/sql"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"github.com/davy66666/rpc_common/dao/model"
)

func newUser(db *gorm.DB, opts ...gen.DOOption) user {
	_user := user{}

	_user.userDo.UseDB(db, opts...)
	_user.userDo.UseModel(&model.User{})

	tableName := _user.userDo.TableName()
	_user.ALL = field.NewAsterisk(tableName)
	_user.ID = field.NewInt64(tableName, "id")
	_user.Username = field.NewString(tableName, "username")
	_user.Password = field.NewString(tableName, "password")
	_user.APIToken = field.NewString(tableName, "api_token")
	_user.PayPassword = field.NewString(tableName, "pay_password")
	_user.PaySecret = field.NewString(tableName, "pay_secret")
	_user.ParentID = field.NewInt64(tableName, "parent_id")
	_user.ForefatherIds = field.NewString(tableName, "forefather_ids")
	_user.ParentName = field.NewString(tableName, "parent_name")
	_user.SignScore = field.NewFloat64(tableName, "sign_score")
	_user.IsOpen = field.NewInt64(tableName, "is_open")
	_user.IsAgent = field.NewInt64(tableName, "is_agent")
	_user.IsTester = field.NewInt64(tableName, "is_tester")
	_user.UserLevel = field.NewString(tableName, "user_level")
	_user.PayLevel = field.NewString(tableName, "pay_level")
	_user.BankNum = field.NewInt64(tableName, "bank_num")
	_user.IsGuest = field.NewInt64(tableName, "is_guest")
	_user.RegCode = field.NewString(tableName, "reg_code")
	_user.IsAutoTransfer = field.NewInt64(tableName, "is_auto_transfer")
	_user.ThirdGameBalance = field.NewString(tableName, "third_game_balance")
	_user.FromUserCode = field.NewString(tableName, "from_user_code")
	_user.RecommendedCount = field.NewInt64(tableName, "recommended_count")
	_user.RecommendedName = field.NewString(tableName, "recommended_name")
	_user.IP = field.NewString(tableName, "ip")
	_user.RegisterIP = field.NewString(tableName, "register_ip")
	_user.JudgeBankCard = field.NewString(tableName, "judge_bank_card")
	_user.JudgeBankCardResult = field.NewInt64(tableName, "judge_bank_card_result")
	_user.Province = field.NewString(tableName, "province")
	_user.IPArea = field.NewString(tableName, "ip_area")
	_user.LastLoginAt = field.NewField(tableName, "last_login_at")
	_user.TotalOnlineDuration = field.NewInt64(tableName, "total_online_duration")
	_user.OnlineDuration = field.NewInt64(tableName, "online_duration")
	_user.Remark = field.NewString(tableName, "remark")
	_user.AutoFanshui = field.NewInt64(tableName, "auto_fanshui")
	_user.FirstRechargeAt = field.NewField(tableName, "first_recharge_at")
	_user.FirstRechargeAmount = field.NewFloat64(tableName, "first_recharge_amount")
	_user.LastRechargeAt = field.NewField(tableName, "last_recharge_at")
	_user.LastRechargeAmount = field.NewFloat64(tableName, "last_recharge_amount")
	_user.IconPath = field.NewString(tableName, "icon_path")
	_user.CreatedAt = field.NewField(tableName, "created_at")
	_user.UpdatedAt = field.NewField(tableName, "updated_at")
	_user.UserLevelUpdatedAt = field.NewField(tableName, "user_level_updated_at")
	_user.IsRisk = field.NewInt64(tableName, "is_risk")
	_user.NewPassword = field.NewString(tableName, "new_password")
	_user.Plat = field.NewInt64(tableName, "plat")
	_user.Mute = field.NewInt64(tableName, "mute")
	_user.MaxRechargeAmount = field.NewFloat64(tableName, "max_recharge_amount")
	_user.DeviceID = field.NewString(tableName, "device_id")
	_user.DeviceName = field.NewString(tableName, "device_name")
	_user.DeviceSystemVersion = field.NewString(tableName, "device_system_version")
	_user.IsLiveStreamer = field.NewInt64(tableName, "is_live_streamer")

	_user.fillFieldMap()

	return _user
}

type user struct {
	userDo userDo

	ALL                 field.Asterisk
	ID                  field.Int64
	Username            field.String
	Password            field.String
	APIToken            field.String
	PayPassword         field.String
	PaySecret           field.String // 支付明文密码
	ParentID            field.Int64
	ForefatherIds       field.String // 父亲树
	ParentName          field.String
	SignScore           field.Float64 // 签到积分
	IsOpen              field.Int64
	IsAgent             field.Int64  // 0: 普通用户, 1: 代理;2:总代理;3:股东
	IsTester            field.Int64  // 0: 普通用户, 1: 测试账号
	UserLevel           field.String // 用户层级
	PayLevel            field.String // 支付层级 对应pay_level表
	BankNum             field.Int64  // 用户能绑定的卡数
	IsGuest             field.Int64  // 是否是游客
	RegCode             field.String // 用户推广码
	IsAutoTransfer      field.Int64  // 是否自动转入转出 1 是 0 否
	ThirdGameBalance    field.String // 用于存放哪几个第三方有余额
	FromUserCode        field.String // 来自那个用户邀请码注册的
	RecommendedCount    field.Int64  // 推荐人总数
	RecommendedName     field.String // 推荐人姓名
	IP                  field.String
	RegisterIP          field.String // 注册ip地址
	JudgeBankCard       field.String // 注册彩金用户判定的银行卡
	JudgeBankCardResult field.Int64  // 注册彩金银行卡判定结果0:未通过, 1:通过
	Province            field.String // 注册所在省份
	IPArea              field.String // 注册ip所在地址
	LastLoginAt         field.Field  // 登录时间
	TotalOnlineDuration field.Int64  // 累计在线时长
	OnlineDuration      field.Int64  // 当前登录在线时长
	Remark              field.String
	AutoFanshui         field.Int64   // 是否自动领取返水 1 是 0 否
	FirstRechargeAt     field.Field   // 会员首次充值时间
	FirstRechargeAmount field.Float64 // 会员首次充值金额
	LastRechargeAt      field.Field   // 会员最后充值时间
	LastRechargeAmount  field.Float64 // 会员最后充值金额
	IconPath            field.String  // 用户头像
	CreatedAt           field.Field
	UpdatedAt           field.Field
	UserLevelUpdatedAt  field.Field   // vip晋级时间
	IsRisk              field.Int64   // 是否风险名单用户：1是，0否
	NewPassword         field.String  // hash密码
	Plat                field.Int64   // 终端;1:h5;2安卓;3ios4:pc
	Mute                field.Int64   // 是否禁言0:否;1:是
	MaxRechargeAmount   field.Float64 // 最大充值金额
	DeviceID            field.String  // 最后一次登录设备id
	DeviceName          field.String  // 最后一次登录设备名称
	DeviceSystemVersion field.String  // 最后一次登录设备系统版本
	IsLiveStreamer      field.Int64   // 是否主播：1是，0否

	fieldMap map[string]field.Expr
}

func (u user) Table(newTableName string) *user {
	u.userDo.UseTable(newTableName)
	return u.updateTableName(newTableName)
}

func (u user) As(alias string) *user {
	u.userDo.DO = *(u.userDo.As(alias).(*gen.DO))
	return u.updateTableName(alias)
}

func (u *user) updateTableName(table string) *user {
	u.ALL = field.NewAsterisk(table)
	u.ID = field.NewInt64(table, "id")
	u.Username = field.NewString(table, "username")
	u.Password = field.NewString(table, "password")
	u.APIToken = field.NewString(table, "api_token")
	u.PayPassword = field.NewString(table, "pay_password")
	u.PaySecret = field.NewString(table, "pay_secret")
	u.ParentID = field.NewInt64(table, "parent_id")
	u.ForefatherIds = field.NewString(table, "forefather_ids")
	u.ParentName = field.NewString(table, "parent_name")
	u.SignScore = field.NewFloat64(table, "sign_score")
	u.IsOpen = field.NewInt64(table, "is_open")
	u.IsAgent = field.NewInt64(table, "is_agent")
	u.IsTester = field.NewInt64(table, "is_tester")
	u.UserLevel = field.NewString(table, "user_level")
	u.PayLevel = field.NewString(table, "pay_level")
	u.BankNum = field.NewInt64(table, "bank_num")
	u.IsGuest = field.NewInt64(table, "is_guest")
	u.RegCode = field.NewString(table, "reg_code")
	u.IsAutoTransfer = field.NewInt64(table, "is_auto_transfer")
	u.ThirdGameBalance = field.NewString(table, "third_game_balance")
	u.FromUserCode = field.NewString(table, "from_user_code")
	u.RecommendedCount = field.NewInt64(table, "recommended_count")
	u.RecommendedName = field.NewString(table, "recommended_name")
	u.IP = field.NewString(table, "ip")
	u.RegisterIP = field.NewString(table, "register_ip")
	u.JudgeBankCard = field.NewString(table, "judge_bank_card")
	u.JudgeBankCardResult = field.NewInt64(table, "judge_bank_card_result")
	u.Province = field.NewString(table, "province")
	u.IPArea = field.NewString(table, "ip_area")
	u.LastLoginAt = field.NewField(table, "last_login_at")
	u.TotalOnlineDuration = field.NewInt64(table, "total_online_duration")
	u.OnlineDuration = field.NewInt64(table, "online_duration")
	u.Remark = field.NewString(table, "remark")
	u.AutoFanshui = field.NewInt64(table, "auto_fanshui")
	u.FirstRechargeAt = field.NewField(table, "first_recharge_at")
	u.FirstRechargeAmount = field.NewFloat64(table, "first_recharge_amount")
	u.LastRechargeAt = field.NewField(table, "last_recharge_at")
	u.LastRechargeAmount = field.NewFloat64(table, "last_recharge_amount")
	u.IconPath = field.NewString(table, "icon_path")
	u.CreatedAt = field.NewField(table, "created_at")
	u.UpdatedAt = field.NewField(table, "updated_at")
	u.UserLevelUpdatedAt = field.NewField(table, "user_level_updated_at")
	u.IsRisk = field.NewInt64(table, "is_risk")
	u.NewPassword = field.NewString(table, "new_password")
	u.Plat = field.NewInt64(table, "plat")
	u.Mute = field.NewInt64(table, "mute")
	u.MaxRechargeAmount = field.NewFloat64(table, "max_recharge_amount")
	u.DeviceID = field.NewString(table, "device_id")
	u.DeviceName = field.NewString(table, "device_name")
	u.DeviceSystemVersion = field.NewString(table, "device_system_version")
	u.IsLiveStreamer = field.NewInt64(table, "is_live_streamer")

	u.fillFieldMap()

	return u
}

func (u *user) WithContext(ctx context.Context) IUserDo { return u.userDo.WithContext(ctx) }

func (u user) TableName() string { return u.userDo.TableName() }

func (u user) Alias() string { return u.userDo.Alias() }

func (u user) Columns(cols ...field.Expr) gen.Columns { return u.userDo.Columns(cols...) }

func (u *user) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := u.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (u *user) fillFieldMap() {
	u.fieldMap = make(map[string]field.Expr, 51)
	u.fieldMap["id"] = u.ID
	u.fieldMap["username"] = u.Username
	u.fieldMap["password"] = u.Password
	u.fieldMap["api_token"] = u.APIToken
	u.fieldMap["pay_password"] = u.PayPassword
	u.fieldMap["pay_secret"] = u.PaySecret
	u.fieldMap["parent_id"] = u.ParentID
	u.fieldMap["forefather_ids"] = u.ForefatherIds
	u.fieldMap["parent_name"] = u.ParentName
	u.fieldMap["sign_score"] = u.SignScore
	u.fieldMap["is_open"] = u.IsOpen
	u.fieldMap["is_agent"] = u.IsAgent
	u.fieldMap["is_tester"] = u.IsTester
	u.fieldMap["user_level"] = u.UserLevel
	u.fieldMap["pay_level"] = u.PayLevel
	u.fieldMap["bank_num"] = u.BankNum
	u.fieldMap["is_guest"] = u.IsGuest
	u.fieldMap["reg_code"] = u.RegCode
	u.fieldMap["is_auto_transfer"] = u.IsAutoTransfer
	u.fieldMap["third_game_balance"] = u.ThirdGameBalance
	u.fieldMap["from_user_code"] = u.FromUserCode
	u.fieldMap["recommended_count"] = u.RecommendedCount
	u.fieldMap["recommended_name"] = u.RecommendedName
	u.fieldMap["ip"] = u.IP
	u.fieldMap["register_ip"] = u.RegisterIP
	u.fieldMap["judge_bank_card"] = u.JudgeBankCard
	u.fieldMap["judge_bank_card_result"] = u.JudgeBankCardResult
	u.fieldMap["province"] = u.Province
	u.fieldMap["ip_area"] = u.IPArea
	u.fieldMap["last_login_at"] = u.LastLoginAt
	u.fieldMap["total_online_duration"] = u.TotalOnlineDuration
	u.fieldMap["online_duration"] = u.OnlineDuration
	u.fieldMap["remark"] = u.Remark
	u.fieldMap["auto_fanshui"] = u.AutoFanshui
	u.fieldMap["first_recharge_at"] = u.FirstRechargeAt
	u.fieldMap["first_recharge_amount"] = u.FirstRechargeAmount
	u.fieldMap["last_recharge_at"] = u.LastRechargeAt
	u.fieldMap["last_recharge_amount"] = u.LastRechargeAmount
	u.fieldMap["icon_path"] = u.IconPath
	u.fieldMap["created_at"] = u.CreatedAt
	u.fieldMap["updated_at"] = u.UpdatedAt
	u.fieldMap["user_level_updated_at"] = u.UserLevelUpdatedAt
	u.fieldMap["is_risk"] = u.IsRisk
	u.fieldMap["new_password"] = u.NewPassword
	u.fieldMap["plat"] = u.Plat
	u.fieldMap["mute"] = u.Mute
	u.fieldMap["max_recharge_amount"] = u.MaxRechargeAmount
	u.fieldMap["device_id"] = u.DeviceID
	u.fieldMap["device_name"] = u.DeviceName
	u.fieldMap["device_system_version"] = u.DeviceSystemVersion
	u.fieldMap["is_live_streamer"] = u.IsLiveStreamer
}

func (u user) clone(db *gorm.DB) user {
	u.userDo.ReplaceConnPool(db.Statement.ConnPool)
	return u
}

func (u user) replaceDB(db *gorm.DB) user {
	u.userDo.ReplaceDB(db)
	return u
}

type userDo struct{ gen.DO }

type IUserDo interface {
	gen.SubQuery
	Debug() IUserDo
	WithContext(ctx context.Context) IUserDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() IUserDo
	WriteDB() IUserDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) IUserDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) IUserDo
	Not(conds ...gen.Condition) IUserDo
	Or(conds ...gen.Condition) IUserDo
	Select(conds ...field.Expr) IUserDo
	Where(conds ...gen.Condition) IUserDo
	Order(conds ...field.Expr) IUserDo
	Distinct(cols ...field.Expr) IUserDo
	Omit(cols ...field.Expr) IUserDo
	Join(table schema.Tabler, on ...field.Expr) IUserDo
	LeftJoin(table schema.Tabler, on ...field.Expr) IUserDo
	RightJoin(table schema.Tabler, on ...field.Expr) IUserDo
	Group(cols ...field.Expr) IUserDo
	Having(conds ...gen.Condition) IUserDo
	Limit(limit int) IUserDo
	Offset(offset int) IUserDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) IUserDo
	Unscoped() IUserDo
	Create(values ...*model.User) error
	CreateInBatches(values []*model.User, batchSize int) error
	Save(values ...*model.User) error
	First() (*model.User, error)
	Take() (*model.User, error)
	Last() (*model.User, error)
	Find() ([]*model.User, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.User, err error)
	FindInBatches(result *[]*model.User, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.User) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) IUserDo
	Assign(attrs ...field.AssignExpr) IUserDo
	Joins(fields ...field.RelationField) IUserDo
	Preload(fields ...field.RelationField) IUserDo
	FirstOrInit() (*model.User, error)
	FirstOrCreate() (*model.User, error)
	FindByPage(offset int, limit int) (result []*model.User, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Rows() (*sql.Rows, error)
	Row() *sql.Row
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) IUserDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (u userDo) Debug() IUserDo {
	return u.withDO(u.DO.Debug())
}

func (u userDo) WithContext(ctx context.Context) IUserDo {
	return u.withDO(u.DO.WithContext(ctx))
}

func (u userDo) ReadDB() IUserDo {
	return u.Clauses(dbresolver.Read)
}

func (u userDo) WriteDB() IUserDo {
	return u.Clauses(dbresolver.Write)
}

func (u userDo) Session(config *gorm.Session) IUserDo {
	return u.withDO(u.DO.Session(config))
}

func (u userDo) Clauses(conds ...clause.Expression) IUserDo {
	return u.withDO(u.DO.Clauses(conds...))
}

func (u userDo) Returning(value interface{}, columns ...string) IUserDo {
	return u.withDO(u.DO.Returning(value, columns...))
}

func (u userDo) Not(conds ...gen.Condition) IUserDo {
	return u.withDO(u.DO.Not(conds...))
}

func (u userDo) Or(conds ...gen.Condition) IUserDo {
	return u.withDO(u.DO.Or(conds...))
}

func (u userDo) Select(conds ...field.Expr) IUserDo {
	return u.withDO(u.DO.Select(conds...))
}

func (u userDo) Where(conds ...gen.Condition) IUserDo {
	return u.withDO(u.DO.Where(conds...))
}

func (u userDo) Order(conds ...field.Expr) IUserDo {
	return u.withDO(u.DO.Order(conds...))
}

func (u userDo) Distinct(cols ...field.Expr) IUserDo {
	return u.withDO(u.DO.Distinct(cols...))
}

func (u userDo) Omit(cols ...field.Expr) IUserDo {
	return u.withDO(u.DO.Omit(cols...))
}

func (u userDo) Join(table schema.Tabler, on ...field.Expr) IUserDo {
	return u.withDO(u.DO.Join(table, on...))
}

func (u userDo) LeftJoin(table schema.Tabler, on ...field.Expr) IUserDo {
	return u.withDO(u.DO.LeftJoin(table, on...))
}

func (u userDo) RightJoin(table schema.Tabler, on ...field.Expr) IUserDo {
	return u.withDO(u.DO.RightJoin(table, on...))
}

func (u userDo) Group(cols ...field.Expr) IUserDo {
	return u.withDO(u.DO.Group(cols...))
}

func (u userDo) Having(conds ...gen.Condition) IUserDo {
	return u.withDO(u.DO.Having(conds...))
}

func (u userDo) Limit(limit int) IUserDo {
	return u.withDO(u.DO.Limit(limit))
}

func (u userDo) Offset(offset int) IUserDo {
	return u.withDO(u.DO.Offset(offset))
}

func (u userDo) Scopes(funcs ...func(gen.Dao) gen.Dao) IUserDo {
	return u.withDO(u.DO.Scopes(funcs...))
}

func (u userDo) Unscoped() IUserDo {
	return u.withDO(u.DO.Unscoped())
}

func (u userDo) Create(values ...*model.User) error {
	if len(values) == 0 {
		return nil
	}
	return u.DO.Create(values)
}

func (u userDo) CreateInBatches(values []*model.User, batchSize int) error {
	return u.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (u userDo) Save(values ...*model.User) error {
	if len(values) == 0 {
		return nil
	}
	return u.DO.Save(values)
}

func (u userDo) First() (*model.User, error) {
	if result, err := u.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.User), nil
	}
}

func (u userDo) Take() (*model.User, error) {
	if result, err := u.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.User), nil
	}
}

func (u userDo) Last() (*model.User, error) {
	if result, err := u.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.User), nil
	}
}

func (u userDo) Find() ([]*model.User, error) {
	result, err := u.DO.Find()
	return result.([]*model.User), err
}

func (u userDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.User, err error) {
	buf := make([]*model.User, 0, batchSize)
	err = u.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (u userDo) FindInBatches(result *[]*model.User, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return u.DO.FindInBatches(result, batchSize, fc)
}

func (u userDo) Attrs(attrs ...field.AssignExpr) IUserDo {
	return u.withDO(u.DO.Attrs(attrs...))
}

func (u userDo) Assign(attrs ...field.AssignExpr) IUserDo {
	return u.withDO(u.DO.Assign(attrs...))
}

func (u userDo) Joins(fields ...field.RelationField) IUserDo {
	for _, _f := range fields {
		u = *u.withDO(u.DO.Joins(_f))
	}
	return &u
}

func (u userDo) Preload(fields ...field.RelationField) IUserDo {
	for _, _f := range fields {
		u = *u.withDO(u.DO.Preload(_f))
	}
	return &u
}

func (u userDo) FirstOrInit() (*model.User, error) {
	if result, err := u.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.User), nil
	}
}

func (u userDo) FirstOrCreate() (*model.User, error) {
	if result, err := u.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.User), nil
	}
}

func (u userDo) FindByPage(offset int, limit int) (result []*model.User, count int64, err error) {
	result, err = u.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = u.Offset(-1).Limit(-1).Count()
	return
}

func (u userDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = u.Count()
	if err != nil {
		return
	}

	err = u.Offset(offset).Limit(limit).Scan(result)
	return
}

func (u userDo) Scan(result interface{}) (err error) {
	return u.DO.Scan(result)
}

func (u userDo) Delete(models ...*model.User) (result gen.ResultInfo, err error) {
	return u.DO.Delete(models)
}

func (u *userDo) withDO(do gen.Dao) *userDo {
	u.DO = *do.(*gen.DO)
	return u
}
