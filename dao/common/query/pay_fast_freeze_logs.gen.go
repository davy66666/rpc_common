// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package query

import (
	"context"
	"database/sql"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"github.com/davy66666/rpc_common/dao/model"
)

func newPayFastFreezeLog(db *gorm.DB, opts ...gen.DOOption) payFastFreezeLog {
	_payFastFreezeLog := payFastFreezeLog{}

	_payFastFreezeLog.payFastFreezeLogDo.UseDB(db, opts...)
	_payFastFreezeLog.payFastFreezeLogDo.UseModel(&model.PayFastFreezeLog{})

	tableName := _payFastFreezeLog.payFastFreezeLogDo.TableName()
	_payFastFreezeLog.ALL = field.NewAsterisk(tableName)
	_payFastFreezeLog.ID = field.NewInt64(tableName, "id")
	_payFastFreezeLog.Username = field.NewString(tableName, "username")
	_payFastFreezeLog.UserID = field.NewInt64(tableName, "user_id")
	_payFastFreezeLog.PayLevelID = field.NewString(tableName, "pay_level_id")
	_payFastFreezeLog.PayLevelName = field.NewString(tableName, "pay_level_name")
	_payFastFreezeLog.Status = field.NewInt64(tableName, "status")
	_payFastFreezeLog.FreezeTime = field.NewInt64(tableName, "freeze_time")
	_payFastFreezeLog.ExpectFreezeTime = field.NewInt64(tableName, "expect_freeze_time")
	_payFastFreezeLog.ActualFreezeTime = field.NewInt64(tableName, "actual_freeze_time")
	_payFastFreezeLog.AdminName = field.NewString(tableName, "admin_name")
	_payFastFreezeLog.Remark = field.NewString(tableName, "remark")
	_payFastFreezeLog.CreatedAt = field.NewField(tableName, "created_at")
	_payFastFreezeLog.UpdatedAt = field.NewField(tableName, "updated_at")
	_payFastFreezeLog.BankType = field.NewInt64(tableName, "bank_type")
	_payFastFreezeLog.Source = field.NewInt64(tableName, "source")
	_payFastFreezeLog.FreezeSource = field.NewInt64(tableName, "freeze_source")

	_payFastFreezeLog.fillFieldMap()

	return _payFastFreezeLog
}

// payFastFreezeLog 极速取款会员冻结记录
type payFastFreezeLog struct {
	payFastFreezeLogDo payFastFreezeLogDo

	ALL              field.Asterisk
	ID               field.Int64
	Username         field.String // 会员名称
	UserID           field.Int64  // 会员id
	PayLevelID       field.String // 支付层级id
	PayLevelName     field.String // 支付层级名称
	Status           field.Int64  // 状态：[0:已解冻,1:冻结中]
	FreezeTime       field.Int64  // 冻结时间
	ExpectFreezeTime field.Int64  // 预计解冻时间
	ActualFreezeTime field.Int64  // 实际解冻时间
	AdminName        field.String // 管理员
	Remark           field.String // 备注
	CreatedAt        field.Field
	UpdatedAt        field.Field
	BankType         field.Int64 // 1:银行卡, 2:数字钱包, 3:易汇钱包, 4:支付宝, 5:微信, 6:数字人民币
	Source           field.Int64 // 来源：0前台，1后台
	FreezeSource     field.Int64 // 来源：0前台，1后台

	fieldMap map[string]field.Expr
}

func (p payFastFreezeLog) Table(newTableName string) *payFastFreezeLog {
	p.payFastFreezeLogDo.UseTable(newTableName)
	return p.updateTableName(newTableName)
}

func (p payFastFreezeLog) As(alias string) *payFastFreezeLog {
	p.payFastFreezeLogDo.DO = *(p.payFastFreezeLogDo.As(alias).(*gen.DO))
	return p.updateTableName(alias)
}

func (p *payFastFreezeLog) updateTableName(table string) *payFastFreezeLog {
	p.ALL = field.NewAsterisk(table)
	p.ID = field.NewInt64(table, "id")
	p.Username = field.NewString(table, "username")
	p.UserID = field.NewInt64(table, "user_id")
	p.PayLevelID = field.NewString(table, "pay_level_id")
	p.PayLevelName = field.NewString(table, "pay_level_name")
	p.Status = field.NewInt64(table, "status")
	p.FreezeTime = field.NewInt64(table, "freeze_time")
	p.ExpectFreezeTime = field.NewInt64(table, "expect_freeze_time")
	p.ActualFreezeTime = field.NewInt64(table, "actual_freeze_time")
	p.AdminName = field.NewString(table, "admin_name")
	p.Remark = field.NewString(table, "remark")
	p.CreatedAt = field.NewField(table, "created_at")
	p.UpdatedAt = field.NewField(table, "updated_at")
	p.BankType = field.NewInt64(table, "bank_type")
	p.Source = field.NewInt64(table, "source")
	p.FreezeSource = field.NewInt64(table, "freeze_source")

	p.fillFieldMap()

	return p
}

func (p *payFastFreezeLog) WithContext(ctx context.Context) IPayFastFreezeLogDo {
	return p.payFastFreezeLogDo.WithContext(ctx)
}

func (p payFastFreezeLog) TableName() string { return p.payFastFreezeLogDo.TableName() }

func (p payFastFreezeLog) Alias() string { return p.payFastFreezeLogDo.Alias() }

func (p payFastFreezeLog) Columns(cols ...field.Expr) gen.Columns {
	return p.payFastFreezeLogDo.Columns(cols...)
}

func (p *payFastFreezeLog) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := p.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (p *payFastFreezeLog) fillFieldMap() {
	p.fieldMap = make(map[string]field.Expr, 16)
	p.fieldMap["id"] = p.ID
	p.fieldMap["username"] = p.Username
	p.fieldMap["user_id"] = p.UserID
	p.fieldMap["pay_level_id"] = p.PayLevelID
	p.fieldMap["pay_level_name"] = p.PayLevelName
	p.fieldMap["status"] = p.Status
	p.fieldMap["freeze_time"] = p.FreezeTime
	p.fieldMap["expect_freeze_time"] = p.ExpectFreezeTime
	p.fieldMap["actual_freeze_time"] = p.ActualFreezeTime
	p.fieldMap["admin_name"] = p.AdminName
	p.fieldMap["remark"] = p.Remark
	p.fieldMap["created_at"] = p.CreatedAt
	p.fieldMap["updated_at"] = p.UpdatedAt
	p.fieldMap["bank_type"] = p.BankType
	p.fieldMap["source"] = p.Source
	p.fieldMap["freeze_source"] = p.FreezeSource
}

func (p payFastFreezeLog) clone(db *gorm.DB) payFastFreezeLog {
	p.payFastFreezeLogDo.ReplaceConnPool(db.Statement.ConnPool)
	return p
}

func (p payFastFreezeLog) replaceDB(db *gorm.DB) payFastFreezeLog {
	p.payFastFreezeLogDo.ReplaceDB(db)
	return p
}

type payFastFreezeLogDo struct{ gen.DO }

type IPayFastFreezeLogDo interface {
	gen.SubQuery
	Debug() IPayFastFreezeLogDo
	WithContext(ctx context.Context) IPayFastFreezeLogDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() IPayFastFreezeLogDo
	WriteDB() IPayFastFreezeLogDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) IPayFastFreezeLogDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) IPayFastFreezeLogDo
	Not(conds ...gen.Condition) IPayFastFreezeLogDo
	Or(conds ...gen.Condition) IPayFastFreezeLogDo
	Select(conds ...field.Expr) IPayFastFreezeLogDo
	Where(conds ...gen.Condition) IPayFastFreezeLogDo
	Order(conds ...field.Expr) IPayFastFreezeLogDo
	Distinct(cols ...field.Expr) IPayFastFreezeLogDo
	Omit(cols ...field.Expr) IPayFastFreezeLogDo
	Join(table schema.Tabler, on ...field.Expr) IPayFastFreezeLogDo
	LeftJoin(table schema.Tabler, on ...field.Expr) IPayFastFreezeLogDo
	RightJoin(table schema.Tabler, on ...field.Expr) IPayFastFreezeLogDo
	Group(cols ...field.Expr) IPayFastFreezeLogDo
	Having(conds ...gen.Condition) IPayFastFreezeLogDo
	Limit(limit int) IPayFastFreezeLogDo
	Offset(offset int) IPayFastFreezeLogDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) IPayFastFreezeLogDo
	Unscoped() IPayFastFreezeLogDo
	Create(values ...*model.PayFastFreezeLog) error
	CreateInBatches(values []*model.PayFastFreezeLog, batchSize int) error
	Save(values ...*model.PayFastFreezeLog) error
	First() (*model.PayFastFreezeLog, error)
	Take() (*model.PayFastFreezeLog, error)
	Last() (*model.PayFastFreezeLog, error)
	Find() ([]*model.PayFastFreezeLog, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.PayFastFreezeLog, err error)
	FindInBatches(result *[]*model.PayFastFreezeLog, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.PayFastFreezeLog) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) IPayFastFreezeLogDo
	Assign(attrs ...field.AssignExpr) IPayFastFreezeLogDo
	Joins(fields ...field.RelationField) IPayFastFreezeLogDo
	Preload(fields ...field.RelationField) IPayFastFreezeLogDo
	FirstOrInit() (*model.PayFastFreezeLog, error)
	FirstOrCreate() (*model.PayFastFreezeLog, error)
	FindByPage(offset int, limit int) (result []*model.PayFastFreezeLog, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Rows() (*sql.Rows, error)
	Row() *sql.Row
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) IPayFastFreezeLogDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (p payFastFreezeLogDo) Debug() IPayFastFreezeLogDo {
	return p.withDO(p.DO.Debug())
}

func (p payFastFreezeLogDo) WithContext(ctx context.Context) IPayFastFreezeLogDo {
	return p.withDO(p.DO.WithContext(ctx))
}

func (p payFastFreezeLogDo) ReadDB() IPayFastFreezeLogDo {
	return p.Clauses(dbresolver.Read)
}

func (p payFastFreezeLogDo) WriteDB() IPayFastFreezeLogDo {
	return p.Clauses(dbresolver.Write)
}

func (p payFastFreezeLogDo) Session(config *gorm.Session) IPayFastFreezeLogDo {
	return p.withDO(p.DO.Session(config))
}

func (p payFastFreezeLogDo) Clauses(conds ...clause.Expression) IPayFastFreezeLogDo {
	return p.withDO(p.DO.Clauses(conds...))
}

func (p payFastFreezeLogDo) Returning(value interface{}, columns ...string) IPayFastFreezeLogDo {
	return p.withDO(p.DO.Returning(value, columns...))
}

func (p payFastFreezeLogDo) Not(conds ...gen.Condition) IPayFastFreezeLogDo {
	return p.withDO(p.DO.Not(conds...))
}

func (p payFastFreezeLogDo) Or(conds ...gen.Condition) IPayFastFreezeLogDo {
	return p.withDO(p.DO.Or(conds...))
}

func (p payFastFreezeLogDo) Select(conds ...field.Expr) IPayFastFreezeLogDo {
	return p.withDO(p.DO.Select(conds...))
}

func (p payFastFreezeLogDo) Where(conds ...gen.Condition) IPayFastFreezeLogDo {
	return p.withDO(p.DO.Where(conds...))
}

func (p payFastFreezeLogDo) Order(conds ...field.Expr) IPayFastFreezeLogDo {
	return p.withDO(p.DO.Order(conds...))
}

func (p payFastFreezeLogDo) Distinct(cols ...field.Expr) IPayFastFreezeLogDo {
	return p.withDO(p.DO.Distinct(cols...))
}

func (p payFastFreezeLogDo) Omit(cols ...field.Expr) IPayFastFreezeLogDo {
	return p.withDO(p.DO.Omit(cols...))
}

func (p payFastFreezeLogDo) Join(table schema.Tabler, on ...field.Expr) IPayFastFreezeLogDo {
	return p.withDO(p.DO.Join(table, on...))
}

func (p payFastFreezeLogDo) LeftJoin(table schema.Tabler, on ...field.Expr) IPayFastFreezeLogDo {
	return p.withDO(p.DO.LeftJoin(table, on...))
}

func (p payFastFreezeLogDo) RightJoin(table schema.Tabler, on ...field.Expr) IPayFastFreezeLogDo {
	return p.withDO(p.DO.RightJoin(table, on...))
}

func (p payFastFreezeLogDo) Group(cols ...field.Expr) IPayFastFreezeLogDo {
	return p.withDO(p.DO.Group(cols...))
}

func (p payFastFreezeLogDo) Having(conds ...gen.Condition) IPayFastFreezeLogDo {
	return p.withDO(p.DO.Having(conds...))
}

func (p payFastFreezeLogDo) Limit(limit int) IPayFastFreezeLogDo {
	return p.withDO(p.DO.Limit(limit))
}

func (p payFastFreezeLogDo) Offset(offset int) IPayFastFreezeLogDo {
	return p.withDO(p.DO.Offset(offset))
}

func (p payFastFreezeLogDo) Scopes(funcs ...func(gen.Dao) gen.Dao) IPayFastFreezeLogDo {
	return p.withDO(p.DO.Scopes(funcs...))
}

func (p payFastFreezeLogDo) Unscoped() IPayFastFreezeLogDo {
	return p.withDO(p.DO.Unscoped())
}

func (p payFastFreezeLogDo) Create(values ...*model.PayFastFreezeLog) error {
	if len(values) == 0 {
		return nil
	}
	return p.DO.Create(values)
}

func (p payFastFreezeLogDo) CreateInBatches(values []*model.PayFastFreezeLog, batchSize int) error {
	return p.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (p payFastFreezeLogDo) Save(values ...*model.PayFastFreezeLog) error {
	if len(values) == 0 {
		return nil
	}
	return p.DO.Save(values)
}

func (p payFastFreezeLogDo) First() (*model.PayFastFreezeLog, error) {
	if result, err := p.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.PayFastFreezeLog), nil
	}
}

func (p payFastFreezeLogDo) Take() (*model.PayFastFreezeLog, error) {
	if result, err := p.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.PayFastFreezeLog), nil
	}
}

func (p payFastFreezeLogDo) Last() (*model.PayFastFreezeLog, error) {
	if result, err := p.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.PayFastFreezeLog), nil
	}
}

func (p payFastFreezeLogDo) Find() ([]*model.PayFastFreezeLog, error) {
	result, err := p.DO.Find()
	return result.([]*model.PayFastFreezeLog), err
}

func (p payFastFreezeLogDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.PayFastFreezeLog, err error) {
	buf := make([]*model.PayFastFreezeLog, 0, batchSize)
	err = p.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (p payFastFreezeLogDo) FindInBatches(result *[]*model.PayFastFreezeLog, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return p.DO.FindInBatches(result, batchSize, fc)
}

func (p payFastFreezeLogDo) Attrs(attrs ...field.AssignExpr) IPayFastFreezeLogDo {
	return p.withDO(p.DO.Attrs(attrs...))
}

func (p payFastFreezeLogDo) Assign(attrs ...field.AssignExpr) IPayFastFreezeLogDo {
	return p.withDO(p.DO.Assign(attrs...))
}

func (p payFastFreezeLogDo) Joins(fields ...field.RelationField) IPayFastFreezeLogDo {
	for _, _f := range fields {
		p = *p.withDO(p.DO.Joins(_f))
	}
	return &p
}

func (p payFastFreezeLogDo) Preload(fields ...field.RelationField) IPayFastFreezeLogDo {
	for _, _f := range fields {
		p = *p.withDO(p.DO.Preload(_f))
	}
	return &p
}

func (p payFastFreezeLogDo) FirstOrInit() (*model.PayFastFreezeLog, error) {
	if result, err := p.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.PayFastFreezeLog), nil
	}
}

func (p payFastFreezeLogDo) FirstOrCreate() (*model.PayFastFreezeLog, error) {
	if result, err := p.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.PayFastFreezeLog), nil
	}
}

func (p payFastFreezeLogDo) FindByPage(offset int, limit int) (result []*model.PayFastFreezeLog, count int64, err error) {
	result, err = p.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = p.Offset(-1).Limit(-1).Count()
	return
}

func (p payFastFreezeLogDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = p.Count()
	if err != nil {
		return
	}

	err = p.Offset(offset).Limit(limit).Scan(result)
	return
}

func (p payFastFreezeLogDo) Scan(result interface{}) (err error) {
	return p.DO.Scan(result)
}

func (p payFastFreezeLogDo) Delete(models ...*model.PayFastFreezeLog) (result gen.ResultInfo, err error) {
	return p.DO.Delete(models)
}

func (p *payFastFreezeLogDo) withDO(do gen.Dao) *payFastFreezeLogDo {
	p.DO = *do.(*gen.DO)
	return p
}
