// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package query

import (
	"context"
	"database/sql"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"github.com/davy66666/rpc_common/dao/model"
)

func newGameMatchUserBet(db *gorm.DB, opts ...gen.DOOption) gameMatchUserBet {
	_gameMatchUserBet := gameMatchUserBet{}

	_gameMatchUserBet.gameMatchUserBetDo.UseDB(db, opts...)
	_gameMatchUserBet.gameMatchUserBetDo.UseModel(&model.GameMatchUserBet{})

	tableName := _gameMatchUserBet.gameMatchUserBetDo.TableName()
	_gameMatchUserBet.ALL = field.NewAsterisk(tableName)
	_gameMatchUserBet.ID = field.NewInt64(tableName, "id")
	_gameMatchUserBet.GameMatchID = field.NewInt64(tableName, "game_match_id")
	_gameMatchUserBet.UserID = field.NewInt64(tableName, "user_id")
	_gameMatchUserBet.Username = field.NewString(tableName, "username")
	_gameMatchUserBet.GameCode = field.NewString(tableName, "game_code")
	_gameMatchUserBet.BetNums = field.NewInt64(tableName, "bet_nums")
	_gameMatchUserBet.BetAmount = field.NewFloat64(tableName, "bet_amount")
	_gameMatchUserBet.ValidBetAmount = field.NewFloat64(tableName, "valid_bet_amount")
	_gameMatchUserBet.NetAmount = field.NewFloat64(tableName, "net_amount")
	_gameMatchUserBet.InitAmount = field.NewFloat64(tableName, "init_amount")
	_gameMatchUserBet.IP = field.NewString(tableName, "ip")
	_gameMatchUserBet.IPArea = field.NewString(tableName, "ip_area")
	_gameMatchUserBet.MatchRank = field.NewInt64(tableName, "match_rank")
	_gameMatchUserBet.AwardAmount = field.NewFloat64(tableName, "award_amount")
	_gameMatchUserBet.AwardAt = field.NewField(tableName, "award_at")
	_gameMatchUserBet.IsAward = field.NewInt64(tableName, "is_award")
	_gameMatchUserBet.IsRecycleAmount = field.NewInt64(tableName, "is_recycle_amount")
	_gameMatchUserBet.Remark = field.NewString(tableName, "remark")
	_gameMatchUserBet.AdminID = field.NewInt64(tableName, "admin_id")
	_gameMatchUserBet.AdminName = field.NewString(tableName, "admin_name")
	_gameMatchUserBet.CreatedAt = field.NewField(tableName, "created_at")
	_gameMatchUserBet.UpdatedAt = field.NewField(tableName, "updated_at")

	_gameMatchUserBet.fillFieldMap()

	return _gameMatchUserBet
}

// gameMatchUserBet 争霸赛用户报名参赛记录表
type gameMatchUserBet struct {
	gameMatchUserBetDo gameMatchUserBetDo

	ALL             field.Asterisk
	ID              field.Int64
	GameMatchID     field.Int64   // 争霸赛id
	UserID          field.Int64   // 用户id
	Username        field.String  // 用户名
	GameCode        field.String  // 游戏类型
	BetNums         field.Int64   // 注单量
	BetAmount       field.Float64 // 用户投注金额 包括无效金额
	ValidBetAmount  field.Float64 // 有效投注金额
	NetAmount       field.Float64 // 玩家的所赢金额
	InitAmount      field.Float64 // 初始金额，默认2000
	IP              field.String  // 用户报名IP
	IPArea          field.String  // ip所在地址
	MatchRank       field.Int64   // 比赛排名，为空则没有排名
	AwardAmount     field.Float64 // 获奖金额
	AwardAt         field.Field   // 颁奖时间
	IsAward         field.Int64   // 是否颁奖[0:否,1:是]
	IsRecycleAmount field.Int64   // 是否已回收游戏额度[0:否,1:是]
	Remark          field.String  // 备注
	AdminID         field.Int64   // 操作员ID
	AdminName       field.String  // 操作管理员
	CreatedAt       field.Field
	UpdatedAt       field.Field

	fieldMap map[string]field.Expr
}

func (g gameMatchUserBet) Table(newTableName string) *gameMatchUserBet {
	g.gameMatchUserBetDo.UseTable(newTableName)
	return g.updateTableName(newTableName)
}

func (g gameMatchUserBet) As(alias string) *gameMatchUserBet {
	g.gameMatchUserBetDo.DO = *(g.gameMatchUserBetDo.As(alias).(*gen.DO))
	return g.updateTableName(alias)
}

func (g *gameMatchUserBet) updateTableName(table string) *gameMatchUserBet {
	g.ALL = field.NewAsterisk(table)
	g.ID = field.NewInt64(table, "id")
	g.GameMatchID = field.NewInt64(table, "game_match_id")
	g.UserID = field.NewInt64(table, "user_id")
	g.Username = field.NewString(table, "username")
	g.GameCode = field.NewString(table, "game_code")
	g.BetNums = field.NewInt64(table, "bet_nums")
	g.BetAmount = field.NewFloat64(table, "bet_amount")
	g.ValidBetAmount = field.NewFloat64(table, "valid_bet_amount")
	g.NetAmount = field.NewFloat64(table, "net_amount")
	g.InitAmount = field.NewFloat64(table, "init_amount")
	g.IP = field.NewString(table, "ip")
	g.IPArea = field.NewString(table, "ip_area")
	g.MatchRank = field.NewInt64(table, "match_rank")
	g.AwardAmount = field.NewFloat64(table, "award_amount")
	g.AwardAt = field.NewField(table, "award_at")
	g.IsAward = field.NewInt64(table, "is_award")
	g.IsRecycleAmount = field.NewInt64(table, "is_recycle_amount")
	g.Remark = field.NewString(table, "remark")
	g.AdminID = field.NewInt64(table, "admin_id")
	g.AdminName = field.NewString(table, "admin_name")
	g.CreatedAt = field.NewField(table, "created_at")
	g.UpdatedAt = field.NewField(table, "updated_at")

	g.fillFieldMap()

	return g
}

func (g *gameMatchUserBet) WithContext(ctx context.Context) IGameMatchUserBetDo {
	return g.gameMatchUserBetDo.WithContext(ctx)
}

func (g gameMatchUserBet) TableName() string { return g.gameMatchUserBetDo.TableName() }

func (g gameMatchUserBet) Alias() string { return g.gameMatchUserBetDo.Alias() }

func (g gameMatchUserBet) Columns(cols ...field.Expr) gen.Columns {
	return g.gameMatchUserBetDo.Columns(cols...)
}

func (g *gameMatchUserBet) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := g.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (g *gameMatchUserBet) fillFieldMap() {
	g.fieldMap = make(map[string]field.Expr, 22)
	g.fieldMap["id"] = g.ID
	g.fieldMap["game_match_id"] = g.GameMatchID
	g.fieldMap["user_id"] = g.UserID
	g.fieldMap["username"] = g.Username
	g.fieldMap["game_code"] = g.GameCode
	g.fieldMap["bet_nums"] = g.BetNums
	g.fieldMap["bet_amount"] = g.BetAmount
	g.fieldMap["valid_bet_amount"] = g.ValidBetAmount
	g.fieldMap["net_amount"] = g.NetAmount
	g.fieldMap["init_amount"] = g.InitAmount
	g.fieldMap["ip"] = g.IP
	g.fieldMap["ip_area"] = g.IPArea
	g.fieldMap["match_rank"] = g.MatchRank
	g.fieldMap["award_amount"] = g.AwardAmount
	g.fieldMap["award_at"] = g.AwardAt
	g.fieldMap["is_award"] = g.IsAward
	g.fieldMap["is_recycle_amount"] = g.IsRecycleAmount
	g.fieldMap["remark"] = g.Remark
	g.fieldMap["admin_id"] = g.AdminID
	g.fieldMap["admin_name"] = g.AdminName
	g.fieldMap["created_at"] = g.CreatedAt
	g.fieldMap["updated_at"] = g.UpdatedAt
}

func (g gameMatchUserBet) clone(db *gorm.DB) gameMatchUserBet {
	g.gameMatchUserBetDo.ReplaceConnPool(db.Statement.ConnPool)
	return g
}

func (g gameMatchUserBet) replaceDB(db *gorm.DB) gameMatchUserBet {
	g.gameMatchUserBetDo.ReplaceDB(db)
	return g
}

type gameMatchUserBetDo struct{ gen.DO }

type IGameMatchUserBetDo interface {
	gen.SubQuery
	Debug() IGameMatchUserBetDo
	WithContext(ctx context.Context) IGameMatchUserBetDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() IGameMatchUserBetDo
	WriteDB() IGameMatchUserBetDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) IGameMatchUserBetDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) IGameMatchUserBetDo
	Not(conds ...gen.Condition) IGameMatchUserBetDo
	Or(conds ...gen.Condition) IGameMatchUserBetDo
	Select(conds ...field.Expr) IGameMatchUserBetDo
	Where(conds ...gen.Condition) IGameMatchUserBetDo
	Order(conds ...field.Expr) IGameMatchUserBetDo
	Distinct(cols ...field.Expr) IGameMatchUserBetDo
	Omit(cols ...field.Expr) IGameMatchUserBetDo
	Join(table schema.Tabler, on ...field.Expr) IGameMatchUserBetDo
	LeftJoin(table schema.Tabler, on ...field.Expr) IGameMatchUserBetDo
	RightJoin(table schema.Tabler, on ...field.Expr) IGameMatchUserBetDo
	Group(cols ...field.Expr) IGameMatchUserBetDo
	Having(conds ...gen.Condition) IGameMatchUserBetDo
	Limit(limit int) IGameMatchUserBetDo
	Offset(offset int) IGameMatchUserBetDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) IGameMatchUserBetDo
	Unscoped() IGameMatchUserBetDo
	Create(values ...*model.GameMatchUserBet) error
	CreateInBatches(values []*model.GameMatchUserBet, batchSize int) error
	Save(values ...*model.GameMatchUserBet) error
	First() (*model.GameMatchUserBet, error)
	Take() (*model.GameMatchUserBet, error)
	Last() (*model.GameMatchUserBet, error)
	Find() ([]*model.GameMatchUserBet, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.GameMatchUserBet, err error)
	FindInBatches(result *[]*model.GameMatchUserBet, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.GameMatchUserBet) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) IGameMatchUserBetDo
	Assign(attrs ...field.AssignExpr) IGameMatchUserBetDo
	Joins(fields ...field.RelationField) IGameMatchUserBetDo
	Preload(fields ...field.RelationField) IGameMatchUserBetDo
	FirstOrInit() (*model.GameMatchUserBet, error)
	FirstOrCreate() (*model.GameMatchUserBet, error)
	FindByPage(offset int, limit int) (result []*model.GameMatchUserBet, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Rows() (*sql.Rows, error)
	Row() *sql.Row
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) IGameMatchUserBetDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (g gameMatchUserBetDo) Debug() IGameMatchUserBetDo {
	return g.withDO(g.DO.Debug())
}

func (g gameMatchUserBetDo) WithContext(ctx context.Context) IGameMatchUserBetDo {
	return g.withDO(g.DO.WithContext(ctx))
}

func (g gameMatchUserBetDo) ReadDB() IGameMatchUserBetDo {
	return g.Clauses(dbresolver.Read)
}

func (g gameMatchUserBetDo) WriteDB() IGameMatchUserBetDo {
	return g.Clauses(dbresolver.Write)
}

func (g gameMatchUserBetDo) Session(config *gorm.Session) IGameMatchUserBetDo {
	return g.withDO(g.DO.Session(config))
}

func (g gameMatchUserBetDo) Clauses(conds ...clause.Expression) IGameMatchUserBetDo {
	return g.withDO(g.DO.Clauses(conds...))
}

func (g gameMatchUserBetDo) Returning(value interface{}, columns ...string) IGameMatchUserBetDo {
	return g.withDO(g.DO.Returning(value, columns...))
}

func (g gameMatchUserBetDo) Not(conds ...gen.Condition) IGameMatchUserBetDo {
	return g.withDO(g.DO.Not(conds...))
}

func (g gameMatchUserBetDo) Or(conds ...gen.Condition) IGameMatchUserBetDo {
	return g.withDO(g.DO.Or(conds...))
}

func (g gameMatchUserBetDo) Select(conds ...field.Expr) IGameMatchUserBetDo {
	return g.withDO(g.DO.Select(conds...))
}

func (g gameMatchUserBetDo) Where(conds ...gen.Condition) IGameMatchUserBetDo {
	return g.withDO(g.DO.Where(conds...))
}

func (g gameMatchUserBetDo) Order(conds ...field.Expr) IGameMatchUserBetDo {
	return g.withDO(g.DO.Order(conds...))
}

func (g gameMatchUserBetDo) Distinct(cols ...field.Expr) IGameMatchUserBetDo {
	return g.withDO(g.DO.Distinct(cols...))
}

func (g gameMatchUserBetDo) Omit(cols ...field.Expr) IGameMatchUserBetDo {
	return g.withDO(g.DO.Omit(cols...))
}

func (g gameMatchUserBetDo) Join(table schema.Tabler, on ...field.Expr) IGameMatchUserBetDo {
	return g.withDO(g.DO.Join(table, on...))
}

func (g gameMatchUserBetDo) LeftJoin(table schema.Tabler, on ...field.Expr) IGameMatchUserBetDo {
	return g.withDO(g.DO.LeftJoin(table, on...))
}

func (g gameMatchUserBetDo) RightJoin(table schema.Tabler, on ...field.Expr) IGameMatchUserBetDo {
	return g.withDO(g.DO.RightJoin(table, on...))
}

func (g gameMatchUserBetDo) Group(cols ...field.Expr) IGameMatchUserBetDo {
	return g.withDO(g.DO.Group(cols...))
}

func (g gameMatchUserBetDo) Having(conds ...gen.Condition) IGameMatchUserBetDo {
	return g.withDO(g.DO.Having(conds...))
}

func (g gameMatchUserBetDo) Limit(limit int) IGameMatchUserBetDo {
	return g.withDO(g.DO.Limit(limit))
}

func (g gameMatchUserBetDo) Offset(offset int) IGameMatchUserBetDo {
	return g.withDO(g.DO.Offset(offset))
}

func (g gameMatchUserBetDo) Scopes(funcs ...func(gen.Dao) gen.Dao) IGameMatchUserBetDo {
	return g.withDO(g.DO.Scopes(funcs...))
}

func (g gameMatchUserBetDo) Unscoped() IGameMatchUserBetDo {
	return g.withDO(g.DO.Unscoped())
}

func (g gameMatchUserBetDo) Create(values ...*model.GameMatchUserBet) error {
	if len(values) == 0 {
		return nil
	}
	return g.DO.Create(values)
}

func (g gameMatchUserBetDo) CreateInBatches(values []*model.GameMatchUserBet, batchSize int) error {
	return g.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (g gameMatchUserBetDo) Save(values ...*model.GameMatchUserBet) error {
	if len(values) == 0 {
		return nil
	}
	return g.DO.Save(values)
}

func (g gameMatchUserBetDo) First() (*model.GameMatchUserBet, error) {
	if result, err := g.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.GameMatchUserBet), nil
	}
}

func (g gameMatchUserBetDo) Take() (*model.GameMatchUserBet, error) {
	if result, err := g.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.GameMatchUserBet), nil
	}
}

func (g gameMatchUserBetDo) Last() (*model.GameMatchUserBet, error) {
	if result, err := g.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.GameMatchUserBet), nil
	}
}

func (g gameMatchUserBetDo) Find() ([]*model.GameMatchUserBet, error) {
	result, err := g.DO.Find()
	return result.([]*model.GameMatchUserBet), err
}

func (g gameMatchUserBetDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.GameMatchUserBet, err error) {
	buf := make([]*model.GameMatchUserBet, 0, batchSize)
	err = g.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (g gameMatchUserBetDo) FindInBatches(result *[]*model.GameMatchUserBet, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return g.DO.FindInBatches(result, batchSize, fc)
}

func (g gameMatchUserBetDo) Attrs(attrs ...field.AssignExpr) IGameMatchUserBetDo {
	return g.withDO(g.DO.Attrs(attrs...))
}

func (g gameMatchUserBetDo) Assign(attrs ...field.AssignExpr) IGameMatchUserBetDo {
	return g.withDO(g.DO.Assign(attrs...))
}

func (g gameMatchUserBetDo) Joins(fields ...field.RelationField) IGameMatchUserBetDo {
	for _, _f := range fields {
		g = *g.withDO(g.DO.Joins(_f))
	}
	return &g
}

func (g gameMatchUserBetDo) Preload(fields ...field.RelationField) IGameMatchUserBetDo {
	for _, _f := range fields {
		g = *g.withDO(g.DO.Preload(_f))
	}
	return &g
}

func (g gameMatchUserBetDo) FirstOrInit() (*model.GameMatchUserBet, error) {
	if result, err := g.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.GameMatchUserBet), nil
	}
}

func (g gameMatchUserBetDo) FirstOrCreate() (*model.GameMatchUserBet, error) {
	if result, err := g.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.GameMatchUserBet), nil
	}
}

func (g gameMatchUserBetDo) FindByPage(offset int, limit int) (result []*model.GameMatchUserBet, count int64, err error) {
	result, err = g.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = g.Offset(-1).Limit(-1).Count()
	return
}

func (g gameMatchUserBetDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = g.Count()
	if err != nil {
		return
	}

	err = g.Offset(offset).Limit(limit).Scan(result)
	return
}

func (g gameMatchUserBetDo) Scan(result interface{}) (err error) {
	return g.DO.Scan(result)
}

func (g gameMatchUserBetDo) Delete(models ...*model.GameMatchUserBet) (result gen.ResultInfo, err error) {
	return g.DO.Delete(models)
}

func (g *gameMatchUserBetDo) withDO(do gen.Dao) *gameMatchUserBetDo {
	g.DO = *do.(*gen.DO)
	return g
}
