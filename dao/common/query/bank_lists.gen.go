// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package query

import (
	"context"
	"database/sql"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"github.com/davy66666/rpc_common/dao/model"
)

func newBankList(db *gorm.DB, opts ...gen.DOOption) bankList {
	_bankList := bankList{}

	_bankList.bankListDo.UseDB(db, opts...)
	_bankList.bankListDo.UseModel(&model.BankList{})

	tableName := _bankList.bankListDo.TableName()
	_bankList.ALL = field.NewAsterisk(tableName)
	_bankList.ID = field.NewInt64(tableName, "id")
	_bankList.ShortName = field.NewString(tableName, "short_name")
	_bankList.BankName = field.NewString(tableName, "bank_name")
	_bankList.Sort = field.NewInt64(tableName, "sort")
	_bankList.BankType = field.NewInt64(tableName, "bank_type")
	_bankList.ImgPath = field.NewString(tableName, "img_path")
	_bankList.IsOpen = field.NewInt64(tableName, "is_open")
	_bankList.WithdrawType = field.NewInt64(tableName, "withdraw_type")
	_bankList.Is3U = field.NewInt64(tableName, "is_3u")
	_bankList.VirtualCurrencyName = field.NewString(tableName, "virtual_currency_name")
	_bankList.CreatedAt = field.NewField(tableName, "created_at")
	_bankList.UpdatedAt = field.NewField(tableName, "updated_at")
	_bankList.FundsType = field.NewInt64(tableName, "funds_type")
	_bankList.IsLimitArea = field.NewInt64(tableName, "is_limit_area")
	_bankList.LimitAreas = field.NewString(tableName, "limit_areas")

	_bankList.fillFieldMap()

	return _bankList
}

// bankList 银行卡列表
type bankList struct {
	bankListDo bankListDo

	ALL                 field.Asterisk
	ID                  field.Int64
	ShortName           field.String // 银行简称
	BankName            field.String // 银行名称
	Sort                field.Int64  // 排序
	BankType            field.Int64  // 1:银行卡, 2:数字钱包, 3:易汇钱包, 4:支付宝, 5:微信, 6:数字人民币
	ImgPath             field.String // 图标路径
	IsOpen              field.Int64  // 是否开启0:否;1:是
	WithdrawType        field.Int64  // 1:bank, 2:USDT, 3:购宝, 4:GOPAY
	Is3U                field.Int64  // 是否3u,0:否, 1:是
	VirtualCurrencyName field.String // 虚拟货币网络名称, 比如:usdt, btc
	CreatedAt           field.Field
	UpdatedAt           field.Field
	FundsType           field.Int64  // 资金类型：1 rmb，2 usdt 3钱包
	IsLimitArea         field.Int64  // 是否限制地区：1限制，0不限制,默认0
	LimitAreas          field.String // 限制地区，英文逗号相隔

	fieldMap map[string]field.Expr
}

func (b bankList) Table(newTableName string) *bankList {
	b.bankListDo.UseTable(newTableName)
	return b.updateTableName(newTableName)
}

func (b bankList) As(alias string) *bankList {
	b.bankListDo.DO = *(b.bankListDo.As(alias).(*gen.DO))
	return b.updateTableName(alias)
}

func (b *bankList) updateTableName(table string) *bankList {
	b.ALL = field.NewAsterisk(table)
	b.ID = field.NewInt64(table, "id")
	b.ShortName = field.NewString(table, "short_name")
	b.BankName = field.NewString(table, "bank_name")
	b.Sort = field.NewInt64(table, "sort")
	b.BankType = field.NewInt64(table, "bank_type")
	b.ImgPath = field.NewString(table, "img_path")
	b.IsOpen = field.NewInt64(table, "is_open")
	b.WithdrawType = field.NewInt64(table, "withdraw_type")
	b.Is3U = field.NewInt64(table, "is_3u")
	b.VirtualCurrencyName = field.NewString(table, "virtual_currency_name")
	b.CreatedAt = field.NewField(table, "created_at")
	b.UpdatedAt = field.NewField(table, "updated_at")
	b.FundsType = field.NewInt64(table, "funds_type")
	b.IsLimitArea = field.NewInt64(table, "is_limit_area")
	b.LimitAreas = field.NewString(table, "limit_areas")

	b.fillFieldMap()

	return b
}

func (b *bankList) WithContext(ctx context.Context) IBankListDo { return b.bankListDo.WithContext(ctx) }

func (b bankList) TableName() string { return b.bankListDo.TableName() }

func (b bankList) Alias() string { return b.bankListDo.Alias() }

func (b bankList) Columns(cols ...field.Expr) gen.Columns { return b.bankListDo.Columns(cols...) }

func (b *bankList) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := b.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (b *bankList) fillFieldMap() {
	b.fieldMap = make(map[string]field.Expr, 15)
	b.fieldMap["id"] = b.ID
	b.fieldMap["short_name"] = b.ShortName
	b.fieldMap["bank_name"] = b.BankName
	b.fieldMap["sort"] = b.Sort
	b.fieldMap["bank_type"] = b.BankType
	b.fieldMap["img_path"] = b.ImgPath
	b.fieldMap["is_open"] = b.IsOpen
	b.fieldMap["withdraw_type"] = b.WithdrawType
	b.fieldMap["is_3u"] = b.Is3U
	b.fieldMap["virtual_currency_name"] = b.VirtualCurrencyName
	b.fieldMap["created_at"] = b.CreatedAt
	b.fieldMap["updated_at"] = b.UpdatedAt
	b.fieldMap["funds_type"] = b.FundsType
	b.fieldMap["is_limit_area"] = b.IsLimitArea
	b.fieldMap["limit_areas"] = b.LimitAreas
}

func (b bankList) clone(db *gorm.DB) bankList {
	b.bankListDo.ReplaceConnPool(db.Statement.ConnPool)
	return b
}

func (b bankList) replaceDB(db *gorm.DB) bankList {
	b.bankListDo.ReplaceDB(db)
	return b
}

type bankListDo struct{ gen.DO }

type IBankListDo interface {
	gen.SubQuery
	Debug() IBankListDo
	WithContext(ctx context.Context) IBankListDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() IBankListDo
	WriteDB() IBankListDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) IBankListDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) IBankListDo
	Not(conds ...gen.Condition) IBankListDo
	Or(conds ...gen.Condition) IBankListDo
	Select(conds ...field.Expr) IBankListDo
	Where(conds ...gen.Condition) IBankListDo
	Order(conds ...field.Expr) IBankListDo
	Distinct(cols ...field.Expr) IBankListDo
	Omit(cols ...field.Expr) IBankListDo
	Join(table schema.Tabler, on ...field.Expr) IBankListDo
	LeftJoin(table schema.Tabler, on ...field.Expr) IBankListDo
	RightJoin(table schema.Tabler, on ...field.Expr) IBankListDo
	Group(cols ...field.Expr) IBankListDo
	Having(conds ...gen.Condition) IBankListDo
	Limit(limit int) IBankListDo
	Offset(offset int) IBankListDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) IBankListDo
	Unscoped() IBankListDo
	Create(values ...*model.BankList) error
	CreateInBatches(values []*model.BankList, batchSize int) error
	Save(values ...*model.BankList) error
	First() (*model.BankList, error)
	Take() (*model.BankList, error)
	Last() (*model.BankList, error)
	Find() ([]*model.BankList, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.BankList, err error)
	FindInBatches(result *[]*model.BankList, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.BankList) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) IBankListDo
	Assign(attrs ...field.AssignExpr) IBankListDo
	Joins(fields ...field.RelationField) IBankListDo
	Preload(fields ...field.RelationField) IBankListDo
	FirstOrInit() (*model.BankList, error)
	FirstOrCreate() (*model.BankList, error)
	FindByPage(offset int, limit int) (result []*model.BankList, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Rows() (*sql.Rows, error)
	Row() *sql.Row
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) IBankListDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (b bankListDo) Debug() IBankListDo {
	return b.withDO(b.DO.Debug())
}

func (b bankListDo) WithContext(ctx context.Context) IBankListDo {
	return b.withDO(b.DO.WithContext(ctx))
}

func (b bankListDo) ReadDB() IBankListDo {
	return b.Clauses(dbresolver.Read)
}

func (b bankListDo) WriteDB() IBankListDo {
	return b.Clauses(dbresolver.Write)
}

func (b bankListDo) Session(config *gorm.Session) IBankListDo {
	return b.withDO(b.DO.Session(config))
}

func (b bankListDo) Clauses(conds ...clause.Expression) IBankListDo {
	return b.withDO(b.DO.Clauses(conds...))
}

func (b bankListDo) Returning(value interface{}, columns ...string) IBankListDo {
	return b.withDO(b.DO.Returning(value, columns...))
}

func (b bankListDo) Not(conds ...gen.Condition) IBankListDo {
	return b.withDO(b.DO.Not(conds...))
}

func (b bankListDo) Or(conds ...gen.Condition) IBankListDo {
	return b.withDO(b.DO.Or(conds...))
}

func (b bankListDo) Select(conds ...field.Expr) IBankListDo {
	return b.withDO(b.DO.Select(conds...))
}

func (b bankListDo) Where(conds ...gen.Condition) IBankListDo {
	return b.withDO(b.DO.Where(conds...))
}

func (b bankListDo) Order(conds ...field.Expr) IBankListDo {
	return b.withDO(b.DO.Order(conds...))
}

func (b bankListDo) Distinct(cols ...field.Expr) IBankListDo {
	return b.withDO(b.DO.Distinct(cols...))
}

func (b bankListDo) Omit(cols ...field.Expr) IBankListDo {
	return b.withDO(b.DO.Omit(cols...))
}

func (b bankListDo) Join(table schema.Tabler, on ...field.Expr) IBankListDo {
	return b.withDO(b.DO.Join(table, on...))
}

func (b bankListDo) LeftJoin(table schema.Tabler, on ...field.Expr) IBankListDo {
	return b.withDO(b.DO.LeftJoin(table, on...))
}

func (b bankListDo) RightJoin(table schema.Tabler, on ...field.Expr) IBankListDo {
	return b.withDO(b.DO.RightJoin(table, on...))
}

func (b bankListDo) Group(cols ...field.Expr) IBankListDo {
	return b.withDO(b.DO.Group(cols...))
}

func (b bankListDo) Having(conds ...gen.Condition) IBankListDo {
	return b.withDO(b.DO.Having(conds...))
}

func (b bankListDo) Limit(limit int) IBankListDo {
	return b.withDO(b.DO.Limit(limit))
}

func (b bankListDo) Offset(offset int) IBankListDo {
	return b.withDO(b.DO.Offset(offset))
}

func (b bankListDo) Scopes(funcs ...func(gen.Dao) gen.Dao) IBankListDo {
	return b.withDO(b.DO.Scopes(funcs...))
}

func (b bankListDo) Unscoped() IBankListDo {
	return b.withDO(b.DO.Unscoped())
}

func (b bankListDo) Create(values ...*model.BankList) error {
	if len(values) == 0 {
		return nil
	}
	return b.DO.Create(values)
}

func (b bankListDo) CreateInBatches(values []*model.BankList, batchSize int) error {
	return b.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (b bankListDo) Save(values ...*model.BankList) error {
	if len(values) == 0 {
		return nil
	}
	return b.DO.Save(values)
}

func (b bankListDo) First() (*model.BankList, error) {
	if result, err := b.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.BankList), nil
	}
}

func (b bankListDo) Take() (*model.BankList, error) {
	if result, err := b.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.BankList), nil
	}
}

func (b bankListDo) Last() (*model.BankList, error) {
	if result, err := b.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.BankList), nil
	}
}

func (b bankListDo) Find() ([]*model.BankList, error) {
	result, err := b.DO.Find()
	return result.([]*model.BankList), err
}

func (b bankListDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.BankList, err error) {
	buf := make([]*model.BankList, 0, batchSize)
	err = b.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (b bankListDo) FindInBatches(result *[]*model.BankList, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return b.DO.FindInBatches(result, batchSize, fc)
}

func (b bankListDo) Attrs(attrs ...field.AssignExpr) IBankListDo {
	return b.withDO(b.DO.Attrs(attrs...))
}

func (b bankListDo) Assign(attrs ...field.AssignExpr) IBankListDo {
	return b.withDO(b.DO.Assign(attrs...))
}

func (b bankListDo) Joins(fields ...field.RelationField) IBankListDo {
	for _, _f := range fields {
		b = *b.withDO(b.DO.Joins(_f))
	}
	return &b
}

func (b bankListDo) Preload(fields ...field.RelationField) IBankListDo {
	for _, _f := range fields {
		b = *b.withDO(b.DO.Preload(_f))
	}
	return &b
}

func (b bankListDo) FirstOrInit() (*model.BankList, error) {
	if result, err := b.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.BankList), nil
	}
}

func (b bankListDo) FirstOrCreate() (*model.BankList, error) {
	if result, err := b.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.BankList), nil
	}
}

func (b bankListDo) FindByPage(offset int, limit int) (result []*model.BankList, count int64, err error) {
	result, err = b.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = b.Offset(-1).Limit(-1).Count()
	return
}

func (b bankListDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = b.Count()
	if err != nil {
		return
	}

	err = b.Offset(offset).Limit(limit).Scan(result)
	return
}

func (b bankListDo) Scan(result interface{}) (err error) {
	return b.DO.Scan(result)
}

func (b bankListDo) Delete(models ...*model.BankList) (result gen.ResultInfo, err error) {
	return b.DO.Delete(models)
}

func (b *bankListDo) withDO(do gen.Dao) *bankListDo {
	b.DO = *do.(*gen.DO)
	return b
}
