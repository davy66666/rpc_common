// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package query

import (
	"context"
	"database/sql"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"github.com/davy66666/rpc_common/dao/model"
)

func newWithdrawalChannelSub(db *gorm.DB, opts ...gen.DOOption) withdrawalChannelSub {
	_withdrawalChannelSub := withdrawalChannelSub{}

	_withdrawalChannelSub.withdrawalChannelSubDo.UseDB(db, opts...)
	_withdrawalChannelSub.withdrawalChannelSubDo.UseModel(&model.WithdrawalChannelSub{})

	tableName := _withdrawalChannelSub.withdrawalChannelSubDo.TableName()
	_withdrawalChannelSub.ALL = field.NewAsterisk(tableName)
	_withdrawalChannelSub.ID = field.NewInt64(tableName, "id")
	_withdrawalChannelSub.PayLevelID = field.NewString(tableName, "pay_level_id")
	_withdrawalChannelSub.PayTitle = field.NewString(tableName, "pay_title")
	_withdrawalChannelSub.WithdrawalChannelID = field.NewInt64(tableName, "withdrawal_channel_id")
	_withdrawalChannelSub.Type = field.NewInt64(tableName, "type")
	_withdrawalChannelSub.WithdrawalMinAmount = field.NewFloat64(tableName, "withdrawal_min_amount")
	_withdrawalChannelSub.WithdrawalMaxAmount = field.NewFloat64(tableName, "withdrawal_max_amount")
	_withdrawalChannelSub.MaxWithdraw = field.NewInt64(tableName, "max_withdraw")
	_withdrawalChannelSub.WithdrawFee = field.NewFloat64(tableName, "withdraw_fee")
	_withdrawalChannelSub.GiftMoneyRate = field.NewFloat64(tableName, "gift_money_rate")
	_withdrawalChannelSub.IsOpen = field.NewInt64(tableName, "is_open")
	_withdrawalChannelSub.CreatedAt = field.NewField(tableName, "created_at")
	_withdrawalChannelSub.UpdatedAt = field.NewField(tableName, "updated_at")
	_withdrawalChannelSub.AdminName = field.NewString(tableName, "admin_name")
	_withdrawalChannelSub.BankType = field.NewInt64(tableName, "bank_type")
	_withdrawalChannelSub.YhType = field.NewInt64(tableName, "yh_type")
	_withdrawalChannelSub.Sort = field.NewInt64(tableName, "sort")

	_withdrawalChannelSub.fillFieldMap()

	return _withdrawalChannelSub
}

// withdrawalChannelSub 提款通道二级菜单
type withdrawalChannelSub struct {
	withdrawalChannelSubDo withdrawalChannelSubDo

	ALL                 field.Asterisk
	ID                  field.Int64
	PayLevelID          field.String  // 会员分层ID
	PayTitle            field.String  // 关联取款类型
	WithdrawalChannelID field.Int64   // 提款通道id(关联withdrawal_channel表主键id)
	Type                field.Int64   // 提款通道类型(关联withdrawal_channel表type)
	WithdrawalMinAmount field.Float64 // 取款最小金额
	WithdrawalMaxAmount field.Float64 // 取款最大金额
	MaxWithdraw         field.Int64   // 取款最大次数
	WithdrawFee         field.Float64 // 取款手续费比例
	GiftMoneyRate       field.Float64
	IsOpen              field.Int64 // 是否启用
	CreatedAt           field.Field
	UpdatedAt           field.Field
	AdminName           field.String
	BankType            field.Int64 // 1:银行卡, 2:数字钱包, 3:易汇虚拟钱包, 4:支付宝, 5:微信, 6:数字人民币
	YhType              field.Int64 // 易汇取款类型
	Sort                field.Int64 // 排序

	fieldMap map[string]field.Expr
}

func (w withdrawalChannelSub) Table(newTableName string) *withdrawalChannelSub {
	w.withdrawalChannelSubDo.UseTable(newTableName)
	return w.updateTableName(newTableName)
}

func (w withdrawalChannelSub) As(alias string) *withdrawalChannelSub {
	w.withdrawalChannelSubDo.DO = *(w.withdrawalChannelSubDo.As(alias).(*gen.DO))
	return w.updateTableName(alias)
}

func (w *withdrawalChannelSub) updateTableName(table string) *withdrawalChannelSub {
	w.ALL = field.NewAsterisk(table)
	w.ID = field.NewInt64(table, "id")
	w.PayLevelID = field.NewString(table, "pay_level_id")
	w.PayTitle = field.NewString(table, "pay_title")
	w.WithdrawalChannelID = field.NewInt64(table, "withdrawal_channel_id")
	w.Type = field.NewInt64(table, "type")
	w.WithdrawalMinAmount = field.NewFloat64(table, "withdrawal_min_amount")
	w.WithdrawalMaxAmount = field.NewFloat64(table, "withdrawal_max_amount")
	w.MaxWithdraw = field.NewInt64(table, "max_withdraw")
	w.WithdrawFee = field.NewFloat64(table, "withdraw_fee")
	w.GiftMoneyRate = field.NewFloat64(table, "gift_money_rate")
	w.IsOpen = field.NewInt64(table, "is_open")
	w.CreatedAt = field.NewField(table, "created_at")
	w.UpdatedAt = field.NewField(table, "updated_at")
	w.AdminName = field.NewString(table, "admin_name")
	w.BankType = field.NewInt64(table, "bank_type")
	w.YhType = field.NewInt64(table, "yh_type")
	w.Sort = field.NewInt64(table, "sort")

	w.fillFieldMap()

	return w
}

func (w *withdrawalChannelSub) WithContext(ctx context.Context) IWithdrawalChannelSubDo {
	return w.withdrawalChannelSubDo.WithContext(ctx)
}

func (w withdrawalChannelSub) TableName() string { return w.withdrawalChannelSubDo.TableName() }

func (w withdrawalChannelSub) Alias() string { return w.withdrawalChannelSubDo.Alias() }

func (w withdrawalChannelSub) Columns(cols ...field.Expr) gen.Columns {
	return w.withdrawalChannelSubDo.Columns(cols...)
}

func (w *withdrawalChannelSub) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := w.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (w *withdrawalChannelSub) fillFieldMap() {
	w.fieldMap = make(map[string]field.Expr, 17)
	w.fieldMap["id"] = w.ID
	w.fieldMap["pay_level_id"] = w.PayLevelID
	w.fieldMap["pay_title"] = w.PayTitle
	w.fieldMap["withdrawal_channel_id"] = w.WithdrawalChannelID
	w.fieldMap["type"] = w.Type
	w.fieldMap["withdrawal_min_amount"] = w.WithdrawalMinAmount
	w.fieldMap["withdrawal_max_amount"] = w.WithdrawalMaxAmount
	w.fieldMap["max_withdraw"] = w.MaxWithdraw
	w.fieldMap["withdraw_fee"] = w.WithdrawFee
	w.fieldMap["gift_money_rate"] = w.GiftMoneyRate
	w.fieldMap["is_open"] = w.IsOpen
	w.fieldMap["created_at"] = w.CreatedAt
	w.fieldMap["updated_at"] = w.UpdatedAt
	w.fieldMap["admin_name"] = w.AdminName
	w.fieldMap["bank_type"] = w.BankType
	w.fieldMap["yh_type"] = w.YhType
	w.fieldMap["sort"] = w.Sort
}

func (w withdrawalChannelSub) clone(db *gorm.DB) withdrawalChannelSub {
	w.withdrawalChannelSubDo.ReplaceConnPool(db.Statement.ConnPool)
	return w
}

func (w withdrawalChannelSub) replaceDB(db *gorm.DB) withdrawalChannelSub {
	w.withdrawalChannelSubDo.ReplaceDB(db)
	return w
}

type withdrawalChannelSubDo struct{ gen.DO }

type IWithdrawalChannelSubDo interface {
	gen.SubQuery
	Debug() IWithdrawalChannelSubDo
	WithContext(ctx context.Context) IWithdrawalChannelSubDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() IWithdrawalChannelSubDo
	WriteDB() IWithdrawalChannelSubDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) IWithdrawalChannelSubDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) IWithdrawalChannelSubDo
	Not(conds ...gen.Condition) IWithdrawalChannelSubDo
	Or(conds ...gen.Condition) IWithdrawalChannelSubDo
	Select(conds ...field.Expr) IWithdrawalChannelSubDo
	Where(conds ...gen.Condition) IWithdrawalChannelSubDo
	Order(conds ...field.Expr) IWithdrawalChannelSubDo
	Distinct(cols ...field.Expr) IWithdrawalChannelSubDo
	Omit(cols ...field.Expr) IWithdrawalChannelSubDo
	Join(table schema.Tabler, on ...field.Expr) IWithdrawalChannelSubDo
	LeftJoin(table schema.Tabler, on ...field.Expr) IWithdrawalChannelSubDo
	RightJoin(table schema.Tabler, on ...field.Expr) IWithdrawalChannelSubDo
	Group(cols ...field.Expr) IWithdrawalChannelSubDo
	Having(conds ...gen.Condition) IWithdrawalChannelSubDo
	Limit(limit int) IWithdrawalChannelSubDo
	Offset(offset int) IWithdrawalChannelSubDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) IWithdrawalChannelSubDo
	Unscoped() IWithdrawalChannelSubDo
	Create(values ...*model.WithdrawalChannelSub) error
	CreateInBatches(values []*model.WithdrawalChannelSub, batchSize int) error
	Save(values ...*model.WithdrawalChannelSub) error
	First() (*model.WithdrawalChannelSub, error)
	Take() (*model.WithdrawalChannelSub, error)
	Last() (*model.WithdrawalChannelSub, error)
	Find() ([]*model.WithdrawalChannelSub, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.WithdrawalChannelSub, err error)
	FindInBatches(result *[]*model.WithdrawalChannelSub, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.WithdrawalChannelSub) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) IWithdrawalChannelSubDo
	Assign(attrs ...field.AssignExpr) IWithdrawalChannelSubDo
	Joins(fields ...field.RelationField) IWithdrawalChannelSubDo
	Preload(fields ...field.RelationField) IWithdrawalChannelSubDo
	FirstOrInit() (*model.WithdrawalChannelSub, error)
	FirstOrCreate() (*model.WithdrawalChannelSub, error)
	FindByPage(offset int, limit int) (result []*model.WithdrawalChannelSub, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Rows() (*sql.Rows, error)
	Row() *sql.Row
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) IWithdrawalChannelSubDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (w withdrawalChannelSubDo) Debug() IWithdrawalChannelSubDo {
	return w.withDO(w.DO.Debug())
}

func (w withdrawalChannelSubDo) WithContext(ctx context.Context) IWithdrawalChannelSubDo {
	return w.withDO(w.DO.WithContext(ctx))
}

func (w withdrawalChannelSubDo) ReadDB() IWithdrawalChannelSubDo {
	return w.Clauses(dbresolver.Read)
}

func (w withdrawalChannelSubDo) WriteDB() IWithdrawalChannelSubDo {
	return w.Clauses(dbresolver.Write)
}

func (w withdrawalChannelSubDo) Session(config *gorm.Session) IWithdrawalChannelSubDo {
	return w.withDO(w.DO.Session(config))
}

func (w withdrawalChannelSubDo) Clauses(conds ...clause.Expression) IWithdrawalChannelSubDo {
	return w.withDO(w.DO.Clauses(conds...))
}

func (w withdrawalChannelSubDo) Returning(value interface{}, columns ...string) IWithdrawalChannelSubDo {
	return w.withDO(w.DO.Returning(value, columns...))
}

func (w withdrawalChannelSubDo) Not(conds ...gen.Condition) IWithdrawalChannelSubDo {
	return w.withDO(w.DO.Not(conds...))
}

func (w withdrawalChannelSubDo) Or(conds ...gen.Condition) IWithdrawalChannelSubDo {
	return w.withDO(w.DO.Or(conds...))
}

func (w withdrawalChannelSubDo) Select(conds ...field.Expr) IWithdrawalChannelSubDo {
	return w.withDO(w.DO.Select(conds...))
}

func (w withdrawalChannelSubDo) Where(conds ...gen.Condition) IWithdrawalChannelSubDo {
	return w.withDO(w.DO.Where(conds...))
}

func (w withdrawalChannelSubDo) Order(conds ...field.Expr) IWithdrawalChannelSubDo {
	return w.withDO(w.DO.Order(conds...))
}

func (w withdrawalChannelSubDo) Distinct(cols ...field.Expr) IWithdrawalChannelSubDo {
	return w.withDO(w.DO.Distinct(cols...))
}

func (w withdrawalChannelSubDo) Omit(cols ...field.Expr) IWithdrawalChannelSubDo {
	return w.withDO(w.DO.Omit(cols...))
}

func (w withdrawalChannelSubDo) Join(table schema.Tabler, on ...field.Expr) IWithdrawalChannelSubDo {
	return w.withDO(w.DO.Join(table, on...))
}

func (w withdrawalChannelSubDo) LeftJoin(table schema.Tabler, on ...field.Expr) IWithdrawalChannelSubDo {
	return w.withDO(w.DO.LeftJoin(table, on...))
}

func (w withdrawalChannelSubDo) RightJoin(table schema.Tabler, on ...field.Expr) IWithdrawalChannelSubDo {
	return w.withDO(w.DO.RightJoin(table, on...))
}

func (w withdrawalChannelSubDo) Group(cols ...field.Expr) IWithdrawalChannelSubDo {
	return w.withDO(w.DO.Group(cols...))
}

func (w withdrawalChannelSubDo) Having(conds ...gen.Condition) IWithdrawalChannelSubDo {
	return w.withDO(w.DO.Having(conds...))
}

func (w withdrawalChannelSubDo) Limit(limit int) IWithdrawalChannelSubDo {
	return w.withDO(w.DO.Limit(limit))
}

func (w withdrawalChannelSubDo) Offset(offset int) IWithdrawalChannelSubDo {
	return w.withDO(w.DO.Offset(offset))
}

func (w withdrawalChannelSubDo) Scopes(funcs ...func(gen.Dao) gen.Dao) IWithdrawalChannelSubDo {
	return w.withDO(w.DO.Scopes(funcs...))
}

func (w withdrawalChannelSubDo) Unscoped() IWithdrawalChannelSubDo {
	return w.withDO(w.DO.Unscoped())
}

func (w withdrawalChannelSubDo) Create(values ...*model.WithdrawalChannelSub) error {
	if len(values) == 0 {
		return nil
	}
	return w.DO.Create(values)
}

func (w withdrawalChannelSubDo) CreateInBatches(values []*model.WithdrawalChannelSub, batchSize int) error {
	return w.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (w withdrawalChannelSubDo) Save(values ...*model.WithdrawalChannelSub) error {
	if len(values) == 0 {
		return nil
	}
	return w.DO.Save(values)
}

func (w withdrawalChannelSubDo) First() (*model.WithdrawalChannelSub, error) {
	if result, err := w.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.WithdrawalChannelSub), nil
	}
}

func (w withdrawalChannelSubDo) Take() (*model.WithdrawalChannelSub, error) {
	if result, err := w.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.WithdrawalChannelSub), nil
	}
}

func (w withdrawalChannelSubDo) Last() (*model.WithdrawalChannelSub, error) {
	if result, err := w.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.WithdrawalChannelSub), nil
	}
}

func (w withdrawalChannelSubDo) Find() ([]*model.WithdrawalChannelSub, error) {
	result, err := w.DO.Find()
	return result.([]*model.WithdrawalChannelSub), err
}

func (w withdrawalChannelSubDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.WithdrawalChannelSub, err error) {
	buf := make([]*model.WithdrawalChannelSub, 0, batchSize)
	err = w.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (w withdrawalChannelSubDo) FindInBatches(result *[]*model.WithdrawalChannelSub, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return w.DO.FindInBatches(result, batchSize, fc)
}

func (w withdrawalChannelSubDo) Attrs(attrs ...field.AssignExpr) IWithdrawalChannelSubDo {
	return w.withDO(w.DO.Attrs(attrs...))
}

func (w withdrawalChannelSubDo) Assign(attrs ...field.AssignExpr) IWithdrawalChannelSubDo {
	return w.withDO(w.DO.Assign(attrs...))
}

func (w withdrawalChannelSubDo) Joins(fields ...field.RelationField) IWithdrawalChannelSubDo {
	for _, _f := range fields {
		w = *w.withDO(w.DO.Joins(_f))
	}
	return &w
}

func (w withdrawalChannelSubDo) Preload(fields ...field.RelationField) IWithdrawalChannelSubDo {
	for _, _f := range fields {
		w = *w.withDO(w.DO.Preload(_f))
	}
	return &w
}

func (w withdrawalChannelSubDo) FirstOrInit() (*model.WithdrawalChannelSub, error) {
	if result, err := w.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.WithdrawalChannelSub), nil
	}
}

func (w withdrawalChannelSubDo) FirstOrCreate() (*model.WithdrawalChannelSub, error) {
	if result, err := w.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.WithdrawalChannelSub), nil
	}
}

func (w withdrawalChannelSubDo) FindByPage(offset int, limit int) (result []*model.WithdrawalChannelSub, count int64, err error) {
	result, err = w.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = w.Offset(-1).Limit(-1).Count()
	return
}

func (w withdrawalChannelSubDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = w.Count()
	if err != nil {
		return
	}

	err = w.Offset(offset).Limit(limit).Scan(result)
	return
}

func (w withdrawalChannelSubDo) Scan(result interface{}) (err error) {
	return w.DO.Scan(result)
}

func (w withdrawalChannelSubDo) Delete(models ...*model.WithdrawalChannelSub) (result gen.ResultInfo, err error) {
	return w.DO.Delete(models)
}

func (w *withdrawalChannelSubDo) withDO(do gen.Dao) *withdrawalChannelSubDo {
	w.DO = *do.(*gen.DO)
	return w
}
