// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package query

import (
	"context"
	"database/sql"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"github.com/davy66666/rpc_common/dao/model"
)

func newOfflinePay(db *gorm.DB, opts ...gen.DOOption) offlinePay {
	_offlinePay := offlinePay{}

	_offlinePay.offlinePayDo.UseDB(db, opts...)
	_offlinePay.offlinePayDo.UseModel(&model.OfflinePay{})

	tableName := _offlinePay.offlinePayDo.TableName()
	_offlinePay.ALL = field.NewAsterisk(tableName)
	_offlinePay.ID = field.NewInt64(tableName, "id")
	_offlinePay.PayType = field.NewString(tableName, "pay_type")
	_offlinePay.PayCode = field.NewString(tableName, "pay_code")
	_offlinePay.PayName = field.NewString(tableName, "pay_name")
	_offlinePay.Username = field.NewString(tableName, "username")
	_offlinePay.Account = field.NewString(tableName, "account")
	_offlinePay.Address = field.NewString(tableName, "address")
	_offlinePay.PayLevel = field.NewString(tableName, "pay_level")
	_offlinePay.IsSaoma = field.NewInt64(tableName, "is_saoma")
	_offlinePay.ImgPath = field.NewString(tableName, "img_path")
	_offlinePay.Platform = field.NewString(tableName, "platform")
	_offlinePay.MinMoney = field.NewFloat64(tableName, "min_money")
	_offlinePay.MaxMoney = field.NewFloat64(tableName, "max_money")
	_offlinePay.IsRange = field.NewInt64(tableName, "is_range")
	_offlinePay.ExRate = field.NewFloat64(tableName, "ex_rate")
	_offlinePay.QuickAmount = field.NewString(tableName, "quick_amount")
	_offlinePay.AdminUser = field.NewString(tableName, "admin_user")
	_offlinePay.Remark = field.NewString(tableName, "remark")
	_offlinePay.Sort = field.NewInt64(tableName, "sort")
	_offlinePay.BetAmountRate = field.NewInt64(tableName, "bet_amount_rate")
	_offlinePay.BankType = field.NewInt64(tableName, "bank_type")
	_offlinePay.IsThird = field.NewInt64(tableName, "is_third")
	_offlinePay.IsOpen = field.NewInt64(tableName, "is_open")
	_offlinePay.IsMatchFastPay = field.NewInt64(tableName, "is_match_fast_pay")
	_offlinePay.IsLastMatch = field.NewInt64(tableName, "is_last_match")
	_offlinePay.CreatedAt = field.NewField(tableName, "created_at")
	_offlinePay.UpdatedAt = field.NewField(tableName, "updated_at")
	_offlinePay.CompanyDiscount = field.NewFloat64(tableName, "company_discount")
	_offlinePay.UsdtDiscount = field.NewFloat64(tableName, "usdt_discount")

	_offlinePay.fillFieldMap()

	return _offlinePay
}

type offlinePay struct {
	offlinePayDo offlinePayDo

	ALL             field.Asterisk
	ID              field.Int64
	PayType         field.String  // pay_types表中的en_name
	PayCode         field.String  // 银行简称
	PayName         field.String  // 银行名称
	Username        field.String  // 姓名
	Account         field.String  // 银行卡号码
	Address         field.String  // 分行地址
	PayLevel        field.String  // 支付类别 多个以逗号分隔
	IsSaoma         field.Int64   // 0:否 1:扫码
	ImgPath         field.String  // 图片路径
	Platform        field.String  // 支付开放的支付平台,1:手机端;4:pc端
	MinMoney        field.Float64 // 支付最小金额
	MaxMoney        field.Float64 // 支付最大金额
	IsRange         field.Int64   // 是否是范围0:否；1：是
	ExRate          field.Float64 // 虚拟货币汇率
	QuickAmount     field.String  // 存款金额:多个值,则用逗号隔开
	AdminUser       field.String  // 编辑者
	Remark          field.String  // 备注
	Sort            field.Int64   // 排序
	BetAmountRate   field.Int64   // 打码量倍数
	BankType        field.Int64   // 1:银行卡, 2:数字钱包
	IsThird         field.Int64   // 是否是第三方支付0:否；1：是
	IsOpen          field.Int64   // 是否开启0:否;1:是
	IsMatchFastPay  field.Int64   // 是否匹配极速充值：0否，1是；只支持银行卡类型
	IsLastMatch     field.Int64   // 是否是最后一次匹配的银行卡：0否，1是；轮询匹配机制
	CreatedAt       field.Field
	UpdatedAt       field.Field
	CompanyDiscount field.Float64 // 公司入款优惠比例
	UsdtDiscount    field.Float64 // usdt入款优惠比例

	fieldMap map[string]field.Expr
}

func (o offlinePay) Table(newTableName string) *offlinePay {
	o.offlinePayDo.UseTable(newTableName)
	return o.updateTableName(newTableName)
}

func (o offlinePay) As(alias string) *offlinePay {
	o.offlinePayDo.DO = *(o.offlinePayDo.As(alias).(*gen.DO))
	return o.updateTableName(alias)
}

func (o *offlinePay) updateTableName(table string) *offlinePay {
	o.ALL = field.NewAsterisk(table)
	o.ID = field.NewInt64(table, "id")
	o.PayType = field.NewString(table, "pay_type")
	o.PayCode = field.NewString(table, "pay_code")
	o.PayName = field.NewString(table, "pay_name")
	o.Username = field.NewString(table, "username")
	o.Account = field.NewString(table, "account")
	o.Address = field.NewString(table, "address")
	o.PayLevel = field.NewString(table, "pay_level")
	o.IsSaoma = field.NewInt64(table, "is_saoma")
	o.ImgPath = field.NewString(table, "img_path")
	o.Platform = field.NewString(table, "platform")
	o.MinMoney = field.NewFloat64(table, "min_money")
	o.MaxMoney = field.NewFloat64(table, "max_money")
	o.IsRange = field.NewInt64(table, "is_range")
	o.ExRate = field.NewFloat64(table, "ex_rate")
	o.QuickAmount = field.NewString(table, "quick_amount")
	o.AdminUser = field.NewString(table, "admin_user")
	o.Remark = field.NewString(table, "remark")
	o.Sort = field.NewInt64(table, "sort")
	o.BetAmountRate = field.NewInt64(table, "bet_amount_rate")
	o.BankType = field.NewInt64(table, "bank_type")
	o.IsThird = field.NewInt64(table, "is_third")
	o.IsOpen = field.NewInt64(table, "is_open")
	o.IsMatchFastPay = field.NewInt64(table, "is_match_fast_pay")
	o.IsLastMatch = field.NewInt64(table, "is_last_match")
	o.CreatedAt = field.NewField(table, "created_at")
	o.UpdatedAt = field.NewField(table, "updated_at")
	o.CompanyDiscount = field.NewFloat64(table, "company_discount")
	o.UsdtDiscount = field.NewFloat64(table, "usdt_discount")

	o.fillFieldMap()

	return o
}

func (o *offlinePay) WithContext(ctx context.Context) IOfflinePayDo {
	return o.offlinePayDo.WithContext(ctx)
}

func (o offlinePay) TableName() string { return o.offlinePayDo.TableName() }

func (o offlinePay) Alias() string { return o.offlinePayDo.Alias() }

func (o offlinePay) Columns(cols ...field.Expr) gen.Columns { return o.offlinePayDo.Columns(cols...) }

func (o *offlinePay) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := o.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (o *offlinePay) fillFieldMap() {
	o.fieldMap = make(map[string]field.Expr, 29)
	o.fieldMap["id"] = o.ID
	o.fieldMap["pay_type"] = o.PayType
	o.fieldMap["pay_code"] = o.PayCode
	o.fieldMap["pay_name"] = o.PayName
	o.fieldMap["username"] = o.Username
	o.fieldMap["account"] = o.Account
	o.fieldMap["address"] = o.Address
	o.fieldMap["pay_level"] = o.PayLevel
	o.fieldMap["is_saoma"] = o.IsSaoma
	o.fieldMap["img_path"] = o.ImgPath
	o.fieldMap["platform"] = o.Platform
	o.fieldMap["min_money"] = o.MinMoney
	o.fieldMap["max_money"] = o.MaxMoney
	o.fieldMap["is_range"] = o.IsRange
	o.fieldMap["ex_rate"] = o.ExRate
	o.fieldMap["quick_amount"] = o.QuickAmount
	o.fieldMap["admin_user"] = o.AdminUser
	o.fieldMap["remark"] = o.Remark
	o.fieldMap["sort"] = o.Sort
	o.fieldMap["bet_amount_rate"] = o.BetAmountRate
	o.fieldMap["bank_type"] = o.BankType
	o.fieldMap["is_third"] = o.IsThird
	o.fieldMap["is_open"] = o.IsOpen
	o.fieldMap["is_match_fast_pay"] = o.IsMatchFastPay
	o.fieldMap["is_last_match"] = o.IsLastMatch
	o.fieldMap["created_at"] = o.CreatedAt
	o.fieldMap["updated_at"] = o.UpdatedAt
	o.fieldMap["company_discount"] = o.CompanyDiscount
	o.fieldMap["usdt_discount"] = o.UsdtDiscount
}

func (o offlinePay) clone(db *gorm.DB) offlinePay {
	o.offlinePayDo.ReplaceConnPool(db.Statement.ConnPool)
	return o
}

func (o offlinePay) replaceDB(db *gorm.DB) offlinePay {
	o.offlinePayDo.ReplaceDB(db)
	return o
}

type offlinePayDo struct{ gen.DO }

type IOfflinePayDo interface {
	gen.SubQuery
	Debug() IOfflinePayDo
	WithContext(ctx context.Context) IOfflinePayDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() IOfflinePayDo
	WriteDB() IOfflinePayDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) IOfflinePayDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) IOfflinePayDo
	Not(conds ...gen.Condition) IOfflinePayDo
	Or(conds ...gen.Condition) IOfflinePayDo
	Select(conds ...field.Expr) IOfflinePayDo
	Where(conds ...gen.Condition) IOfflinePayDo
	Order(conds ...field.Expr) IOfflinePayDo
	Distinct(cols ...field.Expr) IOfflinePayDo
	Omit(cols ...field.Expr) IOfflinePayDo
	Join(table schema.Tabler, on ...field.Expr) IOfflinePayDo
	LeftJoin(table schema.Tabler, on ...field.Expr) IOfflinePayDo
	RightJoin(table schema.Tabler, on ...field.Expr) IOfflinePayDo
	Group(cols ...field.Expr) IOfflinePayDo
	Having(conds ...gen.Condition) IOfflinePayDo
	Limit(limit int) IOfflinePayDo
	Offset(offset int) IOfflinePayDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) IOfflinePayDo
	Unscoped() IOfflinePayDo
	Create(values ...*model.OfflinePay) error
	CreateInBatches(values []*model.OfflinePay, batchSize int) error
	Save(values ...*model.OfflinePay) error
	First() (*model.OfflinePay, error)
	Take() (*model.OfflinePay, error)
	Last() (*model.OfflinePay, error)
	Find() ([]*model.OfflinePay, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.OfflinePay, err error)
	FindInBatches(result *[]*model.OfflinePay, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.OfflinePay) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) IOfflinePayDo
	Assign(attrs ...field.AssignExpr) IOfflinePayDo
	Joins(fields ...field.RelationField) IOfflinePayDo
	Preload(fields ...field.RelationField) IOfflinePayDo
	FirstOrInit() (*model.OfflinePay, error)
	FirstOrCreate() (*model.OfflinePay, error)
	FindByPage(offset int, limit int) (result []*model.OfflinePay, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Rows() (*sql.Rows, error)
	Row() *sql.Row
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) IOfflinePayDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (o offlinePayDo) Debug() IOfflinePayDo {
	return o.withDO(o.DO.Debug())
}

func (o offlinePayDo) WithContext(ctx context.Context) IOfflinePayDo {
	return o.withDO(o.DO.WithContext(ctx))
}

func (o offlinePayDo) ReadDB() IOfflinePayDo {
	return o.Clauses(dbresolver.Read)
}

func (o offlinePayDo) WriteDB() IOfflinePayDo {
	return o.Clauses(dbresolver.Write)
}

func (o offlinePayDo) Session(config *gorm.Session) IOfflinePayDo {
	return o.withDO(o.DO.Session(config))
}

func (o offlinePayDo) Clauses(conds ...clause.Expression) IOfflinePayDo {
	return o.withDO(o.DO.Clauses(conds...))
}

func (o offlinePayDo) Returning(value interface{}, columns ...string) IOfflinePayDo {
	return o.withDO(o.DO.Returning(value, columns...))
}

func (o offlinePayDo) Not(conds ...gen.Condition) IOfflinePayDo {
	return o.withDO(o.DO.Not(conds...))
}

func (o offlinePayDo) Or(conds ...gen.Condition) IOfflinePayDo {
	return o.withDO(o.DO.Or(conds...))
}

func (o offlinePayDo) Select(conds ...field.Expr) IOfflinePayDo {
	return o.withDO(o.DO.Select(conds...))
}

func (o offlinePayDo) Where(conds ...gen.Condition) IOfflinePayDo {
	return o.withDO(o.DO.Where(conds...))
}

func (o offlinePayDo) Order(conds ...field.Expr) IOfflinePayDo {
	return o.withDO(o.DO.Order(conds...))
}

func (o offlinePayDo) Distinct(cols ...field.Expr) IOfflinePayDo {
	return o.withDO(o.DO.Distinct(cols...))
}

func (o offlinePayDo) Omit(cols ...field.Expr) IOfflinePayDo {
	return o.withDO(o.DO.Omit(cols...))
}

func (o offlinePayDo) Join(table schema.Tabler, on ...field.Expr) IOfflinePayDo {
	return o.withDO(o.DO.Join(table, on...))
}

func (o offlinePayDo) LeftJoin(table schema.Tabler, on ...field.Expr) IOfflinePayDo {
	return o.withDO(o.DO.LeftJoin(table, on...))
}

func (o offlinePayDo) RightJoin(table schema.Tabler, on ...field.Expr) IOfflinePayDo {
	return o.withDO(o.DO.RightJoin(table, on...))
}

func (o offlinePayDo) Group(cols ...field.Expr) IOfflinePayDo {
	return o.withDO(o.DO.Group(cols...))
}

func (o offlinePayDo) Having(conds ...gen.Condition) IOfflinePayDo {
	return o.withDO(o.DO.Having(conds...))
}

func (o offlinePayDo) Limit(limit int) IOfflinePayDo {
	return o.withDO(o.DO.Limit(limit))
}

func (o offlinePayDo) Offset(offset int) IOfflinePayDo {
	return o.withDO(o.DO.Offset(offset))
}

func (o offlinePayDo) Scopes(funcs ...func(gen.Dao) gen.Dao) IOfflinePayDo {
	return o.withDO(o.DO.Scopes(funcs...))
}

func (o offlinePayDo) Unscoped() IOfflinePayDo {
	return o.withDO(o.DO.Unscoped())
}

func (o offlinePayDo) Create(values ...*model.OfflinePay) error {
	if len(values) == 0 {
		return nil
	}
	return o.DO.Create(values)
}

func (o offlinePayDo) CreateInBatches(values []*model.OfflinePay, batchSize int) error {
	return o.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (o offlinePayDo) Save(values ...*model.OfflinePay) error {
	if len(values) == 0 {
		return nil
	}
	return o.DO.Save(values)
}

func (o offlinePayDo) First() (*model.OfflinePay, error) {
	if result, err := o.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.OfflinePay), nil
	}
}

func (o offlinePayDo) Take() (*model.OfflinePay, error) {
	if result, err := o.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.OfflinePay), nil
	}
}

func (o offlinePayDo) Last() (*model.OfflinePay, error) {
	if result, err := o.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.OfflinePay), nil
	}
}

func (o offlinePayDo) Find() ([]*model.OfflinePay, error) {
	result, err := o.DO.Find()
	return result.([]*model.OfflinePay), err
}

func (o offlinePayDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.OfflinePay, err error) {
	buf := make([]*model.OfflinePay, 0, batchSize)
	err = o.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (o offlinePayDo) FindInBatches(result *[]*model.OfflinePay, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return o.DO.FindInBatches(result, batchSize, fc)
}

func (o offlinePayDo) Attrs(attrs ...field.AssignExpr) IOfflinePayDo {
	return o.withDO(o.DO.Attrs(attrs...))
}

func (o offlinePayDo) Assign(attrs ...field.AssignExpr) IOfflinePayDo {
	return o.withDO(o.DO.Assign(attrs...))
}

func (o offlinePayDo) Joins(fields ...field.RelationField) IOfflinePayDo {
	for _, _f := range fields {
		o = *o.withDO(o.DO.Joins(_f))
	}
	return &o
}

func (o offlinePayDo) Preload(fields ...field.RelationField) IOfflinePayDo {
	for _, _f := range fields {
		o = *o.withDO(o.DO.Preload(_f))
	}
	return &o
}

func (o offlinePayDo) FirstOrInit() (*model.OfflinePay, error) {
	if result, err := o.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.OfflinePay), nil
	}
}

func (o offlinePayDo) FirstOrCreate() (*model.OfflinePay, error) {
	if result, err := o.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.OfflinePay), nil
	}
}

func (o offlinePayDo) FindByPage(offset int, limit int) (result []*model.OfflinePay, count int64, err error) {
	result, err = o.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = o.Offset(-1).Limit(-1).Count()
	return
}

func (o offlinePayDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = o.Count()
	if err != nil {
		return
	}

	err = o.Offset(offset).Limit(limit).Scan(result)
	return
}

func (o offlinePayDo) Scan(result interface{}) (err error) {
	return o.DO.Scan(result)
}

func (o offlinePayDo) Delete(models ...*model.OfflinePay) (result gen.ResultInfo, err error) {
	return o.DO.Delete(models)
}

func (o *offlinePayDo) withDO(do gen.Dao) *offlinePayDo {
	o.DO = *do.(*gen.DO)
	return o
}
