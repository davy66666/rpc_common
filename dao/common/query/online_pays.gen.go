// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package query

import (
	"context"
	"database/sql"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"github.com/davy66666/rpc_common/dao/model"
)

func newOnlinePay(db *gorm.DB, opts ...gen.DOOption) onlinePay {
	_onlinePay := onlinePay{}

	_onlinePay.onlinePayDo.UseDB(db, opts...)
	_onlinePay.onlinePayDo.UseModel(&model.OnlinePay{})

	tableName := _onlinePay.onlinePayDo.TableName()
	_onlinePay.ALL = field.NewAsterisk(tableName)
	_onlinePay.ID = field.NewInt64(tableName, "id")
	_onlinePay.PayCode = field.NewString(tableName, "pay_code")
	_onlinePay.PayName = field.NewString(tableName, "pay_name")
	_onlinePay.PayType = field.NewString(tableName, "pay_type")
	_onlinePay.Account = field.NewString(tableName, "account")
	_onlinePay.MerchantKey = field.NewString(tableName, "merchant_key")
	_onlinePay.ChannelCode = field.NewString(tableName, "channel_code")
	_onlinePay.Gateway = field.NewString(tableName, "gateway")
	_onlinePay.PayURL = field.NewString(tableName, "pay_url")
	_onlinePay.MinMoney = field.NewFloat64(tableName, "min_money")
	_onlinePay.MaxMoney = field.NewFloat64(tableName, "max_money")
	_onlinePay.PayLevel = field.NewString(tableName, "pay_level")
	_onlinePay.IP = field.NewString(tableName, "ip")
	_onlinePay.Sort = field.NewInt64(tableName, "sort")
	_onlinePay.Platform = field.NewString(tableName, "platform")
	_onlinePay.IsSaoma = field.NewInt64(tableName, "is_saoma")
	_onlinePay.IsDaifu = field.NewInt64(tableName, "is_daifu")
	_onlinePay.IsZhuanka = field.NewInt64(tableName, "is_zhuanka")
	_onlinePay.IsRange = field.NewInt64(tableName, "is_range")
	_onlinePay.BankType = field.NewInt64(tableName, "bank_type")
	_onlinePay.ExRate = field.NewFloat64(tableName, "ex_rate")
	_onlinePay.QuickAmount = field.NewString(tableName, "quick_amount")
	_onlinePay.Remark = field.NewString(tableName, "remark")
	_onlinePay.Extra = field.NewString(tableName, "extra")
	_onlinePay.AdminUser = field.NewString(tableName, "admin_user")
	_onlinePay.BetAmountRate = field.NewInt64(tableName, "bet_amount_rate")
	_onlinePay.IsOpen = field.NewInt64(tableName, "is_open")
	_onlinePay.IsThird = field.NewInt64(tableName, "is_third")
	_onlinePay.CreatedAt = field.NewField(tableName, "created_at")
	_onlinePay.UpdatedAt = field.NewField(tableName, "updated_at")
	_onlinePay.DailyMaxMoney = field.NewFloat64(tableName, "daily_max_money")
	_onlinePay.GiftMoneyRate = field.NewFloat64(tableName, "gift_money_rate")
	_onlinePay.BoRemark = field.NewString(tableName, "bo_remark")
	_onlinePay.PcIsRange = field.NewInt64(tableName, "pc_is_range")
	_onlinePay.PcQuickAmount = field.NewString(tableName, "pc_quick_amount")
	_onlinePay.IPList = field.NewString(tableName, "ip_list")
	_onlinePay.IsMatchFastPay = field.NewInt64(tableName, "is_match_fast_pay")
	_onlinePay.ChannelName = field.NewString(tableName, "channel_name")
	_onlinePay.RecommendedChannel = field.NewString(tableName, "recommended_channel")
	_onlinePay.LastPayType = field.NewInt64(tableName, "last_pay_type")

	_onlinePay.fillFieldMap()

	return _onlinePay
}

type onlinePay struct {
	onlinePayDo onlinePayDo

	ALL                field.Asterisk
	ID                 field.Int64
	PayCode            field.String  // 支付英文名
	PayName            field.String  // 支付英中文名
	PayType            field.String  // pay_types表中的en_name
	Account            field.String  // 商户号
	MerchantKey        field.String  // 商户密匙
	ChannelCode        field.String  // 通道编码
	Gateway            field.String  // 第三方网关地址
	PayURL             field.String  // 支付地址
	MinMoney           field.Float64 // 支付最小金额
	MaxMoney           field.Float64 // 支付最大金额
	PayLevel           field.String  // 支付类别 多个以逗号分隔
	IP                 field.String  // 第三方ip
	Sort               field.Int64   // 排序
	Platform           field.String  // 支付开放的支付平台,1:手机端;4:pc端
	IsSaoma            field.Int64   // 0:否 1:扫码
	IsDaifu            field.Int64   // 是否是代付0:否；1：是
	IsZhuanka          field.Int64   // 是否是转卡三方
	IsRange            field.Int64   // 是否是固定金额0:是；1：否;0:代表固定金额
	BankType           field.Int64   // 1:银行卡, 2:数字钱包
	ExRate             field.Float64 // 汇率
	QuickAmount        field.String  // 存款金额:多个值,则用逗号隔开
	Remark             field.String  // 前台的支付提示
	Extra              field.String  // 备用字段
	AdminUser          field.String  // 编辑者
	BetAmountRate      field.Int64   // 打码量倍数
	IsOpen             field.Int64   // 是否开启0:否;1:是
	IsThird            field.Int64   // 是否是第三方支付0:否；1：是
	CreatedAt          field.Field
	UpdatedAt          field.Field
	DailyMaxMoney      field.Float64 // 单日最大额度
	GiftMoneyRate      field.Float64 // 优惠比例
	BoRemark           field.String  // 备注
	PcIsRange          field.Int64   // 电脑是否是固定金额0:是；1：否
	PcQuickAmount      field.String  // 电脑存款金额:多个值,则用逗号隔开
	IPList             field.String  // IP过滤列表
	IsMatchFastPay     field.Int64   // 是否开启极速充值匹配0:禁用;1:开启
	ChannelName        field.String  // 通道名称
	RecommendedChannel field.String  // 推荐通道
	LastPayType        field.Int64   // 兜底支付类型 1：极速

	fieldMap map[string]field.Expr
}

func (o onlinePay) Table(newTableName string) *onlinePay {
	o.onlinePayDo.UseTable(newTableName)
	return o.updateTableName(newTableName)
}

func (o onlinePay) As(alias string) *onlinePay {
	o.onlinePayDo.DO = *(o.onlinePayDo.As(alias).(*gen.DO))
	return o.updateTableName(alias)
}

func (o *onlinePay) updateTableName(table string) *onlinePay {
	o.ALL = field.NewAsterisk(table)
	o.ID = field.NewInt64(table, "id")
	o.PayCode = field.NewString(table, "pay_code")
	o.PayName = field.NewString(table, "pay_name")
	o.PayType = field.NewString(table, "pay_type")
	o.Account = field.NewString(table, "account")
	o.MerchantKey = field.NewString(table, "merchant_key")
	o.ChannelCode = field.NewString(table, "channel_code")
	o.Gateway = field.NewString(table, "gateway")
	o.PayURL = field.NewString(table, "pay_url")
	o.MinMoney = field.NewFloat64(table, "min_money")
	o.MaxMoney = field.NewFloat64(table, "max_money")
	o.PayLevel = field.NewString(table, "pay_level")
	o.IP = field.NewString(table, "ip")
	o.Sort = field.NewInt64(table, "sort")
	o.Platform = field.NewString(table, "platform")
	o.IsSaoma = field.NewInt64(table, "is_saoma")
	o.IsDaifu = field.NewInt64(table, "is_daifu")
	o.IsZhuanka = field.NewInt64(table, "is_zhuanka")
	o.IsRange = field.NewInt64(table, "is_range")
	o.BankType = field.NewInt64(table, "bank_type")
	o.ExRate = field.NewFloat64(table, "ex_rate")
	o.QuickAmount = field.NewString(table, "quick_amount")
	o.Remark = field.NewString(table, "remark")
	o.Extra = field.NewString(table, "extra")
	o.AdminUser = field.NewString(table, "admin_user")
	o.BetAmountRate = field.NewInt64(table, "bet_amount_rate")
	o.IsOpen = field.NewInt64(table, "is_open")
	o.IsThird = field.NewInt64(table, "is_third")
	o.CreatedAt = field.NewField(table, "created_at")
	o.UpdatedAt = field.NewField(table, "updated_at")
	o.DailyMaxMoney = field.NewFloat64(table, "daily_max_money")
	o.GiftMoneyRate = field.NewFloat64(table, "gift_money_rate")
	o.BoRemark = field.NewString(table, "bo_remark")
	o.PcIsRange = field.NewInt64(table, "pc_is_range")
	o.PcQuickAmount = field.NewString(table, "pc_quick_amount")
	o.IPList = field.NewString(table, "ip_list")
	o.IsMatchFastPay = field.NewInt64(table, "is_match_fast_pay")
	o.ChannelName = field.NewString(table, "channel_name")
	o.RecommendedChannel = field.NewString(table, "recommended_channel")
	o.LastPayType = field.NewInt64(table, "last_pay_type")

	o.fillFieldMap()

	return o
}

func (o *onlinePay) WithContext(ctx context.Context) IOnlinePayDo {
	return o.onlinePayDo.WithContext(ctx)
}

func (o onlinePay) TableName() string { return o.onlinePayDo.TableName() }

func (o onlinePay) Alias() string { return o.onlinePayDo.Alias() }

func (o onlinePay) Columns(cols ...field.Expr) gen.Columns { return o.onlinePayDo.Columns(cols...) }

func (o *onlinePay) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := o.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (o *onlinePay) fillFieldMap() {
	o.fieldMap = make(map[string]field.Expr, 40)
	o.fieldMap["id"] = o.ID
	o.fieldMap["pay_code"] = o.PayCode
	o.fieldMap["pay_name"] = o.PayName
	o.fieldMap["pay_type"] = o.PayType
	o.fieldMap["account"] = o.Account
	o.fieldMap["merchant_key"] = o.MerchantKey
	o.fieldMap["channel_code"] = o.ChannelCode
	o.fieldMap["gateway"] = o.Gateway
	o.fieldMap["pay_url"] = o.PayURL
	o.fieldMap["min_money"] = o.MinMoney
	o.fieldMap["max_money"] = o.MaxMoney
	o.fieldMap["pay_level"] = o.PayLevel
	o.fieldMap["ip"] = o.IP
	o.fieldMap["sort"] = o.Sort
	o.fieldMap["platform"] = o.Platform
	o.fieldMap["is_saoma"] = o.IsSaoma
	o.fieldMap["is_daifu"] = o.IsDaifu
	o.fieldMap["is_zhuanka"] = o.IsZhuanka
	o.fieldMap["is_range"] = o.IsRange
	o.fieldMap["bank_type"] = o.BankType
	o.fieldMap["ex_rate"] = o.ExRate
	o.fieldMap["quick_amount"] = o.QuickAmount
	o.fieldMap["remark"] = o.Remark
	o.fieldMap["extra"] = o.Extra
	o.fieldMap["admin_user"] = o.AdminUser
	o.fieldMap["bet_amount_rate"] = o.BetAmountRate
	o.fieldMap["is_open"] = o.IsOpen
	o.fieldMap["is_third"] = o.IsThird
	o.fieldMap["created_at"] = o.CreatedAt
	o.fieldMap["updated_at"] = o.UpdatedAt
	o.fieldMap["daily_max_money"] = o.DailyMaxMoney
	o.fieldMap["gift_money_rate"] = o.GiftMoneyRate
	o.fieldMap["bo_remark"] = o.BoRemark
	o.fieldMap["pc_is_range"] = o.PcIsRange
	o.fieldMap["pc_quick_amount"] = o.PcQuickAmount
	o.fieldMap["ip_list"] = o.IPList
	o.fieldMap["is_match_fast_pay"] = o.IsMatchFastPay
	o.fieldMap["channel_name"] = o.ChannelName
	o.fieldMap["recommended_channel"] = o.RecommendedChannel
	o.fieldMap["last_pay_type"] = o.LastPayType
}

func (o onlinePay) clone(db *gorm.DB) onlinePay {
	o.onlinePayDo.ReplaceConnPool(db.Statement.ConnPool)
	return o
}

func (o onlinePay) replaceDB(db *gorm.DB) onlinePay {
	o.onlinePayDo.ReplaceDB(db)
	return o
}

type onlinePayDo struct{ gen.DO }

type IOnlinePayDo interface {
	gen.SubQuery
	Debug() IOnlinePayDo
	WithContext(ctx context.Context) IOnlinePayDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() IOnlinePayDo
	WriteDB() IOnlinePayDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) IOnlinePayDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) IOnlinePayDo
	Not(conds ...gen.Condition) IOnlinePayDo
	Or(conds ...gen.Condition) IOnlinePayDo
	Select(conds ...field.Expr) IOnlinePayDo
	Where(conds ...gen.Condition) IOnlinePayDo
	Order(conds ...field.Expr) IOnlinePayDo
	Distinct(cols ...field.Expr) IOnlinePayDo
	Omit(cols ...field.Expr) IOnlinePayDo
	Join(table schema.Tabler, on ...field.Expr) IOnlinePayDo
	LeftJoin(table schema.Tabler, on ...field.Expr) IOnlinePayDo
	RightJoin(table schema.Tabler, on ...field.Expr) IOnlinePayDo
	Group(cols ...field.Expr) IOnlinePayDo
	Having(conds ...gen.Condition) IOnlinePayDo
	Limit(limit int) IOnlinePayDo
	Offset(offset int) IOnlinePayDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) IOnlinePayDo
	Unscoped() IOnlinePayDo
	Create(values ...*model.OnlinePay) error
	CreateInBatches(values []*model.OnlinePay, batchSize int) error
	Save(values ...*model.OnlinePay) error
	First() (*model.OnlinePay, error)
	Take() (*model.OnlinePay, error)
	Last() (*model.OnlinePay, error)
	Find() ([]*model.OnlinePay, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.OnlinePay, err error)
	FindInBatches(result *[]*model.OnlinePay, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.OnlinePay) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) IOnlinePayDo
	Assign(attrs ...field.AssignExpr) IOnlinePayDo
	Joins(fields ...field.RelationField) IOnlinePayDo
	Preload(fields ...field.RelationField) IOnlinePayDo
	FirstOrInit() (*model.OnlinePay, error)
	FirstOrCreate() (*model.OnlinePay, error)
	FindByPage(offset int, limit int) (result []*model.OnlinePay, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Rows() (*sql.Rows, error)
	Row() *sql.Row
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) IOnlinePayDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (o onlinePayDo) Debug() IOnlinePayDo {
	return o.withDO(o.DO.Debug())
}

func (o onlinePayDo) WithContext(ctx context.Context) IOnlinePayDo {
	return o.withDO(o.DO.WithContext(ctx))
}

func (o onlinePayDo) ReadDB() IOnlinePayDo {
	return o.Clauses(dbresolver.Read)
}

func (o onlinePayDo) WriteDB() IOnlinePayDo {
	return o.Clauses(dbresolver.Write)
}

func (o onlinePayDo) Session(config *gorm.Session) IOnlinePayDo {
	return o.withDO(o.DO.Session(config))
}

func (o onlinePayDo) Clauses(conds ...clause.Expression) IOnlinePayDo {
	return o.withDO(o.DO.Clauses(conds...))
}

func (o onlinePayDo) Returning(value interface{}, columns ...string) IOnlinePayDo {
	return o.withDO(o.DO.Returning(value, columns...))
}

func (o onlinePayDo) Not(conds ...gen.Condition) IOnlinePayDo {
	return o.withDO(o.DO.Not(conds...))
}

func (o onlinePayDo) Or(conds ...gen.Condition) IOnlinePayDo {
	return o.withDO(o.DO.Or(conds...))
}

func (o onlinePayDo) Select(conds ...field.Expr) IOnlinePayDo {
	return o.withDO(o.DO.Select(conds...))
}

func (o onlinePayDo) Where(conds ...gen.Condition) IOnlinePayDo {
	return o.withDO(o.DO.Where(conds...))
}

func (o onlinePayDo) Order(conds ...field.Expr) IOnlinePayDo {
	return o.withDO(o.DO.Order(conds...))
}

func (o onlinePayDo) Distinct(cols ...field.Expr) IOnlinePayDo {
	return o.withDO(o.DO.Distinct(cols...))
}

func (o onlinePayDo) Omit(cols ...field.Expr) IOnlinePayDo {
	return o.withDO(o.DO.Omit(cols...))
}

func (o onlinePayDo) Join(table schema.Tabler, on ...field.Expr) IOnlinePayDo {
	return o.withDO(o.DO.Join(table, on...))
}

func (o onlinePayDo) LeftJoin(table schema.Tabler, on ...field.Expr) IOnlinePayDo {
	return o.withDO(o.DO.LeftJoin(table, on...))
}

func (o onlinePayDo) RightJoin(table schema.Tabler, on ...field.Expr) IOnlinePayDo {
	return o.withDO(o.DO.RightJoin(table, on...))
}

func (o onlinePayDo) Group(cols ...field.Expr) IOnlinePayDo {
	return o.withDO(o.DO.Group(cols...))
}

func (o onlinePayDo) Having(conds ...gen.Condition) IOnlinePayDo {
	return o.withDO(o.DO.Having(conds...))
}

func (o onlinePayDo) Limit(limit int) IOnlinePayDo {
	return o.withDO(o.DO.Limit(limit))
}

func (o onlinePayDo) Offset(offset int) IOnlinePayDo {
	return o.withDO(o.DO.Offset(offset))
}

func (o onlinePayDo) Scopes(funcs ...func(gen.Dao) gen.Dao) IOnlinePayDo {
	return o.withDO(o.DO.Scopes(funcs...))
}

func (o onlinePayDo) Unscoped() IOnlinePayDo {
	return o.withDO(o.DO.Unscoped())
}

func (o onlinePayDo) Create(values ...*model.OnlinePay) error {
	if len(values) == 0 {
		return nil
	}
	return o.DO.Create(values)
}

func (o onlinePayDo) CreateInBatches(values []*model.OnlinePay, batchSize int) error {
	return o.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (o onlinePayDo) Save(values ...*model.OnlinePay) error {
	if len(values) == 0 {
		return nil
	}
	return o.DO.Save(values)
}

func (o onlinePayDo) First() (*model.OnlinePay, error) {
	if result, err := o.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.OnlinePay), nil
	}
}

func (o onlinePayDo) Take() (*model.OnlinePay, error) {
	if result, err := o.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.OnlinePay), nil
	}
}

func (o onlinePayDo) Last() (*model.OnlinePay, error) {
	if result, err := o.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.OnlinePay), nil
	}
}

func (o onlinePayDo) Find() ([]*model.OnlinePay, error) {
	result, err := o.DO.Find()
	return result.([]*model.OnlinePay), err
}

func (o onlinePayDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.OnlinePay, err error) {
	buf := make([]*model.OnlinePay, 0, batchSize)
	err = o.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (o onlinePayDo) FindInBatches(result *[]*model.OnlinePay, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return o.DO.FindInBatches(result, batchSize, fc)
}

func (o onlinePayDo) Attrs(attrs ...field.AssignExpr) IOnlinePayDo {
	return o.withDO(o.DO.Attrs(attrs...))
}

func (o onlinePayDo) Assign(attrs ...field.AssignExpr) IOnlinePayDo {
	return o.withDO(o.DO.Assign(attrs...))
}

func (o onlinePayDo) Joins(fields ...field.RelationField) IOnlinePayDo {
	for _, _f := range fields {
		o = *o.withDO(o.DO.Joins(_f))
	}
	return &o
}

func (o onlinePayDo) Preload(fields ...field.RelationField) IOnlinePayDo {
	for _, _f := range fields {
		o = *o.withDO(o.DO.Preload(_f))
	}
	return &o
}

func (o onlinePayDo) FirstOrInit() (*model.OnlinePay, error) {
	if result, err := o.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.OnlinePay), nil
	}
}

func (o onlinePayDo) FirstOrCreate() (*model.OnlinePay, error) {
	if result, err := o.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.OnlinePay), nil
	}
}

func (o onlinePayDo) FindByPage(offset int, limit int) (result []*model.OnlinePay, count int64, err error) {
	result, err = o.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = o.Offset(-1).Limit(-1).Count()
	return
}

func (o onlinePayDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = o.Count()
	if err != nil {
		return
	}

	err = o.Offset(offset).Limit(limit).Scan(result)
	return
}

func (o onlinePayDo) Scan(result interface{}) (err error) {
	return o.DO.Scan(result)
}

func (o onlinePayDo) Delete(models ...*model.OnlinePay) (result gen.ResultInfo, err error) {
	return o.DO.Delete(models)
}

func (o *onlinePayDo) withDO(do gen.Dao) *onlinePayDo {
	o.DO = *do.(*gen.DO)
	return o
}
